
grbl_athul.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00007af4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007a80  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000005cc  00800100  00800100  00007af4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00007af4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00007b24  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000528  00000000  00000000  00007b64  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000083ba  00000000  00000000  0000808c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000229c  00000000  00000000  00010446  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004cbc  00000000  00000000  000126e2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000116c  00000000  00000000  000173a0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000017ce  00000000  00000000  0001850c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005e43  00000000  00000000  00019cda  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004f8  00000000  00000000  0001fb1d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 e5 04 	jmp	0x9ca	; 0x9ca <__ctors_end>
       4:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <__bad_interrupt>
       8:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <__bad_interrupt>
       c:	0c 94 50 11 	jmp	0x22a0	; 0x22a0 <__vector_3>
      10:	0c 94 23 36 	jmp	0x6c46	; 0x6c46 <__vector_4>
      14:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <__bad_interrupt>
      18:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <__bad_interrupt>
      1c:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <__bad_interrupt>
      20:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <__bad_interrupt>
      24:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <__bad_interrupt>
      28:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <__bad_interrupt>
      2c:	0c 94 84 2c 	jmp	0x5908	; 0x5908 <__vector_11>
      30:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <__bad_interrupt>
      34:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <__bad_interrupt>
      38:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <__bad_interrupt>
      3c:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <__bad_interrupt>
      40:	0c 94 67 2e 	jmp	0x5cce	; 0x5cce <__vector_16>
      44:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <__bad_interrupt>
      48:	0c 94 7c 28 	jmp	0x50f8	; 0x50f8 <__vector_18>
      4c:	0c 94 3e 28 	jmp	0x507c	; 0x507c <__vector_19>
      50:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <__bad_interrupt>
      54:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <__bad_interrupt>
      58:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <__bad_interrupt>
      5c:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <__bad_interrupt>
      60:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <__bad_interrupt>
      64:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <__bad_interrupt>
      68:	06 07       	cpc	r16, r22
      6a:	06 07       	cpc	r16, r22
      6c:	06 07       	cpc	r16, r22
      6e:	06 07       	cpc	r16, r22
      70:	9b 06       	cpc	r9, r27
      72:	18 10       	cpse	r1, r8
      74:	18 10       	cpse	r1, r8
      76:	18 10       	cpse	r1, r8
      78:	18 10       	cpse	r1, r8
      7a:	18 10       	cpse	r1, r8
      7c:	8f 06       	cpc	r8, r31
      7e:	18 10       	cpse	r1, r8
      80:	18 10       	cpse	r1, r8
      82:	18 10       	cpse	r1, r8
      84:	18 10       	cpse	r1, r8
      86:	18 10       	cpse	r1, r8
      88:	18 10       	cpse	r1, r8
      8a:	59 07       	cpc	r21, r25
      8c:	59 07       	cpc	r21, r25
      8e:	59 07       	cpc	r21, r25
      90:	91 07       	cpc	r25, r17
      92:	91 07       	cpc	r25, r17
      94:	18 10       	cpse	r1, r8
      96:	18 10       	cpse	r1, r8
      98:	18 10       	cpse	r1, r8
      9a:	18 10       	cpse	r1, r8
      9c:	18 10       	cpse	r1, r8
      9e:	18 10       	cpse	r1, r8
      a0:	8f 06       	cpc	r8, r31
      a2:	18 10       	cpse	r1, r8
      a4:	8f 06       	cpc	r8, r31
      a6:	18 10       	cpse	r1, r8
      a8:	18 10       	cpse	r1, r8
      aa:	18 10       	cpse	r1, r8
      ac:	18 10       	cpse	r1, r8
      ae:	18 10       	cpse	r1, r8
      b0:	18 10       	cpse	r1, r8
      b2:	18 10       	cpse	r1, r8
      b4:	06 07       	cpc	r16, r22
      b6:	18 10       	cpse	r1, r8
      b8:	bf 07       	cpc	r27, r31
      ba:	18 10       	cpse	r1, r8
      bc:	18 10       	cpse	r1, r8
      be:	9c 07       	cpc	r25, r28
      c0:	18 10       	cpse	r1, r8
      c2:	18 10       	cpse	r1, r8
      c4:	18 10       	cpse	r1, r8
      c6:	18 10       	cpse	r1, r8
      c8:	18 10       	cpse	r1, r8
      ca:	9c 07       	cpc	r25, r28
      cc:	18 10       	cpse	r1, r8
      ce:	18 10       	cpse	r1, r8
      d0:	18 10       	cpse	r1, r8
      d2:	9b 06       	cpc	r9, r27
      d4:	b4 07       	cpc	r27, r20
      d6:	b4 07       	cpc	r27, r20
      d8:	b4 07       	cpc	r27, r20
      da:	b4 07       	cpc	r27, r20
      dc:	b4 07       	cpc	r27, r20
      de:	b4 07       	cpc	r27, r20
      e0:	18 10       	cpse	r1, r8
      e2:	b9 07       	cpc	r27, r25
      e4:	18 10       	cpse	r1, r8
      e6:	18 10       	cpse	r1, r8
      e8:	18 10       	cpse	r1, r8
      ea:	18 10       	cpse	r1, r8
      ec:	18 10       	cpse	r1, r8
      ee:	18 10       	cpse	r1, r8
      f0:	18 10       	cpse	r1, r8
      f2:	18 10       	cpse	r1, r8
      f4:	18 10       	cpse	r1, r8
      f6:	18 10       	cpse	r1, r8
      f8:	18 10       	cpse	r1, r8
      fa:	18 10       	cpse	r1, r8
      fc:	18 10       	cpse	r1, r8
      fe:	18 10       	cpse	r1, r8
     100:	18 10       	cpse	r1, r8
     102:	18 10       	cpse	r1, r8
     104:	18 10       	cpse	r1, r8
     106:	18 10       	cpse	r1, r8
     108:	0c 07       	cpc	r16, r28
     10a:	18 10       	cpse	r1, r8
     10c:	18 10       	cpse	r1, r8
     10e:	18 10       	cpse	r1, r8
     110:	18 10       	cpse	r1, r8
     112:	18 10       	cpse	r1, r8
     114:	18 10       	cpse	r1, r8
     116:	18 10       	cpse	r1, r8
     118:	18 10       	cpse	r1, r8
     11a:	18 10       	cpse	r1, r8
     11c:	6d 07       	cpc	r22, r29
     11e:	6d 07       	cpc	r22, r29
     120:	8f 06       	cpc	r8, r31
     122:	86 07       	cpc	r24, r22
     124:	86 07       	cpc	r24, r22
     126:	ee 07       	cpc	r30, r30
     128:	ee 07       	cpc	r30, r30
     12a:	ee 07       	cpc	r30, r30
     12c:	fe 07       	cpc	r31, r30
     12e:	fe 07       	cpc	r31, r30
     130:	fe 07       	cpc	r31, r30
     132:	36 10       	cpse	r3, r6
     134:	36 10       	cpse	r3, r6
     136:	12 08       	sbc	r1, r2
     138:	12 08       	sbc	r1, r2
     13a:	36 10       	cpse	r3, r6
     13c:	36 10       	cpse	r3, r6
     13e:	36 10       	cpse	r3, r6
     140:	36 10       	cpse	r3, r6
     142:	36 10       	cpse	r3, r6
     144:	36 10       	cpse	r3, r6
     146:	36 10       	cpse	r3, r6
     148:	36 10       	cpse	r3, r6
     14a:	36 10       	cpse	r3, r6
     14c:	36 10       	cpse	r3, r6
     14e:	36 10       	cpse	r3, r6
     150:	36 10       	cpse	r3, r6
     152:	36 10       	cpse	r3, r6
     154:	36 10       	cpse	r3, r6
     156:	36 10       	cpse	r3, r6
     158:	36 10       	cpse	r3, r6
     15a:	36 10       	cpse	r3, r6
     15c:	36 10       	cpse	r3, r6
     15e:	36 10       	cpse	r3, r6
     160:	36 10       	cpse	r3, r6
     162:	ee 07       	cpc	r30, r30
     164:	43 08       	sbc	r4, r3
     166:	3a 10       	cpse	r3, r10
     168:	3a 10       	cpse	r3, r10
     16a:	4d 08       	sbc	r4, r13
     16c:	5a 08       	sbc	r5, r10
     16e:	67 08       	sbc	r6, r7
     170:	74 08       	sbc	r7, r4
     172:	3a 10       	cpse	r3, r10
     174:	78 08       	sbc	r7, r8
     176:	3a 10       	cpse	r3, r10
     178:	86 08       	sbc	r8, r6
     17a:	3a 10       	cpse	r3, r10
     17c:	90 08       	sbc	r9, r0
     17e:	9a 08       	sbc	r9, r10
     180:	cb 08       	sbc	r12, r11
     182:	3a 10       	cpse	r3, r10
     184:	3a 10       	cpse	r3, r10
     186:	3a 10       	cpse	r3, r10
     188:	a4 08       	sbc	r10, r4
     18a:	b1 08       	sbc	r11, r1
     18c:	be 08       	sbc	r11, r14
     18e:	cc 0e       	add	r12, r28
     190:	e1 0e       	add	r14, r17
     192:	00 0f       	add	r16, r16
     194:	e1 0e       	add	r14, r17
     196:	06 0f       	add	r16, r22
     198:	1d 0f       	add	r17, r29
     19a:	0c 0f       	add	r16, r28
     19c:	16 0f       	add	r17, r22
     19e:	32 0f       	add	r19, r18
     1a0:	3c 0f       	add	r19, r28
     1a2:	48 0f       	add	r20, r24
     1a4:	6a 0f       	add	r22, r26
     1a6:	8b 0f       	add	r24, r27
     1a8:	99 0f       	add	r25, r25
     1aa:	a8 0f       	add	r26, r24
     1ac:	b6 0f       	add	r27, r22
     1ae:	58 22       	and	r5, r24
     1b0:	5d 22       	and	r5, r29
     1b2:	62 22       	and	r6, r18
     1b4:	67 22       	and	r6, r23
     1b6:	6c 22       	and	r6, r28
     1b8:	71 22       	and	r7, r17
     1ba:	76 22       	and	r7, r22
     1bc:	7b 22       	and	r7, r27
     1be:	80 22       	and	r8, r16
     1c0:	85 22       	and	r8, r21
     1c2:	8a 22       	and	r8, r26
     1c4:	9e 22       	and	r9, r30
     1c6:	9e 22       	and	r9, r30
     1c8:	9e 22       	and	r9, r30
     1ca:	9e 22       	and	r9, r30
     1cc:	9e 22       	and	r9, r30
     1ce:	9e 22       	and	r9, r30
     1d0:	9e 22       	and	r9, r30
     1d2:	9e 22       	and	r9, r30
     1d4:	94 22       	and	r9, r20
     1d6:	8f 22       	and	r8, r31
     1d8:	99 22       	and	r9, r25
     1da:	f1 22       	and	r15, r17
     1dc:	f6 22       	and	r15, r22
     1de:	fb 22       	and	r15, r27
     1e0:	00 23       	and	r16, r16
     1e2:	05 23       	and	r16, r21
     1e4:	0a 23       	and	r16, r26
     1e6:	0f 23       	and	r16, r31
     1e8:	14 23       	and	r17, r20
     1ea:	2c 27       	eor	r18, r28
     1ec:	40 27       	eor	r20, r16
     1ee:	45 27       	eor	r20, r21
     1f0:	4e 27       	eor	r20, r30
     1f2:	3b 27       	eor	r19, r27
     1f4:	4e 27       	eor	r20, r30
     1f6:	4e 27       	eor	r20, r30
     1f8:	4e 27       	eor	r20, r30
     1fa:	31 27       	eor	r19, r17
     1fc:	4e 27       	eor	r20, r30
     1fe:	4e 27       	eor	r20, r30
     200:	4e 27       	eor	r20, r30
     202:	4e 27       	eor	r20, r30
     204:	4e 27       	eor	r20, r30
     206:	4e 27       	eor	r20, r30
     208:	4e 27       	eor	r20, r30
     20a:	36 27       	eor	r19, r22
     20c:	4e 27       	eor	r20, r30
     20e:	4e 27       	eor	r20, r30
     210:	4e 27       	eor	r20, r30
     212:	4e 27       	eor	r20, r30
     214:	4e 27       	eor	r20, r30
     216:	4e 27       	eor	r20, r30
     218:	4e 27       	eor	r20, r30
     21a:	4e 27       	eor	r20, r30
     21c:	4e 27       	eor	r20, r30
     21e:	4e 27       	eor	r20, r30
     220:	4e 27       	eor	r20, r30
     222:	4e 27       	eor	r20, r30
     224:	4e 27       	eor	r20, r30
     226:	4e 27       	eor	r20, r30
     228:	4e 27       	eor	r20, r30
     22a:	4a 27       	eor	r20, r26
     22c:	4e 27       	eor	r20, r30
     22e:	4e 27       	eor	r20, r30
     230:	4e 27       	eor	r20, r30
     232:	4e 27       	eor	r20, r30
     234:	4e 27       	eor	r20, r30
     236:	4e 27       	eor	r20, r30
     238:	4e 27       	eor	r20, r30
     23a:	4e 27       	eor	r20, r30
     23c:	4e 27       	eor	r20, r30
     23e:	4e 27       	eor	r20, r30
     240:	4e 27       	eor	r20, r30
     242:	4e 27       	eor	r20, r30
     244:	4e 27       	eor	r20, r30
     246:	4e 27       	eor	r20, r30
     248:	4e 27       	eor	r20, r30
     24a:	4e 27       	eor	r20, r30
     24c:	4e 27       	eor	r20, r30
     24e:	4e 27       	eor	r20, r30
     250:	4e 27       	eor	r20, r30
     252:	4e 27       	eor	r20, r30
     254:	4e 27       	eor	r20, r30
     256:	4e 27       	eor	r20, r30
     258:	4e 27       	eor	r20, r30
     25a:	4e 27       	eor	r20, r30
     25c:	4e 27       	eor	r20, r30
     25e:	4e 27       	eor	r20, r30
     260:	4e 27       	eor	r20, r30
     262:	4e 27       	eor	r20, r30
     264:	4e 27       	eor	r20, r30
     266:	4e 27       	eor	r20, r30
     268:	4e 27       	eor	r20, r30
     26a:	31 27       	eor	r19, r17
     26c:	7b 2a       	or	r7, r27
     26e:	81 2a       	or	r8, r17
     270:	84 2a       	or	r8, r20
     272:	89 2a       	or	r8, r25
     274:	8e 2a       	or	r8, r30
     276:	9c 2a       	or	r9, r28
     278:	aa 2a       	or	r10, r26
     27a:	35 2b       	or	r19, r21
     27c:	35 2b       	or	r19, r21
     27e:	35 2b       	or	r19, r21
     280:	b8 2a       	or	r11, r24
     282:	bb 2a       	or	r11, r27
     284:	c4 2a       	or	r12, r20
     286:	cd 2a       	or	r12, r29
     288:	35 2b       	or	r19, r21
     28a:	35 2b       	or	r19, r21
     28c:	35 2b       	or	r19, r21
     28e:	35 2b       	or	r19, r21
     290:	35 2b       	or	r19, r21
     292:	35 2b       	or	r19, r21
     294:	db 2a       	or	r13, r27
     296:	eb 2a       	or	r14, r27
     298:	fb 2a       	or	r15, r27
     29a:	09 2b       	or	r16, r25
     29c:	0c 2b       	or	r16, r28
     29e:	15 2b       	or	r17, r21
     2a0:	1e 2b       	or	r17, r30
     2a2:	25 2b       	or	r18, r21
     2a4:	08 4a       	sbci	r16, 0xA8	; 168
     2a6:	d7 3b       	cpi	r29, 0xB7	; 183
     2a8:	3b ce       	rjmp	.-906    	; 0xffffff20 <__eeprom_end+0xff7eff20>
     2aa:	01 6e       	ori	r16, 0xE1	; 225
     2ac:	84 bc       	out	0x24, r8	; 36
     2ae:	bf fd       	.word	0xfdbf	; ????
     2b0:	c1 2f       	mov	r28, r17
     2b2:	3d 6c       	ori	r19, 0xCD	; 205
     2b4:	74 31       	cpi	r23, 0x14	; 20
     2b6:	9a bd       	out	0x2a, r25	; 42
     2b8:	56 83       	std	Z+6, r21	; 0x06
     2ba:	3d da       	rcall	.-2950   	; 0xfffff736 <__eeprom_end+0xff7ef736>
     2bc:	3d 00       	.word	0x003d	; ????
     2be:	c7 7f       	andi	r28, 0xF7	; 247
     2c0:	11 be       	out	0x31, r1	; 49
     2c2:	d9 e4       	ldi	r29, 0x49	; 73
     2c4:	bb 4c       	sbci	r27, 0xCB	; 203
     2c6:	3e 91       	ld	r19, -X
     2c8:	6b aa       	std	Y+51, r6	; 0x33
     2ca:	aa be       	out	0x3a, r10	; 58
     2cc:	00 00       	nop
     2ce:	00 80       	ld	r0, Z
     2d0:	3f 05       	cpc	r19, r15
     2d2:	a8 4c       	sbci	r26, 0xC8	; 200
     2d4:	cd b2       	in	r12, 0x1d	; 29
     2d6:	d4 4e       	sbci	r29, 0xE4	; 228
     2d8:	b9 38       	cpi	r27, 0x89	; 137
     2da:	36 a9       	ldd	r19, Z+54	; 0x36
     2dc:	02 0c       	add	r0, r2
     2de:	50 b9       	out	0x00, r21	; 0
     2e0:	91 86       	std	Z+9, r9	; 0x09
     2e2:	88 08       	sbc	r8, r8
     2e4:	3c a6       	std	Y+44, r3	; 0x2c
     2e6:	aa aa       	std	Y+50, r10	; 0x32
     2e8:	2a be       	out	0x3a, r2	; 58
     2ea:	00 00       	nop
     2ec:	00 80       	ld	r0, Z
     2ee:	3f 00       	.word	0x003f	; ????

000002f0 <__trampolines_end>:
     2f0:	3e 0d       	add	r19, r14
     2f2:	0a 00       	.word	0x000a	; ????

000002f4 <__c.2888>:
     2f4:	2c 4c 69 6d 3a 00                                   ,Lim:.

000002fa <__c.2886>:
     2fa:	2c 52 58 3a 00                                      ,RX:.

000002ff <__c.2884>:
     2ff:	2c 42 75 66 3a 00                                   ,Buf:.

00000305 <__c.2879>:
     305:	2c 00                                               ,.

00000307 <__c.2877>:
     307:	2c 57 50 6f 73 3a 00                                ,WPos:.

0000030e <__c.2872>:
     30e:	2c 00                                               ,.

00000310 <__c.2870>:
     310:	2c 4d 50 6f 73 3a 00                                ,MPos:.

00000317 <__c.2868>:
     317:	3c 44 6f 6f 72 00                                   <Door.

0000031d <__c.2865>:
     31d:	3c 43 68 65 63 6b 00                                <Check.

00000324 <__c.2862>:
     324:	3c 41 6c 61 72 6d 00                                <Alarm.

0000032b <__c.2859>:
     32b:	3c 48 6f 6d 65 00                                   <Home.

00000331 <__c.2856>:
     331:	3c 48 6f 6c 64 00                                   <Hold.

00000337 <__c.2853>:
     337:	3c 52 75 6e 00                                      <Run.

0000033c <__c.2848>:
     33c:	3c 49 64 6c 65 00                                   <Idle.

00000342 <__c.2833>:
     342:	5d 0d 0a 00                                         ]...

00000346 <__c.2831>:
     346:	5b 30 2e 39 6a 2e 32 30 31 36 30 37 32 36 3a 00     [0.9j.20160726:.

00000356 <__c.2826>:
     356:	0d 0a 00                                            ...

00000359 <__c.2824>:
     359:	3d 00                                               =.

0000035b <__c.2822>:
     35b:	24 4e 00                                            $N.

0000035e <__c.2816>:
     35e:	5d 0d 0a 00                                         ]...

00000362 <__c.2814>:
     362:	20 53 00                                             S.

00000365 <__c.2812>:
     365:	20 46 00                                             F.

00000368 <__c.2810>:
     368:	20 54 00                                             T.

0000036b <__c.2808>:
     36b:	20 4d 38 00                                          M8.

0000036f <__c.2804>:
     36f:	20 4d 39 00                                          M9.

00000373 <__c.2801>:
     373:	20 4d 35 00                                          M5.

00000377 <__c.2798>:
     377:	20 4d 34 00                                          M4.

0000037b <__c.2794>:
     37b:	20 4d 33 00                                          M3.

0000037f <__c.2791>:
     37f:	20 4d 32 00                                          M2.

00000383 <__c.2788>:
     383:	20 4d 31 00                                          M1.

00000387 <__c.2784>:
     387:	20 4d 30 00                                          M0.

0000038b <__c.2781>:
     38b:	20 47 39 34 00                                       G94.

00000390 <__c.2779>:
     390:	20 47 39 33 00                                       G93.

00000395 <__c.2777>:
     395:	20 47 39 31 00                                       G91.

0000039a <__c.2775>:
     39a:	20 47 39 30 00                                       G90.

0000039f <__c.2773>:
     39f:	20 47 32 30 00                                       G20.

000003a4 <__c.2771>:
     3a4:	20 47 32 31 00                                       G21.

000003a9 <__c.2769>:
     3a9:	20 47 31 39 00                                       G19.

000003ae <__c.2766>:
     3ae:	20 47 31 38 00                                       G18.

000003b3 <__c.2762>:
     3b3:	20 47 31 37 00                                       G17.

000003b8 <__c.2759>:
     3b8:	20 47 00                                             G.

000003bb <__c.2757>:
     3bb:	47 33 38 2e 00                                      G38..

000003c0 <__c.2754>:
     3c0:	47 38 30 00                                         G80.

000003c4 <__c.2751>:
     3c4:	47 33 00                                            G3.

000003c7 <__c.2748>:
     3c7:	47 32 00                                            G2.

000003ca <__c.2745>:
     3ca:	47 31 00                                            G1.

000003cd <__c.2741>:
     3cd:	47 30 00                                            G0.

000003d0 <__c.2738>:
     3d0:	5b 00                                               [.

000003d2 <__c.2734>:
     3d2:	5d 0d 0a 00                                         ]...

000003d6 <__c.2732>:
     3d6:	5b 54 4c 4f 3a 00                                   [TLO:.

000003dc <__c.2727>:
     3dc:	5d 0d 0a 00                                         ]...

000003e0 <__c.2725>:
     3e0:	2c 00                                               ,.

000003e2 <__c.2723>:
     3e2:	5b 47 39 32 3a 00                                   [G92:.

000003e8 <__c.2715>:
     3e8:	5d 0d 0a 00                                         ]...

000003ec <__c.2713>:
     3ec:	2c 00                                               ,.

000003ee <__c.2711>:
     3ee:	3a 00                                               :.

000003f0 <__c.2708>:
     3f0:	33 30 00                                            30.

000003f3 <__c.2704>:
     3f3:	32 38 00                                            28.

000003f6 <__c.2701>:
     3f6:	5b 47 00                                            [G.

000003f9 <__c.2694>:
     3f9:	5d 0d 0a 00                                         ]...

000003fd <__c.2692>:
     3fd:	3a 00                                               :.

000003ff <__c.2687>:
     3ff:	2c 00                                               ,.

00000401 <__c.2685>:
     401:	5b 50 52 42 3a 00                                   [PRB:.

00000407 <__c.2673>:
     407:	29 0d 0a 00                                         )...

0000040b <__c.2671>:
     40b:	20 6d 61 78 20 74 72 61 76 65 6c 2c 20 6d 6d 00      max travel, mm.

0000041b <__c.2668>:
     41b:	20 61 63 63 65 6c 2c 20 6d 6d 2f 73 65 63 5e 32      accel, mm/sec^2
	...

0000042c <__c.2665>:
     42c:	20 6d 61 78 20 72 61 74 65 2c 20 6d 6d 2f 6d 69      max rate, mm/mi
     43c:	6e 00                                               n.

0000043e <__c.2661>:
     43e:	2c 20 73 74 65 70 2f 6d 6d 00                       , step/mm.

00000448 <__c.2658>:
     448:	7a 00                                               z.

0000044a <__c.2655>:
     44a:	79 00                                               y.

0000044c <__c.2651>:
     44c:	78 00                                               x.

0000044e <__c.2648>:
     44e:	20 28 00                                             (.

00000451 <__c.2641>:
     451:	3d 00                                               =.

00000453 <__c.2639>:
     453:	24 00                                               $.

00000455 <__c.2634>:
     455:	20 28 68 6f 6d 69 6e 67 20 70 75 6c 6c 2d 6f 66      (homing pull-of
     465:	66 2c 20 6d 6d 29 0d 0a 00                          f, mm)...

0000046e <__c.2632>:
     46e:	20 28 68 6f 6d 69 6e 67 20 64 65 62 6f 75 6e 63      (homing debounc
     47e:	65 2c 20 6d 73 65 63 29 0d 0a 24 32 37 3d 00        e, msec)..$27=.

0000048d <__c.2630>:
     48d:	20 28 68 6f 6d 69 6e 67 20 73 65 65 6b 2c 20 6d      (homing seek, m
     49d:	6d 2f 6d 69 6e 29 0d 0a 24 32 36 3d 00              m/min)..$26=.

000004aa <__c.2628>:
     4aa:	20 28 68 6f 6d 69 6e 67 20 66 65 65 64 2c 20 6d      (homing feed, m
     4ba:	6d 2f 6d 69 6e 29 0d 0a 24 32 35 3d 00              m/min)..$25=.

000004c7 <__c.2626>:
     4c7:	29 0d 0a 24 32 34 3d 00                             )..$24=.

000004cf <__c.2624>:
     4cf:	20 28 68 6f 6d 69 6e 67 20 64 69 72 20 69 6e 76      (homing dir inv
     4df:	65 72 74 20 6d 61 73 6b 3a 00                       ert mask:.

000004e9 <__c.2622>:
     4e9:	20 28 68 6f 6d 69 6e 67 20 63 79 63 6c 65 2c 20      (homing cycle, 
     4f9:	62 6f 6f 6c 29 0d 0a 24 32 33 3d 00                 bool)..$23=.

00000505 <__c.2620>:
     505:	20 28 68 61 72 64 20 6c 69 6d 69 74 73 2c 20 62      (hard limits, b
     515:	6f 6f 6c 29 0d 0a 24 32 32 3d 00                    ool)..$22=.

00000520 <__c.2618>:
     520:	20 28 73 6f 66 74 20 6c 69 6d 69 74 73 2c 20 62      (soft limits, b
     530:	6f 6f 6c 29 0d 0a 24 32 31 3d 00                    ool)..$21=.

0000053b <__c.2616>:
     53b:	20 28 72 65 70 6f 72 74 20 69 6e 63 68 65 73 2c      (report inches,
     54b:	20 62 6f 6f 6c 29 0d 0a 24 32 30 3d 00               bool)..$20=.

00000558 <__c.2614>:
     558:	20 28 61 72 63 20 74 6f 6c 65 72 61 6e 63 65 2c      (arc tolerance,
     568:	20 6d 6d 29 0d 0a 24 31 33 3d 00                     mm)..$13=.

00000573 <__c.2612>:
     573:	20 28 6a 75 6e 63 74 69 6f 6e 20 64 65 76 69 61      (junction devia
     583:	74 69 6f 6e 2c 20 6d 6d 29 0d 0a 24 31 32 3d 00     tion, mm)..$12=.

00000593 <__c.2610>:
     593:	29 0d 0a 24 31 31 3d 00                             )..$11=.

0000059b <__c.2608>:
     59b:	20 28 73 74 61 74 75 73 20 72 65 70 6f 72 74 20      (status report 
     5ab:	6d 61 73 6b 3a 00                                   mask:.

000005b1 <__c.2606>:
     5b1:	20 28 70 72 6f 62 65 20 70 69 6e 20 69 6e 76 65      (probe pin inve
     5c1:	72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 31 30 3d 00     rt, bool)..$10=.

000005d1 <__c.2604>:
     5d1:	20 28 6c 69 6d 69 74 20 70 69 6e 73 20 69 6e 76      (limit pins inv
     5e1:	65 72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 36 3d 00     ert, bool)..$6=.

000005f1 <__c.2602>:
     5f1:	20 28 73 74 65 70 20 65 6e 61 62 6c 65 20 69 6e      (step enable in
     601:	76 65 72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 35 3d     vert, bool)..$5=
	...

00000612 <__c.2600>:
     612:	29 0d 0a 24 34 3d 00                                )..$4=.

00000619 <__c.2598>:
     619:	20 28 64 69 72 20 70 6f 72 74 20 69 6e 76 65 72      (dir port inver
     629:	74 20 6d 61 73 6b 3a 00                             t mask:.

00000631 <__c.2596>:
     631:	29 0d 0a 24 33 3d 00                                )..$3=.

00000638 <__c.2594>:
     638:	20 28 73 74 65 70 20 70 6f 72 74 20 69 6e 76 65      (step port inve
     648:	72 74 20 6d 61 73 6b 3a 00                          rt mask:.

00000651 <__c.2592>:
     651:	20 28 73 74 65 70 20 69 64 6c 65 20 64 65 6c 61      (step idle dela
     661:	79 2c 20 6d 73 65 63 29 0d 0a 24 32 3d 00           y, msec)..$2=.

0000066f <__c.2590>:
     66f:	20 28 73 74 65 70 20 70 75 6c 73 65 2c 20 75 73      (step pulse, us
     67f:	65 63 29 0d 0a 24 31 3d 00                          ec)..$1=.

00000688 <__c.2588>:
     688:	24 30 3d 00                                         $0=.

0000068c <__c.2584>:
     68c:	24 24 20 28 76 69 65 77 20 47 72 62 6c 20 73 65     $$ (view Grbl se
     69c:	74 74 69 6e 67 73 29 0d 0a 24 23 20 28 76 69 65     ttings)..$# (vie
     6ac:	77 20 23 20 70 61 72 61 6d 65 74 65 72 73 29 0d     w # parameters).
     6bc:	0a 24 47 20 28 76 69 65 77 20 70 61 72 73 65 72     .$G (view parser
     6cc:	20 73 74 61 74 65 29 0d 0a 24 49 20 28 76 69 65      state)..$I (vie
     6dc:	77 20 62 75 69 6c 64 20 69 6e 66 6f 29 0d 0a 24     w build info)..$
     6ec:	4e 20 28 76 69 65 77 20 73 74 61 72 74 75 70 20     N (view startup 
     6fc:	62 6c 6f 63 6b 73 29 0d 0a 24 78 3d 76 61 6c 75     blocks)..$x=valu
     70c:	65 20 28 73 61 76 65 20 47 72 62 6c 20 73 65 74     e (save Grbl set
     71c:	74 69 6e 67 29 0d 0a 24 4e 78 3d 6c 69 6e 65 20     ting)..$Nx=line 
     72c:	28 73 61 76 65 20 73 74 61 72 74 75 70 20 62 6c     (save startup bl
     73c:	6f 63 6b 29 0d 0a 24 43 20 28 63 68 65 63 6b 20     ock)..$C (check 
     74c:	67 63 6f 64 65 20 6d 6f 64 65 29 0d 0a 24 58 20     gcode mode)..$X 
     75c:	28 6b 69 6c 6c 20 61 6c 61 72 6d 20 6c 6f 63 6b     (kill alarm lock
     76c:	29 0d 0a 24 48 20 28 72 75 6e 20 68 6f 6d 69 6e     )..$H (run homin
     77c:	67 20 63 79 63 6c 65 29 0d 0a 7e 20 28 63 79 63     g cycle)..~ (cyc
     78c:	6c 65 20 73 74 61 72 74 29 0d 0a 21 20 28 66 65     le start)..! (fe
     79c:	65 64 20 68 6f 6c 64 29 0d 0a 3f 20 28 63 75 72     ed hold)..? (cur
     7ac:	72 65 6e 74 20 73 74 61 74 75 73 29 0d 0a 63 74     rent status)..ct
     7bc:	72 6c 2d 78 20 28 72 65 73 65 74 20 47 72 62 6c     rl-x (reset Grbl
     7cc:	29 0d 0a 00                                         )...

000007d0 <__c.2580>:
     7d0:	0d 0a 47 72 62 6c 20 30 2e 39 6a 20 5b 27 24 27     ..Grbl 0.9j ['$'
     7e0:	20 66 6f 72 20 68 65 6c 70 5d 0d 0a 00               for help]...

000007ed <__c.2576>:
     7ed:	5d 0d 0a 00                                         ]...

000007f1 <__c.2574>:
     7f1:	52 65 73 74 6f 72 69 6e 67 20 64 65 66 61 75 6c     Restoring defaul
     801:	74 73 00                                            ts.

00000804 <__c.2571>:
     804:	50 67 6d 20 45 6e 64 00                             Pgm End.

0000080c <__c.2568>:
     80c:	43 68 65 63 6b 20 44 6f 6f 72 00                    Check Door.

00000817 <__c.2565>:
     817:	44 69 73 61 62 6c 65 64 00                          Disabled.

00000820 <__c.2562>:
     820:	45 6e 61 62 6c 65 64 00                             Enabled.

00000828 <__c.2559>:
     828:	43 61 75 74 69 6f 6e 3a 20 55 6e 6c 6f 63 6b 65     Caution: Unlocke
     838:	64 00                                               d.

0000083a <__c.2556>:
     83a:	27 24 48 27 7c 27 24 58 27 20 74 6f 20 75 6e 6c     '$H'|'$X' to unl
     84a:	6f 63 6b 00                                         ock.

0000084e <__c.2552>:
     84e:	52 65 73 65 74 20 74 6f 20 63 6f 6e 74 69 6e 75     Reset to continu
     85e:	65 00                                               e.

00000860 <__c.2549>:
     860:	5b 00                                               [.

00000862 <__c.2544>:
     862:	0d 0a 00                                            ...

00000865 <__c.2542>:
     865:	48 6f 6d 69 6e 67 20 66 61 69 6c 00                 Homing fail.

00000871 <__c.2539>:
     871:	50 72 6f 62 65 20 66 61 69 6c 00                    Probe fail.

0000087c <__c.2536>:
     87c:	41 62 6f 72 74 20 64 75 72 69 6e 67 20 63 79 63     Abort during cyc
     88c:	6c 65 00                                            le.

0000088f <__c.2533>:
     88f:	53 6f 66 74 20 6c 69 6d 69 74 00                    Soft limit.

0000089a <__c.2529>:
     89a:	48 61 72 64 20 6c 69 6d 69 74 00                    Hard limit.

000008a5 <__c.2526>:
     8a5:	41 4c 41 52 4d 3a 20 00                             ALARM: .

000008ad <__c.2521>:
     8ad:	0d 0a 00                                            ...

000008b0 <__c.2519>:
     8b0:	49 6e 76 61 6c 69 64 20 67 63 6f 64 65 20 49 44     Invalid gcode ID
     8c0:	3a 00                                               :.

000008c2 <__c.2516>:
     8c2:	55 6e 64 65 66 69 6e 65 64 20 66 65 65 64 20 72     Undefined feed r
     8d2:	61 74 65 00                                         ate.

000008d6 <__c.2513>:
     8d6:	55 6e 73 75 70 70 6f 72 74 65 64 20 63 6f 6d 6d     Unsupported comm
     8e6:	61 6e 64 00                                         and.

000008ea <__c.2510>:
     8ea:	4d 6f 64 61 6c 20 67 72 6f 75 70 20 76 69 6f 6c     Modal group viol
     8fa:	61 74 69 6f 6e 00                                   ation.

00000900 <__c.2507>:
     900:	4c 69 6e 65 20 6f 76 65 72 66 6c 6f 77 00           Line overflow.

0000090e <__c.2504>:
     90e:	48 6f 6d 69 6e 67 20 6e 6f 74 20 65 6e 61 62 6c     Homing not enabl
     91e:	65 64 00                                            ed.

00000921 <__c.2501>:
     921:	41 6c 61 72 6d 20 6c 6f 63 6b 00                    Alarm lock.

0000092c <__c.2498>:
     92c:	4e 6f 74 20 69 64 6c 65 00                          Not idle.

00000935 <__c.2495>:
     935:	45 45 50 52 4f 4d 20 72 65 61 64 20 66 61 69 6c     EEPROM read fail
     945:	2e 20 55 73 69 6e 67 20 64 65 66 61 75 6c 74 73     . Using defaults
	...

00000956 <__c.2492>:
     956:	56 61 6c 75 65 20 3c 20 33 20 75 73 65 63 00        Value < 3 usec.

00000965 <__c.2489>:
     965:	53 65 74 74 69 6e 67 20 64 69 73 61 62 6c 65 64     Setting disabled
	...

00000976 <__c.2486>:
     976:	56 61 6c 75 65 20 3c 20 30 00                       Value < 0.

00000980 <__c.2483>:
     980:	49 6e 76 61 6c 69 64 20 73 74 61 74 65 6d 65 6e     Invalid statemen
     990:	74 00                                               t.

00000992 <__c.2480>:
     992:	42 61 64 20 6e 75 6d 62 65 72 20 66 6f 72 6d 61     Bad number forma
     9a2:	74 00                                               t.

000009a4 <__c.2476>:
     9a4:	45 78 70 65 63 74 65 64 20 63 6f 6d 6d 61 6e 64     Expected command
     9b4:	20 6c 65 74 74 65 72 00                              letter.

000009bc <__c.2473>:
     9bc:	65 72 72 6f 72 3a 20 00                             error: .

000009c4 <__c.2471>:
     9c4:	6f 6b 0d 0a 00 00                                   ok....

000009ca <__ctors_end>:
     9ca:	11 24       	eor	r1, r1
     9cc:	1f be       	out	0x3f, r1	; 63
     9ce:	cf ef       	ldi	r28, 0xFF	; 255
     9d0:	d8 e0       	ldi	r29, 0x08	; 8
     9d2:	de bf       	out	0x3e, r29	; 62
     9d4:	cd bf       	out	0x3d, r28	; 61

000009d6 <__do_clear_bss>:
     9d6:	26 e0       	ldi	r18, 0x06	; 6
     9d8:	a0 e0       	ldi	r26, 0x00	; 0
     9da:	b1 e0       	ldi	r27, 0x01	; 1
     9dc:	01 c0       	rjmp	.+2      	; 0x9e0 <.do_clear_bss_start>

000009de <.do_clear_bss_loop>:
     9de:	1d 92       	st	X+, r1

000009e0 <.do_clear_bss_start>:
     9e0:	ac 3c       	cpi	r26, 0xCC	; 204
     9e2:	b2 07       	cpc	r27, r18
     9e4:	e1 f7       	brne	.-8      	; 0x9de <.do_clear_bss_loop>
     9e6:	0e 94 ed 13 	call	0x27da	; 0x27da <main>
     9ea:	0c 94 3e 3d 	jmp	0x7a7c	; 0x7a7c <_exit>

000009ee <__bad_interrupt>:
     9ee:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000009f2 <coolant_stop>:
}


void coolant_stop()
{
  COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
     9f2:	43 98       	cbi	0x08, 3	; 8
     9f4:	08 95       	ret

000009f6 <coolant_init>:
#include "grbl.h"


void coolant_init()
{
  COOLANT_FLOOD_DDR |= (1 << COOLANT_FLOOD_BIT);
     9f6:	3b 9a       	sbi	0x07, 3	; 7
  #ifdef ENABLE_M7
    COOLANT_MIST_DDR |= (1 << COOLANT_MIST_BIT);
  #endif
  coolant_stop();
     9f8:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <coolant_stop>
     9fc:	08 95       	ret

000009fe <coolant_set_state>:
}


void coolant_set_state(uint8_t mode)
{
  if (mode == COOLANT_FLOOD_ENABLE) {
     9fe:	82 30       	cpi	r24, 0x02	; 2
     a00:	11 f4       	brne	.+4      	; 0xa06 <coolant_set_state+0x8>
    COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
     a02:	43 9a       	sbi	0x08, 3	; 8
     a04:	08 95       	ret
    } else if (mode == COOLANT_MIST_ENABLE) {
      COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
  #endif

  } else {
    coolant_stop();
     a06:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <coolant_stop>
     a0a:	08 95       	ret

00000a0c <coolant_run>:
  }
}


void coolant_run(uint8_t mode)
{
     a0c:	cf 93       	push	r28
  if (sys.state == STATE_CHECK_MODE) { return; }
     a0e:	90 91 a1 05 	lds	r25, 0x05A1	; 0x8005a1 <sys+0x1>
     a12:	92 30       	cpi	r25, 0x02	; 2
     a14:	31 f0       	breq	.+12     	; 0xa22 <coolant_run+0x16>
     a16:	c8 2f       	mov	r28, r24
  protocol_buffer_synchronize(); // Ensure coolant turns on when specified in program.  
     a18:	0e 94 2a 22 	call	0x4454	; 0x4454 <protocol_buffer_synchronize>
  coolant_set_state(mode);
     a1c:	8c 2f       	mov	r24, r28
     a1e:	0e 94 ff 04 	call	0x9fe	; 0x9fe <coolant_set_state>
}
     a22:	cf 91       	pop	r28
     a24:	08 95       	ret

00000a26 <eeprom_get_char>:
 *  \param  addr  EEPROM address to read from.
 *  \return  The byte read from the EEPROM address.
 */
unsigned char eeprom_get_char( unsigned int addr )
{
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
     a26:	f9 99       	sbic	0x1f, 1	; 31
     a28:	fe cf       	rjmp	.-4      	; 0xa26 <eeprom_get_char>
	EEAR = addr; // Set EEPROM address register.
     a2a:	92 bd       	out	0x22, r25	; 34
     a2c:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
     a2e:	81 e0       	ldi	r24, 0x01	; 1
     a30:	8f bb       	out	0x1f, r24	; 31
	return EEDR; // Return the byte read from EEPROM.
     a32:	80 b5       	in	r24, 0x20	; 32
}
     a34:	08 95       	ret

00000a36 <eeprom_put_char>:
void eeprom_put_char( unsigned int addr, unsigned char new_value )
{
	char old_value; // Old EEPROM value.
	char diff_mask; // Difference mask, i.e. old value XOR new value.

	cli(); // Ensure atomic operation for the write operation.
     a36:	f8 94       	cli
	
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
     a38:	f9 99       	sbic	0x1f, 1	; 31
     a3a:	fe cf       	rjmp	.-4      	; 0xa38 <eeprom_put_char+0x2>
	#ifndef EEPROM_IGNORE_SELFPROG
	do {} while( SPMCSR & (1<<SELFPRGEN) ); // Wait for completion of SPM.
	#endif
	
	EEAR = addr; // Set EEPROM address register.
     a3c:	92 bd       	out	0x22, r25	; 34
     a3e:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
     a40:	81 e0       	ldi	r24, 0x01	; 1
     a42:	8f bb       	out	0x1f, r24	; 31
	old_value = EEDR; // Get old EEPROM value.
     a44:	80 b5       	in	r24, 0x20	; 32
	diff_mask = old_value ^ new_value; // Get bit differences.
     a46:	86 27       	eor	r24, r22
	
	// Check if any bits are changed to '1' in the new value.
	if( diff_mask & new_value ) {
     a48:	96 2f       	mov	r25, r22
     a4a:	98 23       	and	r25, r24
     a4c:	59 f0       	breq	.+22     	; 0xa64 <eeprom_put_char+0x2e>
		// Now we know that _some_ bits need to be erased to '1'.
		
		// Check if any bits in the new value are '0'.
		if( new_value != 0xff ) {
     a4e:	6f 3f       	cpi	r22, 0xFF	; 255
     a50:	29 f0       	breq	.+10     	; 0xa5c <eeprom_put_char+0x26>
			// Now we know that some bits need to be programmed to '0' also.
			
			EEDR = new_value; // Set EEPROM data register.
     a52:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
     a54:	84 e0       	ldi	r24, 0x04	; 4
     a56:	8f bb       	out	0x1f, r24	; 31
			       (0<<EEPM1) | (0<<EEPM0); // ...and Erase+Write mode.
			EECR |= (1<<EEPE);  // Start Erase+Write operation.
     a58:	f9 9a       	sbi	0x1f, 1	; 31
     a5a:	0a c0       	rjmp	.+20     	; 0xa70 <eeprom_put_char+0x3a>
		} else {
			// Now we know that all bits should be erased.

			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
     a5c:	84 e1       	ldi	r24, 0x14	; 20
     a5e:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM0);  // ...and Erase-only mode.
			EECR |= (1<<EEPE);  // Start Erase-only operation.
     a60:	f9 9a       	sbi	0x1f, 1	; 31
     a62:	06 c0       	rjmp	.+12     	; 0xa70 <eeprom_put_char+0x3a>
		}
	} else {
		// Now we know that _no_ bits need to be erased to '1'.
		
		// Check if any bits are changed from '1' in the old value.
		if( diff_mask ) {
     a64:	88 23       	and	r24, r24
     a66:	21 f0       	breq	.+8      	; 0xa70 <eeprom_put_char+0x3a>
			// Now we know that _some_ bits need to the programmed to '0'.
			
			EEDR = new_value;   // Set EEPROM data register.
     a68:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
     a6a:	84 e2       	ldi	r24, 0x24	; 36
     a6c:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM1);  // ...and Write-only mode.
			EECR |= (1<<EEPE);  // Start Write-only operation.
     a6e:	f9 9a       	sbi	0x1f, 1	; 31
		}
	}
	
	sei(); // Restore interrupt flag state.
     a70:	78 94       	sei
     a72:	08 95       	ret

00000a74 <memcpy_to_eeprom_with_checksum>:
}

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
     a74:	8f 92       	push	r8
     a76:	9f 92       	push	r9
     a78:	af 92       	push	r10
     a7a:	bf 92       	push	r11
     a7c:	cf 92       	push	r12
     a7e:	df 92       	push	r13
     a80:	ef 92       	push	r14
     a82:	ff 92       	push	r15
     a84:	0f 93       	push	r16
     a86:	1f 93       	push	r17
     a88:	cf 93       	push	r28
     a8a:	df 93       	push	r29
     a8c:	7c 01       	movw	r14, r24
     a8e:	8b 01       	movw	r16, r22
     a90:	6a 01       	movw	r12, r20
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
     a92:	41 15       	cp	r20, r1
     a94:	51 05       	cpc	r21, r1
     a96:	09 f1       	breq	.+66     	; 0xada <memcpy_to_eeprom_with_checksum+0x66>
     a98:	5a 01       	movw	r10, r20
     a9a:	c0 e0       	ldi	r28, 0x00	; 0
    checksum = (checksum << 1) || (checksum >> 7);
     a9c:	d1 e0       	ldi	r29, 0x01	; 1
     a9e:	01 c0       	rjmp	.+2      	; 0xaa2 <memcpy_to_eeprom_with_checksum+0x2e>
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
     aa0:	c4 01       	movw	r24, r8


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
     aa2:	c1 11       	cpse	r28, r1
     aa4:	08 c0       	rjmp	.+16     	; 0xab6 <memcpy_to_eeprom_with_checksum+0x42>
     aa6:	6c 2f       	mov	r22, r28
     aa8:	cc 0f       	add	r28, r28
     aaa:	77 0b       	sbc	r23, r23
     aac:	c7 2f       	mov	r28, r23
     aae:	cc 1f       	adc	r28, r28
     ab0:	cc 27       	eor	r28, r28
     ab2:	cc 1f       	adc	r28, r28
     ab4:	01 c0       	rjmp	.+2      	; 0xab8 <memcpy_to_eeprom_with_checksum+0x44>
     ab6:	cd 2f       	mov	r28, r29
    checksum += *source;
     ab8:	f8 01       	movw	r30, r16
     aba:	61 91       	ld	r22, Z+
     abc:	8f 01       	movw	r16, r30
     abe:	c6 0f       	add	r28, r22
    eeprom_put_char(destination++, *(source++)); 
     ac0:	4c 01       	movw	r8, r24
     ac2:	ff ef       	ldi	r31, 0xFF	; 255
     ac4:	8f 1a       	sub	r8, r31
     ac6:	9f 0a       	sbc	r9, r31
     ac8:	0e 94 1b 05 	call	0xa36	; 0xa36 <eeprom_put_char>
// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
     acc:	21 e0       	ldi	r18, 0x01	; 1
     ace:	a2 1a       	sub	r10, r18
     ad0:	b1 08       	sbc	r11, r1
     ad2:	31 f7       	brne	.-52     	; 0xaa0 <memcpy_to_eeprom_with_checksum+0x2c>
     ad4:	ec 0c       	add	r14, r12
     ad6:	fd 1c       	adc	r15, r13
     ad8:	01 c0       	rjmp	.+2      	; 0xadc <memcpy_to_eeprom_with_checksum+0x68>

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
     ada:	c0 e0       	ldi	r28, 0x00	; 0
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
  }
  eeprom_put_char(destination, checksum);
     adc:	6c 2f       	mov	r22, r28
     ade:	c7 01       	movw	r24, r14
     ae0:	0e 94 1b 05 	call	0xa36	; 0xa36 <eeprom_put_char>
}
     ae4:	df 91       	pop	r29
     ae6:	cf 91       	pop	r28
     ae8:	1f 91       	pop	r17
     aea:	0f 91       	pop	r16
     aec:	ff 90       	pop	r15
     aee:	ef 90       	pop	r14
     af0:	df 90       	pop	r13
     af2:	cf 90       	pop	r12
     af4:	bf 90       	pop	r11
     af6:	af 90       	pop	r10
     af8:	9f 90       	pop	r9
     afa:	8f 90       	pop	r8
     afc:	08 95       	ret

00000afe <memcpy_from_eeprom_with_checksum>:

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
     afe:	8f 92       	push	r8
     b00:	9f 92       	push	r9
     b02:	af 92       	push	r10
     b04:	bf 92       	push	r11
     b06:	cf 92       	push	r12
     b08:	df 92       	push	r13
     b0a:	ef 92       	push	r14
     b0c:	ff 92       	push	r15
     b0e:	0f 93       	push	r16
     b10:	1f 93       	push	r17
     b12:	cf 93       	push	r28
     b14:	df 93       	push	r29
     b16:	7b 01       	movw	r14, r22
     b18:	6a 01       	movw	r12, r20
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
     b1a:	41 15       	cp	r20, r1
     b1c:	51 05       	cpc	r21, r1
     b1e:	11 f1       	breq	.+68     	; 0xb64 <memcpy_from_eeprom_with_checksum+0x66>
     b20:	c8 2f       	mov	r28, r24
     b22:	d9 2f       	mov	r29, r25
     b24:	5a 01       	movw	r10, r20
     b26:	cb 01       	movw	r24, r22
     b28:	91 2c       	mov	r9, r1
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
     b2a:	88 24       	eor	r8, r8
     b2c:	83 94       	inc	r8
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    data = eeprom_get_char(source++);
     b2e:	8c 01       	movw	r16, r24
     b30:	0f 5f       	subi	r16, 0xFF	; 255
     b32:	1f 4f       	sbci	r17, 0xFF	; 255
     b34:	0e 94 13 05 	call	0xa26	; 0xa26 <eeprom_get_char>
    checksum = (checksum << 1) || (checksum >> 7);
     b38:	91 10       	cpse	r9, r1
     b3a:	08 c0       	rjmp	.+16     	; 0xb4c <memcpy_from_eeprom_with_checksum+0x4e>
     b3c:	29 2d       	mov	r18, r9
     b3e:	99 0c       	add	r9, r9
     b40:	33 0b       	sbc	r19, r19
     b42:	23 2f       	mov	r18, r19
     b44:	22 1f       	adc	r18, r18
     b46:	22 27       	eor	r18, r18
     b48:	22 1f       	adc	r18, r18
     b4a:	01 c0       	rjmp	.+2      	; 0xb4e <memcpy_from_eeprom_with_checksum+0x50>
     b4c:	28 2d       	mov	r18, r8
    checksum += data;    
     b4e:	98 2e       	mov	r9, r24
     b50:	92 0e       	add	r9, r18
    *(destination++) = data; 
     b52:	89 93       	st	Y+, r24
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
     b54:	81 e0       	ldi	r24, 0x01	; 1
     b56:	a8 1a       	sub	r10, r24
     b58:	b1 08       	sbc	r11, r1
    data = eeprom_get_char(source++);
     b5a:	c8 01       	movw	r24, r16
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
     b5c:	41 f7       	brne	.-48     	; 0xb2e <memcpy_from_eeprom_with_checksum+0x30>
     b5e:	ec 0c       	add	r14, r12
     b60:	fd 1c       	adc	r15, r13
     b62:	01 c0       	rjmp	.+2      	; 0xb66 <memcpy_from_eeprom_with_checksum+0x68>
  }
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
     b64:	91 2c       	mov	r9, r1
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    *(destination++) = data; 
  }
  return(checksum == eeprom_get_char(source));
     b66:	c7 01       	movw	r24, r14
     b68:	0e 94 13 05 	call	0xa26	; 0xa26 <eeprom_get_char>
     b6c:	21 e0       	ldi	r18, 0x01	; 1
     b6e:	30 e0       	ldi	r19, 0x00	; 0
     b70:	89 15       	cp	r24, r9
     b72:	11 f0       	breq	.+4      	; 0xb78 <memcpy_from_eeprom_with_checksum+0x7a>
     b74:	20 e0       	ldi	r18, 0x00	; 0
     b76:	30 e0       	ldi	r19, 0x00	; 0
}
     b78:	c9 01       	movw	r24, r18
     b7a:	df 91       	pop	r29
     b7c:	cf 91       	pop	r28
     b7e:	1f 91       	pop	r17
     b80:	0f 91       	pop	r16
     b82:	ff 90       	pop	r15
     b84:	ef 90       	pop	r14
     b86:	df 90       	pop	r13
     b88:	cf 90       	pop	r12
     b8a:	bf 90       	pop	r11
     b8c:	af 90       	pop	r10
     b8e:	9f 90       	pop	r9
     b90:	8f 90       	pop	r8
     b92:	08 95       	ret

00000b94 <gc_check_same_position>:
  system_convert_array_steps_to_mpos(gc_state.position,sys.position);
}


static uint8_t gc_check_same_position(float *pos_a, float *pos_b) 
{
     b94:	ef 92       	push	r14
     b96:	ff 92       	push	r15
     b98:	0f 93       	push	r16
     b9a:	1f 93       	push	r17
     b9c:	cf 93       	push	r28
     b9e:	df 93       	push	r29
     ba0:	7c 01       	movw	r14, r24
     ba2:	06 2f       	mov	r16, r22
     ba4:	17 2f       	mov	r17, r23
     ba6:	ec 01       	movw	r28, r24
     ba8:	2c 96       	adiw	r28, 0x0c	; 12
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    if (pos_a[idx] != pos_b[idx]) { return(false); }
     baa:	f7 01       	movw	r30, r14
     bac:	61 91       	ld	r22, Z+
     bae:	71 91       	ld	r23, Z+
     bb0:	81 91       	ld	r24, Z+
     bb2:	91 91       	ld	r25, Z+
     bb4:	7f 01       	movw	r14, r30
     bb6:	f8 01       	movw	r30, r16
     bb8:	21 91       	ld	r18, Z+
     bba:	31 91       	ld	r19, Z+
     bbc:	41 91       	ld	r20, Z+
     bbe:	51 91       	ld	r21, Z+
     bc0:	8f 01       	movw	r16, r30
     bc2:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
     bc6:	81 11       	cpse	r24, r1
     bc8:	05 c0       	rjmp	.+10     	; 0xbd4 <gc_check_same_position+0x40>


static uint8_t gc_check_same_position(float *pos_a, float *pos_b) 
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
     bca:	ec 16       	cp	r14, r28
     bcc:	fd 06       	cpc	r15, r29
     bce:	69 f7       	brne	.-38     	; 0xbaa <gc_check_same_position+0x16>
    if (pos_a[idx] != pos_b[idx]) { return(false); }
  }
  return(true);
     bd0:	81 e0       	ldi	r24, 0x01	; 1
     bd2:	01 c0       	rjmp	.+2      	; 0xbd6 <gc_check_same_position+0x42>

static uint8_t gc_check_same_position(float *pos_a, float *pos_b) 
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    if (pos_a[idx] != pos_b[idx]) { return(false); }
     bd4:	80 e0       	ldi	r24, 0x00	; 0
  }
  return(true);
}
     bd6:	df 91       	pop	r29
     bd8:	cf 91       	pop	r28
     bda:	1f 91       	pop	r17
     bdc:	0f 91       	pop	r16
     bde:	ff 90       	pop	r15
     be0:	ef 90       	pop	r14
     be2:	08 95       	ret

00000be4 <gc_init>:
#define FAIL(status) return(status);


void gc_init() 
{
  memset(&gc_state, 0, sizeof(parser_state_t));
     be4:	8f e3       	ldi	r24, 0x3F	; 63
     be6:	e8 e2       	ldi	r30, 0x28	; 40
     be8:	f5 e0       	ldi	r31, 0x05	; 5
     bea:	df 01       	movw	r26, r30
     bec:	1d 92       	st	X+, r1
     bee:	8a 95       	dec	r24
     bf0:	e9 f7       	brne	.-6      	; 0xbec <gc_init+0x8>
  
  // Load default G54 coordinate system.
  if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { 
     bf2:	6b e4       	ldi	r22, 0x4B	; 75
     bf4:	75 e0       	ldi	r23, 0x05	; 5
     bf6:	80 e0       	ldi	r24, 0x00	; 0
     bf8:	0e 94 0a 2a 	call	0x5414	; 0x5414 <settings_read_coord_data>
     bfc:	81 11       	cpse	r24, r1
     bfe:	03 c0       	rjmp	.+6      	; 0xc06 <gc_init+0x22>
    report_status_message(STATUS_SETTING_READ_FAIL); 
     c00:	87 e0       	ldi	r24, 0x07	; 7
     c02:	0e 94 3f 22 	call	0x447e	; 0x447e <report_status_message>
     c06:	08 95       	ret

00000c08 <gc_sync_position>:

// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
// limit pull-off routines.
void gc_sync_position() 
{
  system_convert_array_steps_to_mpos(gc_state.position,sys.position);
     c08:	64 ea       	ldi	r22, 0xA4	; 164
     c0a:	75 e0       	ldi	r23, 0x05	; 5
     c0c:	8f e3       	ldi	r24, 0x3F	; 63
     c0e:	95 e0       	ldi	r25, 0x05	; 5
     c10:	0e 94 8e 38 	call	0x711c	; 0x711c <system_convert_array_steps_to_mpos>
     c14:	08 95       	ret

00000c16 <gc_execute_line>:
// characters and signed floating point values (no whitespace). Comments and block delete
// characters have been removed. In this function, all units and positions are converted and 
// exported to grbl's internal functions in terms of (mm, mm/min) and absolute machine 
// coordinates, respectively.
uint8_t gc_execute_line(char *line) 
{
     c16:	2f 92       	push	r2
     c18:	3f 92       	push	r3
     c1a:	4f 92       	push	r4
     c1c:	5f 92       	push	r5
     c1e:	6f 92       	push	r6
     c20:	7f 92       	push	r7
     c22:	8f 92       	push	r8
     c24:	9f 92       	push	r9
     c26:	af 92       	push	r10
     c28:	bf 92       	push	r11
     c2a:	cf 92       	push	r12
     c2c:	df 92       	push	r13
     c2e:	ef 92       	push	r14
     c30:	ff 92       	push	r15
     c32:	0f 93       	push	r16
     c34:	1f 93       	push	r17
     c36:	cf 93       	push	r28
     c38:	df 93       	push	r29
     c3a:	cd b7       	in	r28, 0x3d	; 61
     c3c:	de b7       	in	r29, 0x3e	; 62
     c3e:	ab 97       	sbiw	r28, 0x2b	; 43
     c40:	0f b6       	in	r0, 0x3f	; 63
     c42:	f8 94       	cli
     c44:	de bf       	out	0x3e, r29	; 62
     c46:	0f be       	out	0x3f, r0	; 63
     c48:	cd bf       	out	0x3d, r28	; 61
     c4a:	7c 01       	movw	r14, r24
     updates these modes and commands as the block line is parser and will only be used and
     executed after successful error-checking. The parser block struct also contains a block
     values struct, word tracking variables, and a non-modal commands tracker for the new 
     block. This struct contains all of the necessary information to execute the block. */

  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
     c4c:	89 e3       	ldi	r24, 0x39	; 57
     c4e:	e7 e6       	ldi	r30, 0x67	; 103
     c50:	f5 e0       	ldi	r31, 0x05	; 5
     c52:	df 01       	movw	r26, r30
     c54:	1d 92       	st	X+, r1
     c56:	8a 95       	dec	r24
     c58:	e9 f7       	brne	.-6      	; 0xc54 <gc_execute_line+0x3e>
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
     c5a:	8a e0       	ldi	r24, 0x0A	; 10
     c5c:	e8 e2       	ldi	r30, 0x28	; 40
     c5e:	f5 e0       	ldi	r31, 0x05	; 5
     c60:	a8 e6       	ldi	r26, 0x68	; 104
     c62:	b5 e0       	ldi	r27, 0x05	; 5
     c64:	01 90       	ld	r0, Z+
     c66:	0d 92       	st	X+, r0
     c68:	8a 95       	dec	r24
     c6a:	e1 f7       	brne	.-8      	; 0xc64 <gc_execute_line+0x4e>
     a number, which can either be a 'G'/'M' command or sets/assigns a command value. Also, 
     perform initial error-checks for command word modal group violations, for any repeated
     words, and for negative values set for the value words F, N, P, T, and S. */
     
  uint8_t word_bit; // Bit-value for assigning tracking variables
  uint8_t char_counter = 0;  
     c6c:	19 8e       	std	Y+25, r1	; 0x19
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 

  // Initialize command and value words variables. Tracks words contained in this block.
  uint16_t command_words = 0; // G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Value words. 
     c6e:	61 2c       	mov	r6, r1
     c70:	71 2c       	mov	r7, r1
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 

  // Initialize command and value words variables. Tracks words contained in this block.
  uint16_t command_words = 0; // G and M command words. Also used for modal group violations.
     c72:	c1 2c       	mov	r12, r1
     c74:	d1 2c       	mov	r13, r1
  float coordinate_data[N_AXIS]; // Multi-use variable to store coordinate data for execution
  float parameter_data[N_AXIS]; // Multi-use variable to store parameter data for execution
  
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 
     c76:	1b a2       	std	Y+35, r1	; 0x23
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
  float coordinate_data[N_AXIS]; // Multi-use variable to store coordinate data for execution
  float parameter_data[N_AXIS]; // Multi-use variable to store parameter data for execution
  
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
     c78:	1e 8e       	std	Y+30, r1	; 0x1e
     values struct, word tracking variables, and a non-modal commands tracker for the new 
     block. This struct contains all of the necessary information to execute the block. */

  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
  uint8_t axis_command = AXIS_COMMAND_NONE;
     c7a:	1a a2       	std	Y+34, r1	; 0x22
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
     c7c:	aa 24       	eor	r10, r10
     c7e:	a3 94       	inc	r10
     c80:	b1 2c       	mov	r11, r1
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
     c82:	0f 2e       	mov	r0, r31
     c84:	f1 e6       	ldi	r31, 0x61	; 97
     c86:	8f 2e       	mov	r8, r31
     c88:	f3 e0       	ldi	r31, 0x03	; 3
     c8a:	9f 2e       	mov	r9, r31
     c8c:	f0 2d       	mov	r31, r0
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
     c8e:	a5 c2       	rjmp	.+1354   	; 0x11da <gc_execute_line+0x5c4>
    
    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
     c90:	9f eb       	ldi	r25, 0xBF	; 191
     c92:	91 0f       	add	r25, r17
     c94:	9a 31       	cpi	r25, 0x1A	; 26
     c96:	10 f0       	brcs	.+4      	; 0xc9c <gc_execute_line+0x86>
     c98:	0c 94 14 10 	jmp	0x2028	; 0x2028 <gc_execute_line+0x1412>
    char_counter++;
     c9c:	8f 5f       	subi	r24, 0xFF	; 255
     c9e:	89 8f       	std	Y+25, r24	; 0x19
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
     ca0:	ae 01       	movw	r20, r28
     ca2:	46 5e       	subi	r20, 0xE6	; 230
     ca4:	5f 4f       	sbci	r21, 0xFF	; 255
     ca6:	be 01       	movw	r22, r28
     ca8:	67 5e       	subi	r22, 0xE7	; 231
     caa:	7f 4f       	sbci	r23, 0xFF	; 255
     cac:	c7 01       	movw	r24, r14
     cae:	0e 94 65 18 	call	0x30ca	; 0x30ca <read_float>
     cb2:	88 23       	and	r24, r24
     cb4:	11 f4       	brne	.+4      	; 0xcba <gc_execute_line+0xa4>
     cb6:	0c 94 16 10 	jmp	0x202c	; 0x202c <gc_execute_line+0x1416>
    // accurate than the NIST gcode requirement of x10 when used for commands, but not quite
    // accurate enough for value words that require integers to within 0.0001. This should be
    // a good enough comprimise and catch most all non-integer errors. To make it compliant, 
    // we would simply need to change the mantissa to int16, but this add compiled flash space.
    // Maybe update this later. 
    int_value = trunc(value);
     cba:	2a 8c       	ldd	r2, Y+26	; 0x1a
     cbc:	3b 8c       	ldd	r3, Y+27	; 0x1b
     cbe:	4c 8c       	ldd	r4, Y+28	; 0x1c
     cc0:	5d 8c       	ldd	r5, Y+29	; 0x1d
     cc2:	c2 01       	movw	r24, r4
     cc4:	b1 01       	movw	r22, r2
     cc6:	0e 94 e4 3c 	call	0x79c8	; 0x79c8 <trunc>
     cca:	0e 94 22 3a 	call	0x7444	; 0x7444 <__fixunssfsi>
     cce:	06 2f       	mov	r16, r22
    mantissa =  round(100*(value - int_value)); // Compute mantissa for Gxx.x commands.
     cd0:	70 e0       	ldi	r23, 0x00	; 0
     cd2:	80 e0       	ldi	r24, 0x00	; 0
     cd4:	90 e0       	ldi	r25, 0x00	; 0
     cd6:	0e 94 53 3a 	call	0x74a6	; 0x74a6 <__floatsisf>
     cda:	9b 01       	movw	r18, r22
     cdc:	ac 01       	movw	r20, r24
     cde:	c2 01       	movw	r24, r4
     ce0:	b1 01       	movw	r22, r2
     ce2:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
     ce6:	20 e0       	ldi	r18, 0x00	; 0
     ce8:	30 e0       	ldi	r19, 0x00	; 0
     cea:	48 ec       	ldi	r20, 0xC8	; 200
     cec:	52 e4       	ldi	r21, 0x42	; 66
     cee:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
     cf2:	0e 94 6e 3c 	call	0x78dc	; 0x78dc <round>
     cf6:	0e 94 22 3a 	call	0x7444	; 0x7444 <__fixunssfsi>
        // NOTE: Rounding must be used to catch small floating point errors. 

    // Check if the g-code word is supported or errors due to modal group violations or has
    // been repeated in the g-code block. If ok, update the command or record its value.
    switch(letter) {
     cfa:	17 34       	cpi	r17, 0x47	; 71
     cfc:	21 f0       	breq	.+8      	; 0xd06 <gc_execute_line+0xf0>
     cfe:	1d 34       	cpi	r17, 0x4D	; 77
     d00:	09 f4       	brne	.+2      	; 0xd04 <gc_execute_line+0xee>
     d02:	5c c1       	rjmp	.+696    	; 0xfbc <gc_execute_line+0x3a6>
     d04:	b2 c1       	rjmp	.+868    	; 0x106a <gc_execute_line+0x454>
      /* 'G' and 'M' Command Words: Parse commands and check for modal group violations.
         NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */
         
      case 'G':
        // Determine 'G' command and its modal group
        switch(int_value) {
     d06:	80 2f       	mov	r24, r16
     d08:	90 e0       	ldi	r25, 0x00	; 0
     d0a:	8f 35       	cpi	r24, 0x5F	; 95
     d0c:	91 05       	cpc	r25, r1
     d0e:	10 f0       	brcs	.+4      	; 0xd14 <gc_execute_line+0xfe>
     d10:	0c 94 18 10 	jmp	0x2030	; 0x2030 <gc_execute_line+0x141a>
     d14:	fc 01       	movw	r30, r24
     d16:	ec 5c       	subi	r30, 0xCC	; 204
     d18:	ff 4f       	sbci	r31, 0xFF	; 255
     d1a:	0c 94 38 3d 	jmp	0x7a70	; 0x7a70 <__tablejump2__>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
     d1e:	61 15       	cp	r22, r1
     d20:	71 05       	cpc	r23, r1
     d22:	11 f0       	breq	.+4      	; 0xd28 <gc_execute_line+0x112>
     d24:	0c 94 99 10 	jmp	0x2132	; 0x2132 <gc_execute_line+0x151c>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
     d28:	ba a1       	ldd	r27, Y+34	; 0x22
     d2a:	bb 23       	and	r27, r27
     d2c:	11 f4       	brne	.+4      	; 0xd32 <gc_execute_line+0x11c>
     d2e:	0c 94 7c 10 	jmp	0x20f8	; 0x20f8 <gc_execute_line+0x14e2>
     d32:	0c 94 1a 10 	jmp	0x2034	; 0x2034 <gc_execute_line+0x141e>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
     d36:	0c 31       	cpi	r16, 0x1C	; 28
     d38:	09 f1       	breq	.+66     	; 0xd7c <gc_execute_line+0x166>
     d3a:	28 f4       	brcc	.+10     	; 0xd46 <gc_execute_line+0x130>
     d3c:	04 30       	cpi	r16, 0x04	; 4
     d3e:	71 f0       	breq	.+28     	; 0xd5c <gc_execute_line+0x146>
     d40:	0a 30       	cpi	r16, 0x0A	; 10
     d42:	a1 f0       	breq	.+40     	; 0xd6c <gc_execute_line+0x156>
     d44:	1e c1       	rjmp	.+572    	; 0xf82 <gc_execute_line+0x36c>
     d46:	05 33       	cpi	r16, 0x35	; 53
     d48:	09 f4       	brne	.+2      	; 0xd4c <gc_execute_line+0x136>
     d4a:	44 c0       	rjmp	.+136    	; 0xdd4 <gc_execute_line+0x1be>
     d4c:	0c 35       	cpi	r16, 0x5C	; 92
     d4e:	09 f4       	brne	.+2      	; 0xd52 <gc_execute_line+0x13c>
     d50:	49 c0       	rjmp	.+146    	; 0xde4 <gc_execute_line+0x1ce>
     d52:	0e 31       	cpi	r16, 0x1E	; 30
     d54:	49 f1       	breq	.+82     	; 0xda8 <gc_execute_line+0x192>
     d56:	15 c1       	rjmp	.+554    	; 0xf82 <gc_execute_line+0x36c>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     d58:	e1 e0       	ldi	r30, 0x01	; 1
     d5a:	ea a3       	std	Y+34, r30	; 0x22
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
     d5c:	e1 e0       	ldi	r30, 0x01	; 1
     d5e:	a7 e6       	ldi	r26, 0x67	; 103
     d60:	b5 e0       	ldi	r27, 0x05	; 5
     d62:	ec 93       	st	X, r30
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     d64:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
     d66:	12 c1       	rjmp	.+548    	; 0xf8c <gc_execute_line+0x376>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     d68:	f1 e0       	ldi	r31, 0x01	; 1
     d6a:	fa a3       	std	Y+34, r31	; 0x22
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
     d6c:	82 e0       	ldi	r24, 0x02	; 2
     d6e:	a7 e6       	ldi	r26, 0x67	; 103
     d70:	b5 e0       	ldi	r27, 0x05	; 5
     d72:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     d74:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
     d76:	0a c1       	rjmp	.+532    	; 0xf8c <gc_execute_line+0x376>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     d78:	b1 e0       	ldi	r27, 0x01	; 1
     d7a:	ba a3       	std	Y+34, r27	; 0x22
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
     d7c:	61 15       	cp	r22, r1
     d7e:	71 05       	cpc	r23, r1
     d80:	29 f0       	breq	.+10     	; 0xd8c <gc_execute_line+0x176>
     d82:	6a 30       	cpi	r22, 0x0A	; 10
     d84:	71 05       	cpc	r23, r1
     d86:	41 f0       	breq	.+16     	; 0xd98 <gc_execute_line+0x182>
     d88:	0c 94 1c 10 	jmp	0x2038	; 0x2038 <gc_execute_line+0x1422>
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
     d8c:	23 e0       	ldi	r18, 0x03	; 3
     d8e:	e7 e6       	ldi	r30, 0x67	; 103
     d90:	f5 e0       	ldi	r31, 0x05	; 5
     d92:	20 83       	st	Z, r18
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     d94:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
     d96:	01 c1       	rjmp	.+514    	; 0xf9a <gc_execute_line+0x384>
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
     d98:	84 e0       	ldi	r24, 0x04	; 4
     d9a:	a7 e6       	ldi	r26, 0x67	; 103
     d9c:	b5 e0       	ldi	r27, 0x05	; 5
     d9e:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     da0:	80 e0       	ldi	r24, 0x00	; 0
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
     da2:	fb c0       	rjmp	.+502    	; 0xf9a <gc_execute_line+0x384>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     da4:	b1 e0       	ldi	r27, 0x01	; 1
     da6:	ba a3       	std	Y+34, r27	; 0x22
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G28.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
     da8:	61 15       	cp	r22, r1
     daa:	71 05       	cpc	r23, r1
     dac:	29 f0       	breq	.+10     	; 0xdb8 <gc_execute_line+0x1a2>
     dae:	6a 30       	cpi	r22, 0x0A	; 10
     db0:	71 05       	cpc	r23, r1
     db2:	41 f0       	breq	.+16     	; 0xdc4 <gc_execute_line+0x1ae>
     db4:	0c 94 1e 10 	jmp	0x203c	; 0x203c <gc_execute_line+0x1426>
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
     db8:	25 e0       	ldi	r18, 0x05	; 5
     dba:	e7 e6       	ldi	r30, 0x67	; 103
     dbc:	f5 e0       	ldi	r31, 0x05	; 5
     dbe:	20 83       	st	Z, r18
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     dc0:	80 e0       	ldi	r24, 0x00	; 0
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
     dc2:	eb c0       	rjmp	.+470    	; 0xf9a <gc_execute_line+0x384>
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
     dc4:	e6 e0       	ldi	r30, 0x06	; 6
     dc6:	a7 e6       	ldi	r26, 0x67	; 103
     dc8:	b5 e0       	ldi	r27, 0x05	; 5
     dca:	ec 93       	st	X, r30
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     dcc:	80 e0       	ldi	r24, 0x00	; 0
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
     dce:	e5 c0       	rjmp	.+458    	; 0xf9a <gc_execute_line+0x384>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     dd0:	f1 e0       	ldi	r31, 0x01	; 1
     dd2:	fa a3       	std	Y+34, r31	; 0x22
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
     dd4:	e7 e0       	ldi	r30, 0x07	; 7
     dd6:	a7 e6       	ldi	r26, 0x67	; 103
     dd8:	b5 e0       	ldi	r27, 0x05	; 5
     dda:	ec 93       	st	X, r30
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     ddc:	80 e0       	ldi	r24, 0x00	; 0
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
     dde:	d6 c0       	rjmp	.+428    	; 0xf8c <gc_execute_line+0x376>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     de0:	f1 e0       	ldi	r31, 0x01	; 1
     de2:	fa a3       	std	Y+34, r31	; 0x22
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
     de4:	61 15       	cp	r22, r1
     de6:	71 05       	cpc	r23, r1
     de8:	29 f0       	breq	.+10     	; 0xdf4 <gc_execute_line+0x1de>
     dea:	6a 30       	cpi	r22, 0x0A	; 10
     dec:	71 05       	cpc	r23, r1
     dee:	41 f0       	breq	.+16     	; 0xe00 <gc_execute_line+0x1ea>
     df0:	0c 94 20 10 	jmp	0x2040	; 0x2040 <gc_execute_line+0x142a>
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
     df4:	e8 e0       	ldi	r30, 0x08	; 8
     df6:	a7 e6       	ldi	r26, 0x67	; 103
     df8:	b5 e0       	ldi	r27, 0x05	; 5
     dfa:	ec 93       	st	X, r30
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     dfc:	80 e0       	ldi	r24, 0x00	; 0
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
     dfe:	cd c0       	rjmp	.+410    	; 0xf9a <gc_execute_line+0x384>
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
     e00:	e9 e0       	ldi	r30, 0x09	; 9
     e02:	a7 e6       	ldi	r26, 0x67	; 103
     e04:	b5 e0       	ldi	r27, 0x05	; 5
     e06:	ec 93       	st	X, r30
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     e08:	80 e0       	ldi	r24, 0x00	; 0
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
     e0a:	c7 c0       	rjmp	.+398    	; 0xf9a <gc_execute_line+0x384>
            }
            break;
          case 0: case 1: case 2: case 3: case 38: 
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
     e0c:	fa a1       	ldd	r31, Y+34	; 0x22
     e0e:	f1 11       	cpse	r31, r1
     e10:	0c 94 22 10 	jmp	0x2044	; 0x2044 <gc_execute_line+0x142e>
            axis_command = AXIS_COMMAND_MOTION_MODE; 
     e14:	22 e0       	ldi	r18, 0x02	; 2
     e16:	2a a3       	std	Y+34, r18	; 0x22
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
            switch(int_value) {
     e18:	02 30       	cpi	r16, 0x02	; 2
     e1a:	b9 f0       	breq	.+46     	; 0xe4a <gc_execute_line+0x234>
     e1c:	28 f4       	brcc	.+10     	; 0xe28 <gc_execute_line+0x212>
     e1e:	00 23       	and	r16, r16
     e20:	59 f0       	breq	.+22     	; 0xe38 <gc_execute_line+0x222>
     e22:	01 30       	cpi	r16, 0x01	; 1
     e24:	69 f0       	breq	.+26     	; 0xe40 <gc_execute_line+0x22a>
     e26:	af c0       	rjmp	.+350    	; 0xf86 <gc_execute_line+0x370>
     e28:	06 32       	cpi	r16, 0x26	; 38
     e2a:	c9 f0       	breq	.+50     	; 0xe5e <gc_execute_line+0x248>
     e2c:	00 35       	cpi	r16, 0x50	; 80
     e2e:	e1 f1       	breq	.+120    	; 0xea8 <gc_execute_line+0x292>
     e30:	03 30       	cpi	r16, 0x03	; 3
     e32:	09 f0       	breq	.+2      	; 0xe36 <gc_execute_line+0x220>
     e34:	a8 c0       	rjmp	.+336    	; 0xf86 <gc_execute_line+0x370>
     e36:	0e c0       	rjmp	.+28     	; 0xe54 <gc_execute_line+0x23e>
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
     e38:	10 92 68 05 	sts	0x0568, r1	; 0x800568 <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     e3c:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
     e3e:	a6 c0       	rjmp	.+332    	; 0xf8c <gc_execute_line+0x376>
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
     e40:	31 e0       	ldi	r19, 0x01	; 1
     e42:	30 93 68 05 	sts	0x0568, r19	; 0x800568 <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     e46:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
     e48:	a1 c0       	rjmp	.+322    	; 0xf8c <gc_execute_line+0x376>
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
     e4a:	82 e0       	ldi	r24, 0x02	; 2
     e4c:	80 93 68 05 	sts	0x0568, r24	; 0x800568 <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     e50:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
     e52:	9c c0       	rjmp	.+312    	; 0xf8c <gc_execute_line+0x376>
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
     e54:	83 e0       	ldi	r24, 0x03	; 3
     e56:	80 93 68 05 	sts	0x0568, r24	; 0x800568 <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     e5a:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
     e5c:	97 c0       	rjmp	.+302    	; 0xf8c <gc_execute_line+0x376>
              case 38: 
                switch(mantissa) {
     e5e:	6e 31       	cpi	r22, 0x1E	; 30
     e60:	71 05       	cpc	r23, r1
     e62:	99 f0       	breq	.+38     	; 0xe8a <gc_execute_line+0x274>
     e64:	28 f4       	brcc	.+10     	; 0xe70 <gc_execute_line+0x25a>
     e66:	64 31       	cpi	r22, 0x14	; 20
     e68:	71 05       	cpc	r23, r1
     e6a:	51 f0       	breq	.+20     	; 0xe80 <gc_execute_line+0x26a>
     e6c:	0c 94 24 10 	jmp	0x2048	; 0x2048 <gc_execute_line+0x1432>
     e70:	68 32       	cpi	r22, 0x28	; 40
     e72:	71 05       	cpc	r23, r1
     e74:	79 f0       	breq	.+30     	; 0xe94 <gc_execute_line+0x27e>
     e76:	62 33       	cpi	r22, 0x32	; 50
     e78:	71 05       	cpc	r23, r1
     e7a:	89 f0       	breq	.+34     	; 0xe9e <gc_execute_line+0x288>
     e7c:	0c 94 24 10 	jmp	0x2048	; 0x2048 <gc_execute_line+0x1432>
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
     e80:	84 e0       	ldi	r24, 0x04	; 4
     e82:	80 93 68 05 	sts	0x0568, r24	; 0x800568 <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     e86:	81 e0       	ldi	r24, 0x01	; 1
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
     e88:	88 c0       	rjmp	.+272    	; 0xf9a <gc_execute_line+0x384>
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
     e8a:	95 e0       	ldi	r25, 0x05	; 5
     e8c:	90 93 68 05 	sts	0x0568, r25	; 0x800568 <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     e90:	81 e0       	ldi	r24, 0x01	; 1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
     e92:	83 c0       	rjmp	.+262    	; 0xf9a <gc_execute_line+0x384>
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
     e94:	a6 e0       	ldi	r26, 0x06	; 6
     e96:	a0 93 68 05 	sts	0x0568, r26	; 0x800568 <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     e9a:	81 e0       	ldi	r24, 0x01	; 1
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
     e9c:	7e c0       	rjmp	.+252    	; 0xf9a <gc_execute_line+0x384>
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
     e9e:	b7 e0       	ldi	r27, 0x07	; 7
     ea0:	b0 93 68 05 	sts	0x0568, r27	; 0x800568 <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     ea4:	81 e0       	ldi	r24, 0x01	; 1
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
     ea6:	79 c0       	rjmp	.+242    	; 0xf9a <gc_execute_line+0x384>
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
     ea8:	e8 e0       	ldi	r30, 0x08	; 8
     eaa:	e0 93 68 05 	sts	0x0568, r30	; 0x800568 <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     eae:	81 e0       	ldi	r24, 0x01	; 1
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
     eb0:	6d c0       	rjmp	.+218    	; 0xf8c <gc_execute_line+0x376>
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
            switch(int_value) {
     eb2:	02 31       	cpi	r16, 0x12	; 18
     eb4:	49 f0       	breq	.+18     	; 0xec8 <gc_execute_line+0x2b2>
     eb6:	03 31       	cpi	r16, 0x13	; 19
     eb8:	61 f0       	breq	.+24     	; 0xed2 <gc_execute_line+0x2bc>
     eba:	01 31       	cpi	r16, 0x11	; 17
     ebc:	09 f0       	breq	.+2      	; 0xec0 <gc_execute_line+0x2aa>
     ebe:	65 c0       	rjmp	.+202    	; 0xf8a <gc_execute_line+0x374>
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
     ec0:	10 92 6c 05 	sts	0x056C, r1	; 0x80056c <gc_block+0x5>
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
     ec4:	82 e0       	ldi	r24, 0x02	; 2
            switch(int_value) {
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
     ec6:	62 c0       	rjmp	.+196    	; 0xf8c <gc_execute_line+0x376>
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
     ec8:	f1 e0       	ldi	r31, 0x01	; 1
     eca:	f0 93 6c 05 	sts	0x056C, r31	; 0x80056c <gc_block+0x5>
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
     ece:	82 e0       	ldi	r24, 0x02	; 2
            switch(int_value) {
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
     ed0:	5d c0       	rjmp	.+186    	; 0xf8c <gc_execute_line+0x376>
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
     ed2:	82 e0       	ldi	r24, 0x02	; 2
     ed4:	80 93 6c 05 	sts	0x056C, r24	; 0x80056c <gc_block+0x5>
     ed8:	59 c0       	rjmp	.+178    	; 0xf8c <gc_execute_line+0x376>
            }
            break;
          case 90: case 91: 
            if (mantissa == 0) {
     eda:	61 15       	cp	r22, r1
     edc:	71 05       	cpc	r23, r1
     ede:	59 f4       	brne	.+22     	; 0xef6 <gc_execute_line+0x2e0>
              word_bit = MODAL_GROUP_G3; 
              if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
     ee0:	0a 35       	cpi	r16, 0x5A	; 90
     ee2:	21 f4       	brne	.+8      	; 0xeec <gc_execute_line+0x2d6>
     ee4:	10 92 6b 05 	sts	0x056B, r1	; 0x80056b <gc_block+0x4>
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
            }
            break;
          case 90: case 91: 
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3; 
     ee8:	83 e0       	ldi	r24, 0x03	; 3
     eea:	57 c0       	rjmp	.+174    	; 0xf9a <gc_execute_line+0x384>
              if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
              else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91
     eec:	21 e0       	ldi	r18, 0x01	; 1
     eee:	20 93 6b 05 	sts	0x056B, r18	; 0x80056b <gc_block+0x4>
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
            }
            break;
          case 90: case 91: 
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3; 
     ef2:	83 e0       	ldi	r24, 0x03	; 3
     ef4:	52 c0       	rjmp	.+164    	; 0xf9a <gc_execute_line+0x384>
              if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
              else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
     ef6:	6a 30       	cpi	r22, 0x0A	; 10
     ef8:	71 05       	cpc	r23, r1
     efa:	11 f0       	breq	.+4      	; 0xf00 <gc_execute_line+0x2ea>
     efc:	0c 94 26 10 	jmp	0x204c	; 0x204c <gc_execute_line+0x1436>
     f00:	0a 35       	cpi	r16, 0x5A	; 90
     f02:	11 f4       	brne	.+4      	; 0xf08 <gc_execute_line+0x2f2>
     f04:	0c 94 28 10 	jmp	0x2050	; 0x2050 <gc_execute_line+0x143a>
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3; 
              if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
              else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91
            } else {
              word_bit = MODAL_GROUP_G4;
     f08:	84 e0       	ldi	r24, 0x04	; 4
     f0a:	47 c0       	rjmp	.+142    	; 0xf9a <gc_execute_line+0x384>
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
     f0c:	0d 35       	cpi	r16, 0x5D	; 93
     f0e:	29 f4       	brne	.+10     	; 0xf1a <gc_execute_line+0x304>
     f10:	31 e0       	ldi	r19, 0x01	; 1
     f12:	30 93 69 05 	sts	0x0569, r19	; 0x800569 <gc_block+0x2>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
     f16:	85 e0       	ldi	r24, 0x05	; 5
     f18:	39 c0       	rjmp	.+114    	; 0xf8c <gc_execute_line+0x376>
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
     f1a:	10 92 69 05 	sts	0x0569, r1	; 0x800569 <gc_block+0x2>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
     f1e:	85 e0       	ldi	r24, 0x05	; 5
     f20:	35 c0       	rjmp	.+106    	; 0xf8c <gc_execute_line+0x376>
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
     f22:	04 31       	cpi	r16, 0x14	; 20
     f24:	29 f4       	brne	.+10     	; 0xf30 <gc_execute_line+0x31a>
     f26:	81 e0       	ldi	r24, 0x01	; 1
     f28:	80 93 6a 05 	sts	0x056A, r24	; 0x80056a <gc_block+0x3>
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
     f2c:	86 e0       	ldi	r24, 0x06	; 6
     f2e:	2e c0       	rjmp	.+92     	; 0xf8c <gc_execute_line+0x376>
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
            else { gc_block.modal.units = UNITS_MODE_MM; } // G21
     f30:	10 92 6a 05 	sts	0x056A, r1	; 0x80056a <gc_block+0x3>
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
     f34:	86 e0       	ldi	r24, 0x06	; 6
     f36:	2a c0       	rjmp	.+84     	; 0xf8c <gc_execute_line+0x376>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
     f38:	9a a1       	ldd	r25, Y+34	; 0x22
     f3a:	91 11       	cpse	r25, r1
     f3c:	0c 94 2a 10 	jmp	0x2054	; 0x2054 <gc_execute_line+0x143e>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
     f40:	01 33       	cpi	r16, 0x31	; 49
     f42:	31 f4       	brne	.+12     	; 0xf50 <gc_execute_line+0x33a>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
     f44:	10 92 6d 05 	sts	0x056D, r1	; 0x80056d <gc_block+0x6>
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
     f48:	88 e0       	ldi	r24, 0x08	; 8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
     f4a:	a3 e0       	ldi	r26, 0x03	; 3
     f4c:	aa a3       	std	Y+34, r26	; 0x22
     f4e:	25 c0       	rjmp	.+74     	; 0xf9a <gc_execute_line+0x384>
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
            } else if (mantissa == 10) { // G43.1
     f50:	6a 30       	cpi	r22, 0x0A	; 10
     f52:	71 05       	cpc	r23, r1
     f54:	11 f0       	breq	.+4      	; 0xf5a <gc_execute_line+0x344>
     f56:	0c 94 2c 10 	jmp	0x2058	; 0x2058 <gc_execute_line+0x1442>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
     f5a:	b1 e0       	ldi	r27, 0x01	; 1
     f5c:	b0 93 6d 05 	sts	0x056D, r27	; 0x80056d <gc_block+0x6>
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
     f60:	88 e0       	ldi	r24, 0x08	; 8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
     f62:	e3 e0       	ldi	r30, 0x03	; 3
     f64:	ea a3       	std	Y+34, r30	; 0x22
     f66:	19 c0       	rjmp	.+50     	; 0xf9a <gc_execute_line+0x384>
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59: 
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
     f68:	06 53       	subi	r16, 0x36	; 54
     f6a:	00 93 6e 05 	sts	0x056E, r16	; 0x80056e <gc_block+0x7>
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59: 
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
     f6e:	89 e0       	ldi	r24, 0x09	; 9
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
     f70:	0d c0       	rjmp	.+26     	; 0xf8c <gc_execute_line+0x376>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
     f72:	67 2b       	or	r22, r23
     f74:	11 f0       	breq	.+4      	; 0xf7a <gc_execute_line+0x364>
     f76:	0c 94 2e 10 	jmp	0x205c	; 0x205c <gc_execute_line+0x1446>
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
     f7a:	8a e0       	ldi	r24, 0x0A	; 10
     f7c:	0e c0       	rjmp	.+28     	; 0xf9a <gc_execute_line+0x384>
            word_bit = MODAL_GROUP_G6; 
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
            else { gc_block.modal.units = UNITS_MODE_MM; } // G21
            break;
          case 40:
            word_bit = MODAL_GROUP_G7;
     f7e:	87 e0       	ldi	r24, 0x07	; 7
     f80:	05 c0       	rjmp	.+10     	; 0xf8c <gc_execute_line+0x376>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     f82:	80 e0       	ldi	r24, 0x00	; 0
     f84:	03 c0       	rjmp	.+6      	; 0xf8c <gc_execute_line+0x376>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     f86:	81 e0       	ldi	r24, 0x01	; 1
     f88:	01 c0       	rjmp	.+2      	; 0xf8c <gc_execute_line+0x376>
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
     f8a:	82 e0       	ldi	r24, 0x02	; 2
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
     f8c:	67 2b       	or	r22, r23
     f8e:	29 f0       	breq	.+10     	; 0xf9a <gc_execute_line+0x384>
     f90:	0c 94 30 10 	jmp	0x2060	; 0x2060 <gc_execute_line+0x144a>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     f94:	80 e0       	ldi	r24, 0x00	; 0
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     f96:	f1 e0       	ldi	r31, 0x01	; 1
     f98:	fa a3       	std	Y+34, r31	; 0x22
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
     f9a:	95 01       	movw	r18, r10
     f9c:	02 c0       	rjmp	.+4      	; 0xfa2 <gc_execute_line+0x38c>
     f9e:	22 0f       	add	r18, r18
     fa0:	33 1f       	adc	r19, r19
     fa2:	8a 95       	dec	r24
     fa4:	e2 f7       	brpl	.-8      	; 0xf9e <gc_execute_line+0x388>
     fa6:	c9 01       	movw	r24, r18
     fa8:	96 01       	movw	r18, r12
     faa:	28 23       	and	r18, r24
     fac:	39 23       	and	r19, r25
     fae:	23 2b       	or	r18, r19
     fb0:	11 f0       	breq	.+4      	; 0xfb6 <gc_execute_line+0x3a0>
     fb2:	0c 94 32 10 	jmp	0x2064	; 0x2064 <gc_execute_line+0x144e>
        command_words |= bit(word_bit);
     fb6:	c8 2a       	or	r12, r24
     fb8:	d9 2a       	or	r13, r25
        break;
     fba:	0f c1       	rjmp	.+542    	; 0x11da <gc_execute_line+0x5c4>
        
      case 'M':
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
     fbc:	67 2b       	or	r22, r23
     fbe:	11 f0       	breq	.+4      	; 0xfc4 <gc_execute_line+0x3ae>
     fc0:	0c 94 34 10 	jmp	0x2068	; 0x2068 <gc_execute_line+0x1452>
        switch(int_value) {
     fc4:	80 2f       	mov	r24, r16
     fc6:	90 e0       	ldi	r25, 0x00	; 0
     fc8:	8f 31       	cpi	r24, 0x1F	; 31
     fca:	91 05       	cpc	r25, r1
     fcc:	10 f0       	brcs	.+4      	; 0xfd2 <gc_execute_line+0x3bc>
     fce:	0c 94 36 10 	jmp	0x206c	; 0x206c <gc_execute_line+0x1456>
     fd2:	fc 01       	movw	r30, r24
     fd4:	ed 56       	subi	r30, 0x6D	; 109
     fd6:	ff 4f       	sbci	r31, 0xFF	; 255
     fd8:	0c 94 38 3d 	jmp	0x7a70	; 0x7a70 <__tablejump2__>
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
            switch(int_value) {
     fdc:	02 30       	cpi	r16, 0x02	; 2
     fde:	49 f0       	breq	.+18     	; 0xff2 <gc_execute_line+0x3dc>
     fe0:	0e 31       	cpi	r16, 0x1E	; 30
     fe2:	39 f0       	breq	.+14     	; 0xff2 <gc_execute_line+0x3dc>
     fe4:	01 11       	cpse	r16, r1
     fe6:	2c c0       	rjmp	.+88     	; 0x1040 <gc_execute_line+0x42a>
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
     fe8:	31 e0       	ldi	r19, 0x01	; 1
     fea:	30 93 6f 05 	sts	0x056F, r19	; 0x80056f <gc_block+0x8>
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
     fee:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
     ff0:	2c c0       	rjmp	.+88     	; 0x104a <gc_execute_line+0x434>
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
     ff2:	82 e0       	ldi	r24, 0x02	; 2
     ff4:	80 93 6f 05 	sts	0x056F, r24	; 0x80056f <gc_block+0x8>
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
     ff8:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
     ffa:	27 c0       	rjmp	.+78     	; 0x104a <gc_execute_line+0x434>
          #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
            case 4: 
          #endif
          case 3: case 5:
            word_bit = MODAL_GROUP_M7; 
            switch(int_value) {
     ffc:	04 30       	cpi	r16, 0x04	; 4
     ffe:	49 f0       	breq	.+18     	; 0x1012 <gc_execute_line+0x3fc>
    1000:	05 30       	cpi	r16, 0x05	; 5
    1002:	61 f0       	breq	.+24     	; 0x101c <gc_execute_line+0x406>
    1004:	03 30       	cpi	r16, 0x03	; 3
    1006:	f1 f4       	brne	.+60     	; 0x1044 <gc_execute_line+0x42e>
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    1008:	81 e0       	ldi	r24, 0x01	; 1
    100a:	80 93 71 05 	sts	0x0571, r24	; 0x800571 <gc_block+0xa>
            break;
          #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
            case 4: 
          #endif
          case 3: case 5:
            word_bit = MODAL_GROUP_M7; 
    100e:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    1010:	1c c0       	rjmp	.+56     	; 0x104a <gc_execute_line+0x434>
              #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
                case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    1012:	82 e0       	ldi	r24, 0x02	; 2
    1014:	80 93 71 05 	sts	0x0571, r24	; 0x800571 <gc_block+0xa>
            break;
          #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
            case 4: 
          #endif
          case 3: case 5:
            word_bit = MODAL_GROUP_M7; 
    1018:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
                case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    101a:	17 c0       	rjmp	.+46     	; 0x104a <gc_execute_line+0x434>
              #endif
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    101c:	10 92 71 05 	sts	0x0571, r1	; 0x800571 <gc_block+0xa>
            break;
          #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
            case 4: 
          #endif
          case 3: case 5:
            word_bit = MODAL_GROUP_M7; 
    1020:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
                case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              #endif
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    1022:	13 c0       	rjmp	.+38     	; 0x104a <gc_execute_line+0x434>
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
            switch(int_value) {      
    1024:	08 30       	cpi	r16, 0x08	; 8
    1026:	19 f0       	breq	.+6      	; 0x102e <gc_execute_line+0x418>
    1028:	09 30       	cpi	r16, 0x09	; 9
    102a:	31 f0       	breq	.+12     	; 0x1038 <gc_execute_line+0x422>
    102c:	0d c0       	rjmp	.+26     	; 0x1048 <gc_execute_line+0x432>
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
    102e:	82 e0       	ldi	r24, 0x02	; 2
    1030:	80 93 70 05 	sts	0x0570, r24	; 0x800570 <gc_block+0x9>
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1034:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {      
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
    1036:	09 c0       	rjmp	.+18     	; 0x104a <gc_execute_line+0x434>
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
    1038:	10 92 70 05 	sts	0x0570, r1	; 0x800570 <gc_block+0x9>
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    103c:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {      
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
    103e:	05 c0       	rjmp	.+10     	; 0x104a <gc_execute_line+0x434>
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
    1040:	8b e0       	ldi	r24, 0x0B	; 11
    1042:	03 c0       	rjmp	.+6      	; 0x104a <gc_execute_line+0x434>
            break;
          #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
            case 4: 
          #endif
          case 3: case 5:
            word_bit = MODAL_GROUP_M7; 
    1044:	8c e0       	ldi	r24, 0x0C	; 12
    1046:	01 c0       	rjmp	.+2      	; 0x104a <gc_execute_line+0x434>
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1048:	8d e0       	ldi	r24, 0x0D	; 13
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
        }
      
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    104a:	d5 01       	movw	r26, r10
    104c:	02 c0       	rjmp	.+4      	; 0x1052 <gc_execute_line+0x43c>
    104e:	aa 0f       	add	r26, r26
    1050:	bb 1f       	adc	r27, r27
    1052:	8a 95       	dec	r24
    1054:	e2 f7       	brpl	.-8      	; 0x104e <gc_execute_line+0x438>
    1056:	96 01       	movw	r18, r12
    1058:	2a 23       	and	r18, r26
    105a:	3b 23       	and	r19, r27
    105c:	23 2b       	or	r18, r19
    105e:	11 f0       	breq	.+4      	; 0x1064 <gc_execute_line+0x44e>
    1060:	0c 94 38 10 	jmp	0x2070	; 0x2070 <gc_execute_line+0x145a>
        command_words |= bit(word_bit);
    1064:	ca 2a       	or	r12, r26
    1066:	db 2a       	or	r13, r27
        break;
    1068:	b8 c0       	rjmp	.+368    	; 0x11da <gc_execute_line+0x5c4>
      default: 
  
        /* Non-Command Words: This initial parsing phase only checks for repeats of the remaining
           legal g-code words and stores their value. Error-checking is performed later since some
           words (I,J,K,L,P,R) have multiple connotations and/or depend on the issued commands. */
        switch(letter){
    106a:	81 2f       	mov	r24, r17
    106c:	90 e0       	ldi	r25, 0x00	; 0
    106e:	fc 01       	movw	r30, r24
    1070:	e6 54       	subi	r30, 0x46	; 70
    1072:	f1 09       	sbc	r31, r1
    1074:	e5 31       	cpi	r30, 0x15	; 21
    1076:	f1 05       	cpc	r31, r1
    1078:	10 f0       	brcs	.+4      	; 0x107e <gc_execute_line+0x468>
    107a:	0c 94 3a 10 	jmp	0x2074	; 0x2074 <gc_execute_line+0x145e>
    107e:	ee 54       	subi	r30, 0x4E	; 78
    1080:	ff 4f       	sbci	r31, 0xFF	; 255
    1082:	0c 94 38 3d 	jmp	0x7a70	; 0x7a70 <__tablejump2__>
          // case 'A': // Not supported
          // case 'B': // Not supported
          // case 'C': // Not supported
          // case 'D': // Not supported
          case 'F': word_bit = WORD_F; gc_block.values.f = value; break;
    1086:	20 92 72 05 	sts	0x0572, r2	; 0x800572 <gc_block+0xb>
    108a:	30 92 73 05 	sts	0x0573, r3	; 0x800573 <gc_block+0xc>
    108e:	40 92 74 05 	sts	0x0574, r4	; 0x800574 <gc_block+0xd>
    1092:	50 92 75 05 	sts	0x0575, r5	; 0x800575 <gc_block+0xe>
    1096:	80 e0       	ldi	r24, 0x00	; 0
    1098:	7f c0       	rjmp	.+254    	; 0x1198 <gc_execute_line+0x582>
          // case 'H': // Not supported
          case 'I': word_bit = WORD_I; gc_block.values.ijk[X_AXIS] = value; ijk_words |= (1<<X_AXIS); break;
    109a:	20 92 76 05 	sts	0x0576, r2	; 0x800576 <gc_block+0xf>
    109e:	30 92 77 05 	sts	0x0577, r3	; 0x800577 <gc_block+0x10>
    10a2:	40 92 78 05 	sts	0x0578, r4	; 0x800578 <gc_block+0x11>
    10a6:	50 92 79 05 	sts	0x0579, r5	; 0x800579 <gc_block+0x12>
    10aa:	bb a1       	ldd	r27, Y+35	; 0x23
    10ac:	b1 60       	ori	r27, 0x01	; 1
    10ae:	bb a3       	std	Y+35, r27	; 0x23
    10b0:	81 e0       	ldi	r24, 0x01	; 1
    10b2:	72 c0       	rjmp	.+228    	; 0x1198 <gc_execute_line+0x582>
          case 'J': word_bit = WORD_J; gc_block.values.ijk[Y_AXIS] = value; ijk_words |= (1<<Y_AXIS); break;
    10b4:	20 92 7a 05 	sts	0x057A, r2	; 0x80057a <gc_block+0x13>
    10b8:	30 92 7b 05 	sts	0x057B, r3	; 0x80057b <gc_block+0x14>
    10bc:	40 92 7c 05 	sts	0x057C, r4	; 0x80057c <gc_block+0x15>
    10c0:	50 92 7d 05 	sts	0x057D, r5	; 0x80057d <gc_block+0x16>
    10c4:	eb a1       	ldd	r30, Y+35	; 0x23
    10c6:	e2 60       	ori	r30, 0x02	; 2
    10c8:	eb a3       	std	Y+35, r30	; 0x23
    10ca:	82 e0       	ldi	r24, 0x02	; 2
    10cc:	65 c0       	rjmp	.+202    	; 0x1198 <gc_execute_line+0x582>
          case 'K': word_bit = WORD_K; gc_block.values.ijk[Z_AXIS] = value; ijk_words |= (1<<Z_AXIS); break;
    10ce:	20 92 7e 05 	sts	0x057E, r2	; 0x80057e <gc_block+0x17>
    10d2:	30 92 7f 05 	sts	0x057F, r3	; 0x80057f <gc_block+0x18>
    10d6:	40 92 80 05 	sts	0x0580, r4	; 0x800580 <gc_block+0x19>
    10da:	50 92 81 05 	sts	0x0581, r5	; 0x800581 <gc_block+0x1a>
    10de:	fb a1       	ldd	r31, Y+35	; 0x23
    10e0:	f4 60       	ori	r31, 0x04	; 4
    10e2:	fb a3       	std	Y+35, r31	; 0x23
    10e4:	83 e0       	ldi	r24, 0x03	; 3
    10e6:	58 c0       	rjmp	.+176    	; 0x1198 <gc_execute_line+0x582>
          case 'L': word_bit = WORD_L; gc_block.values.l = int_value; break;
    10e8:	00 93 82 05 	sts	0x0582, r16	; 0x800582 <gc_block+0x1b>
    10ec:	84 e0       	ldi	r24, 0x04	; 4
    10ee:	54 c0       	rjmp	.+168    	; 0x1198 <gc_execute_line+0x582>
          case 'N': word_bit = WORD_N; gc_block.values.n = trunc(value); break;
    10f0:	c2 01       	movw	r24, r4
    10f2:	b1 01       	movw	r22, r2
    10f4:	0e 94 1b 3a 	call	0x7436	; 0x7436 <__fixsfsi>
    10f8:	60 93 83 05 	sts	0x0583, r22	; 0x800583 <gc_block+0x1c>
    10fc:	70 93 84 05 	sts	0x0584, r23	; 0x800584 <gc_block+0x1d>
    1100:	80 93 85 05 	sts	0x0585, r24	; 0x800585 <gc_block+0x1e>
    1104:	90 93 86 05 	sts	0x0586, r25	; 0x800586 <gc_block+0x1f>
    1108:	85 e0       	ldi	r24, 0x05	; 5
    110a:	46 c0       	rjmp	.+140    	; 0x1198 <gc_execute_line+0x582>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
    110c:	20 92 87 05 	sts	0x0587, r2	; 0x800587 <gc_block+0x20>
    1110:	30 92 88 05 	sts	0x0588, r3	; 0x800588 <gc_block+0x21>
    1114:	40 92 89 05 	sts	0x0589, r4	; 0x800589 <gc_block+0x22>
    1118:	50 92 8a 05 	sts	0x058A, r5	; 0x80058a <gc_block+0x23>
    111c:	86 e0       	ldi	r24, 0x06	; 6
    111e:	3c c0       	rjmp	.+120    	; 0x1198 <gc_execute_line+0x582>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
    1120:	20 92 8b 05 	sts	0x058B, r2	; 0x80058b <gc_block+0x24>
    1124:	30 92 8c 05 	sts	0x058C, r3	; 0x80058c <gc_block+0x25>
    1128:	40 92 8d 05 	sts	0x058D, r4	; 0x80058d <gc_block+0x26>
    112c:	50 92 8e 05 	sts	0x058E, r5	; 0x80058e <gc_block+0x27>
    1130:	87 e0       	ldi	r24, 0x07	; 7
    1132:	32 c0       	rjmp	.+100    	; 0x1198 <gc_execute_line+0x582>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
    1134:	20 92 8f 05 	sts	0x058F, r2	; 0x80058f <gc_block+0x28>
    1138:	30 92 90 05 	sts	0x0590, r3	; 0x800590 <gc_block+0x29>
    113c:	40 92 91 05 	sts	0x0591, r4	; 0x800591 <gc_block+0x2a>
    1140:	50 92 92 05 	sts	0x0592, r5	; 0x800592 <gc_block+0x2b>
    1144:	88 e0       	ldi	r24, 0x08	; 8
    1146:	28 c0       	rjmp	.+80     	; 0x1198 <gc_execute_line+0x582>
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
    1148:	20 92 94 05 	sts	0x0594, r2	; 0x800594 <gc_block+0x2d>
    114c:	30 92 95 05 	sts	0x0595, r3	; 0x800595 <gc_block+0x2e>
    1150:	40 92 96 05 	sts	0x0596, r4	; 0x800596 <gc_block+0x2f>
    1154:	50 92 97 05 	sts	0x0597, r5	; 0x800597 <gc_block+0x30>
    1158:	2e 8d       	ldd	r18, Y+30	; 0x1e
    115a:	21 60       	ori	r18, 0x01	; 1
    115c:	2e 8f       	std	Y+30, r18	; 0x1e
    115e:	8a e0       	ldi	r24, 0x0A	; 10
    1160:	1b c0       	rjmp	.+54     	; 0x1198 <gc_execute_line+0x582>
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
    1162:	20 92 98 05 	sts	0x0598, r2	; 0x800598 <gc_block+0x31>
    1166:	30 92 99 05 	sts	0x0599, r3	; 0x800599 <gc_block+0x32>
    116a:	40 92 9a 05 	sts	0x059A, r4	; 0x80059a <gc_block+0x33>
    116e:	50 92 9b 05 	sts	0x059B, r5	; 0x80059b <gc_block+0x34>
    1172:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1174:	32 60       	ori	r19, 0x02	; 2
    1176:	3e 8f       	std	Y+30, r19	; 0x1e
    1178:	8b e0       	ldi	r24, 0x0B	; 11
    117a:	0e c0       	rjmp	.+28     	; 0x1198 <gc_execute_line+0x582>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
    117c:	20 92 9c 05 	sts	0x059C, r2	; 0x80059c <gc_block+0x35>
    1180:	30 92 9d 05 	sts	0x059D, r3	; 0x80059d <gc_block+0x36>
    1184:	40 92 9e 05 	sts	0x059E, r4	; 0x80059e <gc_block+0x37>
    1188:	50 92 9f 05 	sts	0x059F, r5	; 0x80059f <gc_block+0x38>
    118c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    118e:	84 60       	ori	r24, 0x04	; 4
    1190:	8e 8f       	std	Y+30, r24	; 0x1e
    1192:	8c e0       	ldi	r24, 0x0C	; 12
    1194:	01 c0       	rjmp	.+2      	; 0x1198 <gc_execute_line+0x582>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
    1196:	89 e0       	ldi	r24, 0x09	; 9
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        } 
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    1198:	85 01       	movw	r16, r10
    119a:	08 2e       	mov	r0, r24
    119c:	02 c0       	rjmp	.+4      	; 0x11a2 <gc_execute_line+0x58c>
    119e:	00 0f       	add	r16, r16
    11a0:	11 1f       	adc	r17, r17
    11a2:	0a 94       	dec	r0
    11a4:	e2 f7       	brpl	.-8      	; 0x119e <gc_execute_line+0x588>
    11a6:	93 01       	movw	r18, r6
    11a8:	20 23       	and	r18, r16
    11aa:	31 23       	and	r19, r17
    11ac:	23 2b       	or	r18, r19
    11ae:	09 f0       	breq	.+2      	; 0x11b2 <gc_execute_line+0x59c>
    11b0:	63 c7       	rjmp	.+3782   	; 0x2078 <gc_execute_line+0x1462>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
    11b2:	d4 01       	movw	r26, r8
    11b4:	02 c0       	rjmp	.+4      	; 0x11ba <gc_execute_line+0x5a4>
    11b6:	b5 95       	asr	r27
    11b8:	a7 95       	ror	r26
    11ba:	8a 95       	dec	r24
    11bc:	e2 f7       	brpl	.-8      	; 0x11b6 <gc_execute_line+0x5a0>
    11be:	a0 ff       	sbrs	r26, 0
    11c0:	0a c0       	rjmp	.+20     	; 0x11d6 <gc_execute_line+0x5c0>
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    11c2:	20 e0       	ldi	r18, 0x00	; 0
    11c4:	30 e0       	ldi	r19, 0x00	; 0
    11c6:	a9 01       	movw	r20, r18
    11c8:	c2 01       	movw	r24, r4
    11ca:	b1 01       	movw	r22, r2
    11cc:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    11d0:	88 23       	and	r24, r24
    11d2:	0c f4       	brge	.+2      	; 0x11d6 <gc_execute_line+0x5c0>
    11d4:	53 c7       	rjmp	.+3750   	; 0x207c <gc_execute_line+0x1466>
        }
        value_words |= bit(word_bit); // Flag to indicate parameter assigned.
    11d6:	60 2a       	or	r6, r16
    11d8:	71 2a       	or	r7, r17
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    11da:	89 8d       	ldd	r24, Y+25	; 0x19
    11dc:	f7 01       	movw	r30, r14
    11de:	e8 0f       	add	r30, r24
    11e0:	f1 1d       	adc	r31, r1
    11e2:	10 81       	ld	r17, Z
    11e4:	11 11       	cpse	r17, r1
    11e6:	54 cd       	rjmp	.-1368   	; 0xc90 <gc_execute_line+0x7a>
  
  // [0. Non-specific/common error-checks and miscellaneous setup]: 
  
  // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
  // command has been sent. If so, set axis command to current motion mode.
  if (axis_words) {
    11e8:	be 8d       	ldd	r27, Y+30	; 0x1e
    11ea:	bb 23       	and	r27, r27
    11ec:	29 f0       	breq	.+10     	; 0x11f8 <gc_execute_line+0x5e2>
    if (!axis_command) { axis_command = AXIS_COMMAND_MOTION_MODE; } // Assign implicit motion-mode
    11ee:	ea a1       	ldd	r30, Y+34	; 0x22
    11f0:	e1 11       	cpse	r30, r1
    11f2:	02 c0       	rjmp	.+4      	; 0x11f8 <gc_execute_line+0x5e2>
    11f4:	f2 e0       	ldi	r31, 0x02	; 2
    11f6:	fa a3       	std	Y+34, r31	; 0x22
  }
  
  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    11f8:	65 fe       	sbrs	r6, 5
    11fa:	0e c0       	rjmp	.+28     	; 0x1218 <gc_execute_line+0x602>
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    11fc:	80 91 83 05 	lds	r24, 0x0583	; 0x800583 <gc_block+0x1c>
    1200:	90 91 84 05 	lds	r25, 0x0584	; 0x800584 <gc_block+0x1d>
    1204:	a0 91 85 05 	lds	r26, 0x0585	; 0x800585 <gc_block+0x1e>
    1208:	b0 91 86 05 	lds	r27, 0x0586	; 0x800586 <gc_block+0x1f>
    120c:	80 38       	cpi	r24, 0x80	; 128
    120e:	96 49       	sbci	r25, 0x96	; 150
    1210:	a8 49       	sbci	r26, 0x98	; 152
    1212:	b1 05       	cpc	r27, r1
    1214:	0c f0       	brlt	.+2      	; 0x1218 <gc_execute_line+0x602>
    1216:	34 c7       	rjmp	.+3688   	; 0x2080 <gc_execute_line+0x146a>
  
  // [1. Comments ]: MSG's NOT SUPPORTED. Comment handling performed by protocol.
  
  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    1218:	80 91 69 05 	lds	r24, 0x0569	; 0x800569 <gc_block+0x2>
    121c:	81 30       	cpi	r24, 0x01	; 1
    121e:	31 f4       	brne	.+12     	; 0x122c <gc_execute_line+0x616>
    // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
    if (axis_command == AXIS_COMMAND_MOTION_MODE) { 
    1220:	3a a1       	ldd	r19, Y+34	; 0x22
    1222:	32 30       	cpi	r19, 0x02	; 2
    1224:	91 f5       	brne	.+100    	; 0x128a <gc_execute_line+0x674>
      if ((gc_block.modal.motion != MOTION_MODE_NONE) || (gc_block.modal.motion != MOTION_MODE_SEEK)) {
        if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    1226:	60 fe       	sbrs	r6, 0
    1228:	2d c7       	rjmp	.+3674   	; 0x2084 <gc_execute_line+0x146e>
    122a:	2f c0       	rjmp	.+94     	; 0x128a <gc_execute_line+0x674>
    // value in the block. If no F word is passed with a motion command that requires a feed rate, this will error 
    // out in the motion modes error-checking. However, if no F word is passed with NO motion command that requires
    // a feed rate, we simply move on and the state feed rate value gets updated to zero and remains undefined.
  } else { // = G94
    // - In units per mm mode: If F word passed, ensure value is in mm/min, otherwise push last state value.
    if (gc_state.modal.feed_rate == FEED_RATE_MODE_UNITS_PER_MIN) { // Last state is also G94
    122c:	80 91 29 05 	lds	r24, 0x0529	; 0x800529 <gc_state+0x1>
    1230:	81 11       	cpse	r24, r1
    1232:	2b c0       	rjmp	.+86     	; 0x128a <gc_execute_line+0x674>
      if (bit_istrue(value_words,bit(WORD_F))) {
    1234:	60 fe       	sbrs	r6, 0
    1236:	19 c0       	rjmp	.+50     	; 0x126a <gc_execute_line+0x654>
        if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    1238:	80 91 6a 05 	lds	r24, 0x056A	; 0x80056a <gc_block+0x3>
    123c:	81 30       	cpi	r24, 0x01	; 1
    123e:	29 f5       	brne	.+74     	; 0x128a <gc_execute_line+0x674>
    1240:	07 e6       	ldi	r16, 0x67	; 103
    1242:	15 e0       	ldi	r17, 0x05	; 5
    1244:	23 e3       	ldi	r18, 0x33	; 51
    1246:	33 e3       	ldi	r19, 0x33	; 51
    1248:	4b ec       	ldi	r20, 0xCB	; 203
    124a:	51 e4       	ldi	r21, 0x41	; 65
    124c:	d8 01       	movw	r26, r16
    124e:	1b 96       	adiw	r26, 0x0b	; 11
    1250:	6d 91       	ld	r22, X+
    1252:	7d 91       	ld	r23, X+
    1254:	8d 91       	ld	r24, X+
    1256:	9c 91       	ld	r25, X
    1258:	1e 97       	sbiw	r26, 0x0e	; 14
    125a:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    125e:	f8 01       	movw	r30, r16
    1260:	63 87       	std	Z+11, r22	; 0x0b
    1262:	74 87       	std	Z+12, r23	; 0x0c
    1264:	85 87       	std	Z+13, r24	; 0x0d
    1266:	96 87       	std	Z+14, r25	; 0x0e
    1268:	10 c0       	rjmp	.+32     	; 0x128a <gc_execute_line+0x674>
      } else {
        gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
    126a:	80 91 36 05 	lds	r24, 0x0536	; 0x800536 <gc_state+0xe>
    126e:	90 91 37 05 	lds	r25, 0x0537	; 0x800537 <gc_state+0xf>
    1272:	a0 91 38 05 	lds	r26, 0x0538	; 0x800538 <gc_state+0x10>
    1276:	b0 91 39 05 	lds	r27, 0x0539	; 0x800539 <gc_state+0x11>
    127a:	80 93 72 05 	sts	0x0572, r24	; 0x800572 <gc_block+0xb>
    127e:	90 93 73 05 	sts	0x0573, r25	; 0x800573 <gc_block+0xc>
    1282:	a0 93 74 05 	sts	0x0574, r26	; 0x800574 <gc_block+0xd>
    1286:	b0 93 75 05 	sts	0x0575, r27	; 0x800575 <gc_block+0xe>
    } // Else, switching to G94 from G93, so don't push last state feed rate. Its undefined or the passed F word value.
  } 
  // bit_false(value_words,bit(WORD_F)); // NOTE: Single-meaning value word. Set at end of error-checking.
  
  // [4. Set spindle speed ]: S is negative (done.)
  if (bit_isfalse(value_words,bit(WORD_S))) { gc_block.values.s = gc_state.spindle_speed; }
    128a:	70 fc       	sbrc	r7, 0
    128c:	10 c0       	rjmp	.+32     	; 0x12ae <gc_execute_line+0x698>
    128e:	80 91 32 05 	lds	r24, 0x0532	; 0x800532 <gc_state+0xa>
    1292:	90 91 33 05 	lds	r25, 0x0533	; 0x800533 <gc_state+0xb>
    1296:	a0 91 34 05 	lds	r26, 0x0534	; 0x800534 <gc_state+0xc>
    129a:	b0 91 35 05 	lds	r27, 0x0535	; 0x800535 <gc_state+0xd>
    129e:	80 93 8f 05 	sts	0x058F, r24	; 0x80058f <gc_block+0x28>
    12a2:	90 93 90 05 	sts	0x0590, r25	; 0x800590 <gc_block+0x29>
    12a6:	a0 93 91 05 	sts	0x0591, r26	; 0x800591 <gc_block+0x2a>
    12aa:	b0 93 92 05 	sts	0x0592, r27	; 0x800592 <gc_block+0x2b>
  // [7. Spindle control ]: N/A
  // [8. Coolant control ]: N/A
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED.
  
  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    12ae:	80 91 67 05 	lds	r24, 0x0567	; 0x800567 <gc_block>
    12b2:	81 30       	cpi	r24, 0x01	; 1
    12b4:	21 f4       	brne	.+8      	; 0x12be <gc_execute_line+0x6a8>
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    12b6:	66 fe       	sbrs	r6, 6
    12b8:	e7 c6       	rjmp	.+3534   	; 0x2088 <gc_execute_line+0x1472>
    bit_false(value_words,bit(WORD_P));
    12ba:	e8 94       	clt
    12bc:	66 f8       	bld	r6, 6
  }
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    12be:	80 91 6c 05 	lds	r24, 0x056C	; 0x80056c <gc_block+0x5>
    12c2:	88 23       	and	r24, r24
    12c4:	49 f0       	breq	.+18     	; 0x12d8 <gc_execute_line+0x6c2>
    12c6:	81 30       	cpi	r24, 0x01	; 1
    12c8:	09 f4       	brne	.+2      	; 0x12cc <gc_execute_line+0x6b6>
    12ca:	4d c7       	rjmp	.+3738   	; 0x2166 <gc_execute_line+0x1550>
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
      axis_linear = X_AXIS;
    12cc:	1e a2       	std	Y+38, r1	; 0x26
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
    12ce:	f2 e0       	ldi	r31, 0x02	; 2
    12d0:	fd a3       	std	Y+37, r31	; 0x25
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
    12d2:	21 e0       	ldi	r18, 0x01	; 1
    12d4:	2c a3       	std	Y+36, r18	; 0x24
    12d6:	4c c7       	rjmp	.+3736   	; 0x2170 <gc_execute_line+0x155a>
  }   
            
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    12d8:	80 91 6a 05 	lds	r24, 0x056A	; 0x80056a <gc_block+0x3>
    12dc:	81 30       	cpi	r24, 0x01	; 1
    12de:	99 f5       	brne	.+102    	; 0x1346 <gc_execute_line+0x730>
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    12e0:	32 e0       	ldi	r19, 0x02	; 2
    12e2:	3e a3       	std	Y+38, r19	; 0x26
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    12e4:	8d a3       	std	Y+37, r24	; 0x25
  }
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    12e6:	1c a2       	std	Y+36, r1	; 0x24
    12e8:	0f 2e       	mov	r0, r31
    12ea:	f7 e6       	ldi	r31, 0x67	; 103
    12ec:	af 2e       	mov	r10, r31
    12ee:	f5 e0       	ldi	r31, 0x05	; 5
    12f0:	bf 2e       	mov	r11, r31
    12f2:	f0 2d       	mov	r31, r0
    12f4:	00 e0       	ldi	r16, 0x00	; 0
    12f6:	10 e0       	ldi	r17, 0x00	; 0
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
      if (bit_istrue(axis_words,bit(idx)) ) {
    12f8:	9e 8d       	ldd	r25, Y+30	; 0x1e
    12fa:	e9 2e       	mov	r14, r25
    12fc:	f1 2c       	mov	r15, r1
    12fe:	c7 01       	movw	r24, r14
    1300:	00 2e       	mov	r0, r16
    1302:	02 c0       	rjmp	.+4      	; 0x1308 <gc_execute_line+0x6f2>
    1304:	95 95       	asr	r25
    1306:	87 95       	ror	r24
    1308:	0a 94       	dec	r0
    130a:	e2 f7       	brpl	.-8      	; 0x1304 <gc_execute_line+0x6ee>
    130c:	80 ff       	sbrs	r24, 0
    130e:	12 c0       	rjmp	.+36     	; 0x1334 <gc_execute_line+0x71e>
        gc_block.values.xyz[idx] *= MM_PER_INCH;
    1310:	23 e3       	ldi	r18, 0x33	; 51
    1312:	33 e3       	ldi	r19, 0x33	; 51
    1314:	4b ec       	ldi	r20, 0xCB	; 203
    1316:	51 e4       	ldi	r21, 0x41	; 65
    1318:	d5 01       	movw	r26, r10
    131a:	9d 96       	adiw	r26, 0x2d	; 45
    131c:	6d 91       	ld	r22, X+
    131e:	7d 91       	ld	r23, X+
    1320:	8d 91       	ld	r24, X+
    1322:	9c 91       	ld	r25, X
    1324:	d0 97       	sbiw	r26, 0x30	; 48
    1326:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    132a:	f5 01       	movw	r30, r10
    132c:	65 a7       	std	Z+45, r22	; 0x2d
    132e:	76 a7       	std	Z+46, r23	; 0x2e
    1330:	87 a7       	std	Z+47, r24	; 0x2f
    1332:	90 ab       	std	Z+48, r25	; 0x30
    1334:	0f 5f       	subi	r16, 0xFF	; 255
    1336:	1f 4f       	sbci	r17, 0xFF	; 255
    1338:	f4 e0       	ldi	r31, 0x04	; 4
    133a:	af 0e       	add	r10, r31
    133c:	b1 1c       	adc	r11, r1
            
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    133e:	03 30       	cpi	r16, 0x03	; 3
    1340:	11 05       	cpc	r17, r1
    1342:	e9 f6       	brne	.-70     	; 0x12fe <gc_execute_line+0x6e8>
    1344:	05 c0       	rjmp	.+10     	; 0x1350 <gc_execute_line+0x73a>
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    1346:	22 e0       	ldi	r18, 0x02	; 2
    1348:	2e a3       	std	Y+38, r18	; 0x26
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    134a:	31 e0       	ldi	r19, 0x01	; 1
    134c:	3d a3       	std	Y+37, r19	; 0x25
  }
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    134e:	1c a2       	std	Y+36, r1	; 0x24
  // [14. Cutter length compensation ]: G43 NOT SUPPORTED, but G43.1 and G49 are. 
  // [G43.1 Errors]: Motion command in same line. 
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid 
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    1350:	8a a1       	ldd	r24, Y+34	; 0x22
    1352:	83 30       	cpi	r24, 0x03	; 3
    1354:	41 f4       	brne	.+16     	; 0x1366 <gc_execute_line+0x750>
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
    1356:	80 91 6d 05 	lds	r24, 0x056D	; 0x80056d <gc_block+0x6>
    135a:	81 30       	cpi	r24, 0x01	; 1
    135c:	21 f4       	brne	.+8      	; 0x1366 <gc_execute_line+0x750>
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    135e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1360:	94 30       	cpi	r25, 0x04	; 4
    1362:	09 f0       	breq	.+2      	; 0x1366 <gc_execute_line+0x750>
    1364:	93 c6       	rjmp	.+3366   	; 0x208c <gc_execute_line+0x1476>
  // [15. Coordinate system selection ]: *N/A. Error, if cutter radius comp is active.
  // TODO: An EEPROM read of the coordinate data may require a buffer sync when the cycle
  // is active. The read pauses the processor temporarily and may cause a rare crash. For 
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  memcpy(coordinate_data,gc_state.coord_system,sizeof(gc_state.coord_system));
    1366:	8c e0       	ldi	r24, 0x0C	; 12
    1368:	eb e4       	ldi	r30, 0x4B	; 75
    136a:	f5 e0       	ldi	r31, 0x05	; 5
    136c:	de 01       	movw	r26, r28
    136e:	11 96       	adiw	r26, 0x01	; 1
    1370:	01 90       	ld	r0, Z+
    1372:	0d 92       	st	X+, r0
    1374:	8a 95       	dec	r24
    1376:	e1 f7       	brne	.-8      	; 0x1370 <gc_execute_line+0x75a>
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    1378:	d1 fe       	sbrs	r13, 1
    137a:	11 c0       	rjmp	.+34     	; 0x139e <gc_execute_line+0x788>
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    137c:	80 91 6e 05 	lds	r24, 0x056E	; 0x80056e <gc_block+0x7>
    1380:	87 30       	cpi	r24, 0x07	; 7
    1382:	08 f0       	brcs	.+2      	; 0x1386 <gc_execute_line+0x770>
    1384:	85 c6       	rjmp	.+3338   	; 0x2090 <gc_execute_line+0x147a>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    1386:	90 91 2e 05 	lds	r25, 0x052E	; 0x80052e <gc_state+0x6>
    138a:	89 17       	cp	r24, r25
    138c:	41 f0       	breq	.+16     	; 0x139e <gc_execute_line+0x788>
      if (!(settings_read_coord_data(gc_block.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
    138e:	be 01       	movw	r22, r28
    1390:	6f 5f       	subi	r22, 0xFF	; 255
    1392:	7f 4f       	sbci	r23, 0xFF	; 255
    1394:	0e 94 0a 2a 	call	0x5414	; 0x5414 <settings_read_coord_data>
    1398:	88 23       	and	r24, r24
    139a:	09 f4       	brne	.+2      	; 0x139e <gc_execute_line+0x788>
    139c:	7b c6       	rjmp	.+3318   	; 0x2094 <gc_execute_line+0x147e>
  // [19. Remaining non-modal actions ]: Check go to predefined position, set G10, or set axis offsets.
  // NOTE: We need to separate the non-modal commands that are axis word-using (G10/G28/G30/G92), as these
  // commands all treat axis words differently. G10 as absolute offsets or computes current position as
  // the axis value, G92 similarly to G10 L20, and G28/30 as an intermediate target position that observes
  // all the current coordinate system and G92 offsets. 
  switch (gc_block.non_modal_command) {
    139e:	50 90 67 05 	lds	r5, 0x0567	; 0x800567 <gc_block>
    13a2:	a2 e0       	ldi	r26, 0x02	; 2
    13a4:	5a 16       	cp	r5, r26
    13a6:	29 f0       	breq	.+10     	; 0x13b2 <gc_execute_line+0x79c>
    13a8:	b8 e0       	ldi	r27, 0x08	; 8
    13aa:	5b 16       	cp	r5, r27
    13ac:	09 f4       	brne	.+2      	; 0x13b0 <gc_execute_line+0x79a>
    13ae:	a8 c0       	rjmp	.+336    	; 0x1500 <gc_execute_line+0x8ea>
    13b0:	1c c1       	rjmp	.+568    	; 0x15ea <gc_execute_line+0x9d4>
    case NON_MODAL_SET_COORDINATE_DATA:  
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    13b2:	ee 8d       	ldd	r30, Y+30	; 0x1e
    13b4:	ee 23       	and	r30, r30
    13b6:	09 f4       	brne	.+2      	; 0x13ba <gc_execute_line+0x7a4>
    13b8:	6f c6       	rjmp	.+3294   	; 0x2098 <gc_execute_line+0x1482>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    13ba:	c3 01       	movw	r24, r6
    13bc:	80 75       	andi	r24, 0x50	; 80
    13be:	99 27       	eor	r25, r25
    13c0:	89 2b       	or	r24, r25
    13c2:	09 f4       	brne	.+2      	; 0x13c6 <gc_execute_line+0x7b0>
    13c4:	6b c6       	rjmp	.+3286   	; 0x209c <gc_execute_line+0x1486>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
    13c6:	60 91 87 05 	lds	r22, 0x0587	; 0x800587 <gc_block+0x20>
    13ca:	70 91 88 05 	lds	r23, 0x0588	; 0x800588 <gc_block+0x21>
    13ce:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <gc_block+0x22>
    13d2:	90 91 8a 05 	lds	r25, 0x058A	; 0x80058a <gc_block+0x23>
    13d6:	0e 94 e4 3c 	call	0x79c8	; 0x79c8 <trunc>
    13da:	0e 94 22 3a 	call	0x7444	; 0x7444 <__fixunssfsi>
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    13de:	67 30       	cpi	r22, 0x07	; 7
    13e0:	08 f0       	brcs	.+2      	; 0x13e4 <gc_execute_line+0x7ce>
    13e2:	5e c6       	rjmp	.+3260   	; 0x20a0 <gc_execute_line+0x148a>
      if (gc_block.values.l != 20) {
    13e4:	80 91 82 05 	lds	r24, 0x0582	; 0x800582 <gc_block+0x1b>
    13e8:	84 31       	cpi	r24, 0x14	; 20
    13ea:	29 f0       	breq	.+10     	; 0x13f6 <gc_execute_line+0x7e0>
        if (gc_block.values.l == 2) {
    13ec:	82 30       	cpi	r24, 0x02	; 2
    13ee:	09 f0       	breq	.+2      	; 0x13f2 <gc_execute_line+0x7dc>
    13f0:	59 c6       	rjmp	.+3250   	; 0x20a4 <gc_execute_line+0x148e>
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    13f2:	67 fc       	sbrc	r6, 7
    13f4:	59 c6       	rjmp	.+3250   	; 0x20a8 <gc_execute_line+0x1492>
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
      }
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
    13f6:	ff ea       	ldi	r31, 0xAF	; 175
    13f8:	6f 22       	and	r6, r31
      
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
    13fa:	66 23       	and	r22, r22
    13fc:	19 f0       	breq	.+6      	; 0x1404 <gc_execute_line+0x7ee>
    13fe:	61 50       	subi	r22, 0x01	; 1
    1400:	6f a3       	std	Y+39, r22	; 0x27
    1402:	03 c0       	rjmp	.+6      	; 0x140a <gc_execute_line+0x7f4>
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
    1404:	20 91 6e 05 	lds	r18, 0x056E	; 0x80056e <gc_block+0x7>
    1408:	2f a3       	std	Y+39, r18	; 0x27
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    140a:	be 01       	movw	r22, r28
    140c:	63 5f       	subi	r22, 0xF3	; 243
    140e:	7f 4f       	sbci	r23, 0xFF	; 255
    1410:	8f a1       	ldd	r24, Y+39	; 0x27
    1412:	0e 94 0a 2a 	call	0x5414	; 0x5414 <settings_read_coord_data>
    1416:	88 23       	and	r24, r24
    1418:	09 f4       	brne	.+2      	; 0x141c <gc_execute_line+0x806>
    141a:	48 c6       	rjmp	.+3216   	; 0x20ac <gc_execute_line+0x1496>
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
          if (gc_block.values.l == 20) {
    141c:	30 90 82 05 	lds	r3, 0x0582	; 0x800582 <gc_block+0x1b>
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            parameter_data[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { parameter_data[idx] -= gc_state.tool_length_offset; }
    1420:	80 91 63 05 	lds	r24, 0x0563	; 0x800563 <gc_state+0x3b>
    1424:	90 91 64 05 	lds	r25, 0x0564	; 0x800564 <gc_state+0x3c>
    1428:	a0 91 65 05 	lds	r26, 0x0565	; 0x800565 <gc_state+0x3d>
    142c:	b0 91 66 05 	lds	r27, 0x0566	; 0x800566 <gc_state+0x3e>
    1430:	88 a7       	std	Y+40, r24	; 0x28
    1432:	99 a7       	std	Y+41, r25	; 0x29
    1434:	aa a7       	std	Y+42, r26	; 0x2a
    1436:	bb a7       	std	Y+43, r27	; 0x2b
    1438:	8e 01       	movw	r16, r28
    143a:	03 5f       	subi	r16, 0xF3	; 243
    143c:	1f 4f       	sbci	r17, 0xFF	; 255
    143e:	0f 2e       	mov	r0, r31
    1440:	f7 e6       	ldi	r31, 0x67	; 103
    1442:	ef 2e       	mov	r14, r31
    1444:	f5 e0       	ldi	r31, 0x05	; 5
    1446:	ff 2e       	mov	r15, r31
    1448:	f0 2d       	mov	r31, r0
    144a:	0f 2e       	mov	r0, r31
    144c:	f8 e2       	ldi	r31, 0x28	; 40
    144e:	cf 2e       	mov	r12, r31
    1450:	f5 e0       	ldi	r31, 0x05	; 5
    1452:	df 2e       	mov	r13, r31
    1454:	f0 2d       	mov	r31, r0
    1456:	a1 2c       	mov	r10, r1
    1458:	b1 2c       	mov	r11, r1
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
    145a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    145c:	89 2e       	mov	r8, r25
    145e:	91 2c       	mov	r9, r1
    1460:	c4 01       	movw	r24, r8
    1462:	0a 2c       	mov	r0, r10
    1464:	02 c0       	rjmp	.+4      	; 0x146a <gc_execute_line+0x854>
    1466:	95 95       	asr	r25
    1468:	87 95       	ror	r24
    146a:	0a 94       	dec	r0
    146c:	e2 f7       	brpl	.-8      	; 0x1466 <gc_execute_line+0x850>
    146e:	80 ff       	sbrs	r24, 0
    1470:	36 c0       	rjmp	.+108    	; 0x14de <gc_execute_line+0x8c8>
          if (gc_block.values.l == 20) {
    1472:	a4 e1       	ldi	r26, 0x14	; 20
    1474:	3a 12       	cpse	r3, r26
    1476:	29 c0       	rjmp	.+82     	; 0x14ca <gc_execute_line+0x8b4>
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            parameter_data[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
    1478:	f6 01       	movw	r30, r12
    147a:	27 a5       	ldd	r18, Z+47	; 0x2f
    147c:	30 a9       	ldd	r19, Z+48	; 0x30
    147e:	41 a9       	ldd	r20, Z+49	; 0x31
    1480:	52 a9       	ldd	r21, Z+50	; 0x32
    1482:	67 89       	ldd	r22, Z+23	; 0x17
    1484:	70 8d       	ldd	r23, Z+24	; 0x18
    1486:	81 8d       	ldd	r24, Z+25	; 0x19
    1488:	92 8d       	ldd	r25, Z+26	; 0x1a
    148a:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    148e:	d7 01       	movw	r26, r14
    1490:	9d 96       	adiw	r26, 0x2d	; 45
    1492:	2d 91       	ld	r18, X+
    1494:	3d 91       	ld	r19, X+
    1496:	4d 91       	ld	r20, X+
    1498:	5c 91       	ld	r21, X
    149a:	d0 97       	sbiw	r26, 0x30	; 48
    149c:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    14a0:	f8 01       	movw	r30, r16
    14a2:	60 83       	st	Z, r22
    14a4:	71 83       	std	Z+1, r23	; 0x01
    14a6:	82 83       	std	Z+2, r24	; 0x02
    14a8:	93 83       	std	Z+3, r25	; 0x03
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { parameter_data[idx] -= gc_state.tool_length_offset; }
    14aa:	f2 e0       	ldi	r31, 0x02	; 2
    14ac:	af 12       	cpse	r10, r31
    14ae:	17 c0       	rjmp	.+46     	; 0x14de <gc_execute_line+0x8c8>
    14b0:	28 a5       	ldd	r18, Y+40	; 0x28
    14b2:	39 a5       	ldd	r19, Y+41	; 0x29
    14b4:	4a a5       	ldd	r20, Y+42	; 0x2a
    14b6:	5b a5       	ldd	r21, Y+43	; 0x2b
    14b8:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    14bc:	d8 01       	movw	r26, r16
    14be:	6d 93       	st	X+, r22
    14c0:	7d 93       	st	X+, r23
    14c2:	8d 93       	st	X+, r24
    14c4:	9c 93       	st	X, r25
    14c6:	13 97       	sbiw	r26, 0x03	; 3
    14c8:	0a c0       	rjmp	.+20     	; 0x14de <gc_execute_line+0x8c8>
          } else {
            // L2: Update coordinate system axis to programmed value.
            parameter_data[idx] = gc_block.values.xyz[idx]; 
    14ca:	f7 01       	movw	r30, r14
    14cc:	85 a5       	ldd	r24, Z+45	; 0x2d
    14ce:	96 a5       	ldd	r25, Z+46	; 0x2e
    14d0:	a7 a5       	ldd	r26, Z+47	; 0x2f
    14d2:	b0 a9       	ldd	r27, Z+48	; 0x30
    14d4:	f8 01       	movw	r30, r16
    14d6:	80 83       	st	Z, r24
    14d8:	91 83       	std	Z+1, r25	; 0x01
    14da:	a2 83       	std	Z+2, r26	; 0x02
    14dc:	b3 83       	std	Z+3, r27	; 0x03
    14de:	ff ef       	ldi	r31, 0xFF	; 255
    14e0:	af 1a       	sub	r10, r31
    14e2:	bf 0a       	sbc	r11, r31
    14e4:	0c 5f       	subi	r16, 0xFC	; 252
    14e6:	1f 4f       	sbci	r17, 0xFF	; 255
    14e8:	24 e0       	ldi	r18, 0x04	; 4
    14ea:	e2 0e       	add	r14, r18
    14ec:	f1 1c       	adc	r15, r1
    14ee:	34 e0       	ldi	r19, 0x04	; 4
    14f0:	c3 0e       	add	r12, r19
    14f2:	d1 1c       	adc	r13, r1
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    14f4:	83 e0       	ldi	r24, 0x03	; 3
    14f6:	a8 16       	cp	r10, r24
    14f8:	b1 04       	cpc	r11, r1
    14fa:	09 f0       	breq	.+2      	; 0x14fe <gc_execute_line+0x8e8>
    14fc:	b1 cf       	rjmp	.-158    	; 0x1460 <gc_execute_line+0x84a>
    14fe:	56 c6       	rjmp	.+3244   	; 0x21ac <gc_execute_line+0x1596>
        }
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1500:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1502:	99 23       	and	r25, r25
    1504:	09 f4       	brne	.+2      	; 0x1508 <gc_execute_line+0x8f2>
    1506:	d4 c5       	rjmp	.+2984   	; 0x20b0 <gc_execute_line+0x149a>
    1508:	0f 2e       	mov	r0, r31
    150a:	f8 e2       	ldi	r31, 0x28	; 40
    150c:	cf 2e       	mov	r12, r31
    150e:	f5 e0       	ldi	r31, 0x05	; 5
    1510:	df 2e       	mov	r13, r31
    1512:	f0 2d       	mov	r31, r0
    1514:	de 01       	movw	r26, r28
    1516:	11 96       	adiw	r26, 0x01	; 1
    1518:	5d 01       	movw	r10, r26
    151a:	0f 2e       	mov	r0, r31
    151c:	f7 e6       	ldi	r31, 0x67	; 103
    151e:	ef 2e       	mov	r14, r31
    1520:	f5 e0       	ldi	r31, 0x05	; 5
    1522:	ff 2e       	mov	r15, r31
    1524:	f0 2d       	mov	r31, r0
    1526:	00 e0       	ldi	r16, 0x00	; 0
    1528:	10 e0       	ldi	r17, 0x00	; 0
    
      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it. 
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
    152a:	89 2e       	mov	r8, r25
    152c:	91 2c       	mov	r9, r1
    152e:	c4 01       	movw	r24, r8
    1530:	00 2e       	mov	r0, r16
    1532:	02 c0       	rjmp	.+4      	; 0x1538 <gc_execute_line+0x922>
    1534:	95 95       	asr	r25
    1536:	87 95       	ror	r24
    1538:	0a 94       	dec	r0
    153a:	e2 f7       	brpl	.-8      	; 0x1534 <gc_execute_line+0x91e>
    153c:	80 ff       	sbrs	r24, 0
    153e:	3a c0       	rjmp	.+116    	; 0x15b4 <gc_execute_line+0x99e>
          gc_block.values.xyz[idx] = gc_state.position[idx]-coordinate_data[idx]-gc_block.values.xyz[idx];
    1540:	f5 01       	movw	r30, r10
    1542:	20 81       	ld	r18, Z
    1544:	31 81       	ldd	r19, Z+1	; 0x01
    1546:	42 81       	ldd	r20, Z+2	; 0x02
    1548:	53 81       	ldd	r21, Z+3	; 0x03
    154a:	d6 01       	movw	r26, r12
    154c:	57 96       	adiw	r26, 0x17	; 23
    154e:	6d 91       	ld	r22, X+
    1550:	7d 91       	ld	r23, X+
    1552:	8d 91       	ld	r24, X+
    1554:	9c 91       	ld	r25, X
    1556:	5a 97       	sbiw	r26, 0x1a	; 26
    1558:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    155c:	f7 01       	movw	r30, r14
    155e:	25 a5       	ldd	r18, Z+45	; 0x2d
    1560:	36 a5       	ldd	r19, Z+46	; 0x2e
    1562:	47 a5       	ldd	r20, Z+47	; 0x2f
    1564:	50 a9       	ldd	r21, Z+48	; 0x30
    1566:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    156a:	d7 01       	movw	r26, r14
    156c:	9d 96       	adiw	r26, 0x2d	; 45
    156e:	6d 93       	st	X+, r22
    1570:	7d 93       	st	X+, r23
    1572:	8d 93       	st	X+, r24
    1574:	9c 93       	st	X, r25
    1576:	d0 97       	sbiw	r26, 0x30	; 48
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
    1578:	02 30       	cpi	r16, 0x02	; 2
    157a:	31 f5       	brne	.+76     	; 0x15c8 <gc_execute_line+0x9b2>
    157c:	00 0f       	add	r16, r16
    157e:	11 1f       	adc	r17, r17
    1580:	00 0f       	add	r16, r16
    1582:	11 1f       	adc	r17, r17
    1584:	09 59       	subi	r16, 0x99	; 153
    1586:	1a 4f       	sbci	r17, 0xFA	; 250
    1588:	20 91 63 05 	lds	r18, 0x0563	; 0x800563 <gc_state+0x3b>
    158c:	30 91 64 05 	lds	r19, 0x0564	; 0x800564 <gc_state+0x3c>
    1590:	40 91 65 05 	lds	r20, 0x0565	; 0x800565 <gc_state+0x3d>
    1594:	50 91 66 05 	lds	r21, 0x0566	; 0x800566 <gc_state+0x3e>
    1598:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    159c:	f8 01       	movw	r30, r16
    159e:	65 a7       	std	Z+45, r22	; 0x2d
    15a0:	76 a7       	std	Z+46, r23	; 0x2e
    15a2:	87 a7       	std	Z+47, r24	; 0x2f
    15a4:	90 ab       	std	Z+48, r25	; 0x30
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    15a6:	10 91 68 05 	lds	r17, 0x0568	; 0x800568 <gc_block+0x1>
    15aa:	18 30       	cpi	r17, 0x08	; 8
    15ac:	09 f4       	brne	.+2      	; 0x15b0 <gc_execute_line+0x99a>
    15ae:	f2 c0       	rjmp	.+484    	; 0x1794 <gc_execute_line+0xb7e>
    15b0:	1f a2       	std	Y+39, r1	; 0x27
    15b2:	f7 c0       	rjmp	.+494    	; 0x17a2 <gc_execute_line+0xb8c>
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
          gc_block.values.xyz[idx] = gc_state.position[idx]-coordinate_data[idx]-gc_block.values.xyz[idx];
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
        } else {
          gc_block.values.xyz[idx] = gc_state.coord_offset[idx];
    15b4:	f6 01       	movw	r30, r12
    15b6:	87 a5       	ldd	r24, Z+47	; 0x2f
    15b8:	90 a9       	ldd	r25, Z+48	; 0x30
    15ba:	a1 a9       	ldd	r26, Z+49	; 0x31
    15bc:	b2 a9       	ldd	r27, Z+50	; 0x32
    15be:	f7 01       	movw	r30, r14
    15c0:	85 a7       	std	Z+45, r24	; 0x2d
    15c2:	96 a7       	std	Z+46, r25	; 0x2e
    15c4:	a7 a7       	std	Z+47, r26	; 0x2f
    15c6:	b0 ab       	std	Z+48, r27	; 0x30
    15c8:	0f 5f       	subi	r16, 0xFF	; 255
    15ca:	1f 4f       	sbci	r17, 0xFF	; 255
    15cc:	f4 e0       	ldi	r31, 0x04	; 4
    15ce:	cf 0e       	add	r12, r31
    15d0:	d1 1c       	adc	r13, r1
    15d2:	24 e0       	ldi	r18, 0x04	; 4
    15d4:	a2 0e       	add	r10, r18
    15d6:	b1 1c       	adc	r11, r1
    15d8:	34 e0       	ldi	r19, 0x04	; 4
    15da:	e3 0e       	add	r14, r19
    15dc:	f1 1c       	adc	r15, r1
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    
      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it. 
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    15de:	03 30       	cpi	r16, 0x03	; 3
    15e0:	11 05       	cpc	r17, r1
    15e2:	09 f0       	breq	.+2      	; 0x15e6 <gc_execute_line+0x9d0>
    15e4:	a4 cf       	rjmp	.-184    	; 0x152e <gc_execute_line+0x918>

  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    15e6:	1f a2       	std	Y+39, r1	; 0x27
    15e8:	e1 c5       	rjmp	.+3010   	; 0x21ac <gc_execute_line+0x1596>

      // At this point, the rest of the explicit axis commands treat the axis values as the traditional
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
    15ea:	8a a1       	ldd	r24, Y+34	; 0x22
    15ec:	83 30       	cpi	r24, 0x03	; 3
    15ee:	09 f4       	brne	.+2      	; 0x15f2 <gc_execute_line+0x9dc>
    15f0:	9b c0       	rjmp	.+310    	; 0x1728 <gc_execute_line+0xb12>
        if (axis_words) {
    15f2:	9e 8d       	ldd	r25, Y+30	; 0x1e
    15f4:	99 23       	and	r25, r25
    15f6:	09 f4       	brne	.+2      	; 0x15fa <gc_execute_line+0x9e4>
    15f8:	cd c5       	rjmp	.+2970   	; 0x2194 <gc_execute_line+0x157e>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    15fa:	40 90 6b 05 	lds	r4, 0x056B	; 0x80056b <gc_block+0x4>
    15fe:	0f 2e       	mov	r0, r31
    1600:	f8 e2       	ldi	r31, 0x28	; 40
    1602:	cf 2e       	mov	r12, r31
    1604:	f5 e0       	ldi	r31, 0x05	; 5
    1606:	df 2e       	mov	r13, r31
    1608:	f0 2d       	mov	r31, r0
    160a:	0f 2e       	mov	r0, r31
    160c:	f7 e6       	ldi	r31, 0x67	; 103
    160e:	ef 2e       	mov	r14, r31
    1610:	f5 e0       	ldi	r31, 0x05	; 5
    1612:	ff 2e       	mov	r15, r31
    1614:	f0 2d       	mov	r31, r0
    1616:	de 01       	movw	r26, r28
    1618:	11 96       	adiw	r26, 0x01	; 1
    161a:	5d 01       	movw	r10, r26
    161c:	00 e0       	ldi	r16, 0x00	; 0
    161e:	10 e0       	ldi	r17, 0x00	; 0
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
            if ( bit_isfalse(axis_words,bit(idx)) ) {
    1620:	29 2e       	mov	r2, r25
    1622:	31 2c       	mov	r3, r1
    1624:	c1 01       	movw	r24, r2
    1626:	00 2e       	mov	r0, r16
    1628:	02 c0       	rjmp	.+4      	; 0x162e <gc_execute_line+0xa18>
    162a:	95 95       	asr	r25
    162c:	87 95       	ror	r24
    162e:	0a 94       	dec	r0
    1630:	e2 f7       	brpl	.-8      	; 0x162a <gc_execute_line+0xa14>
    1632:	80 fd       	sbrc	r24, 0
    1634:	0b c0       	rjmp	.+22     	; 0x164c <gc_execute_line+0xa36>
              gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
    1636:	f6 01       	movw	r30, r12
    1638:	87 89       	ldd	r24, Z+23	; 0x17
    163a:	90 8d       	ldd	r25, Z+24	; 0x18
    163c:	a1 8d       	ldd	r26, Z+25	; 0x19
    163e:	b2 8d       	ldd	r27, Z+26	; 0x1a
    1640:	f7 01       	movw	r30, r14
    1642:	85 a7       	std	Z+45, r24	; 0x2d
    1644:	96 a7       	std	Z+46, r25	; 0x2e
    1646:	a7 a7       	std	Z+47, r26	; 0x2f
    1648:	b0 ab       	std	Z+48, r27	; 0x30
    164a:	5e c0       	rjmp	.+188    	; 0x1708 <gc_execute_line+0xaf2>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
    164c:	f7 e0       	ldi	r31, 0x07	; 7
    164e:	5f 16       	cp	r5, r31
    1650:	09 f4       	brne	.+2      	; 0x1654 <gc_execute_line+0xa3e>
    1652:	5a c0       	rjmp	.+180    	; 0x1708 <gc_execute_line+0xaf2>
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    1654:	41 10       	cpse	r4, r1
    1656:	43 c0       	rjmp	.+134    	; 0x16de <gc_execute_line+0xac8>
                  gc_block.values.xyz[idx] += coordinate_data[idx] + gc_state.coord_offset[idx];
    1658:	d6 01       	movw	r26, r12
    165a:	9f 96       	adiw	r26, 0x2f	; 47
    165c:	2d 91       	ld	r18, X+
    165e:	3d 91       	ld	r19, X+
    1660:	4d 91       	ld	r20, X+
    1662:	5c 91       	ld	r21, X
    1664:	d2 97       	sbiw	r26, 0x32	; 50
    1666:	f5 01       	movw	r30, r10
    1668:	60 81       	ld	r22, Z
    166a:	71 81       	ldd	r23, Z+1	; 0x01
    166c:	82 81       	ldd	r24, Z+2	; 0x02
    166e:	93 81       	ldd	r25, Z+3	; 0x03
    1670:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    1674:	d7 01       	movw	r26, r14
    1676:	9d 96       	adiw	r26, 0x2d	; 45
    1678:	2d 91       	ld	r18, X+
    167a:	3d 91       	ld	r19, X+
    167c:	4d 91       	ld	r20, X+
    167e:	5c 91       	ld	r21, X
    1680:	d0 97       	sbiw	r26, 0x30	; 48
    1682:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    1686:	9b 01       	movw	r18, r22
    1688:	ac 01       	movw	r20, r24
    168a:	f7 01       	movw	r30, r14
    168c:	65 a7       	std	Z+45, r22	; 0x2d
    168e:	76 a7       	std	Z+46, r23	; 0x2e
    1690:	87 a7       	std	Z+47, r24	; 0x2f
    1692:	90 ab       	std	Z+48, r25	; 0x30
                  if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
    1694:	02 30       	cpi	r16, 0x02	; 2
    1696:	c1 f5       	brne	.+112    	; 0x1708 <gc_execute_line+0xaf2>
    1698:	00 0f       	add	r16, r16
    169a:	11 1f       	adc	r17, r17
    169c:	00 0f       	add	r16, r16
    169e:	11 1f       	adc	r17, r17
    16a0:	09 59       	subi	r16, 0x99	; 153
    16a2:	1a 4f       	sbci	r17, 0xFA	; 250
    16a4:	60 91 63 05 	lds	r22, 0x0563	; 0x800563 <gc_state+0x3b>
    16a8:	70 91 64 05 	lds	r23, 0x0564	; 0x800564 <gc_state+0x3c>
    16ac:	80 91 65 05 	lds	r24, 0x0565	; 0x800565 <gc_state+0x3d>
    16b0:	90 91 66 05 	lds	r25, 0x0566	; 0x800566 <gc_state+0x3e>
    16b4:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    16b8:	d8 01       	movw	r26, r16
    16ba:	9d 96       	adiw	r26, 0x2d	; 45
    16bc:	6d 93       	st	X+, r22
    16be:	7d 93       	st	X+, r23
    16c0:	8d 93       	st	X+, r24
    16c2:	9c 93       	st	X, r25
    16c4:	d0 97       	sbiw	r26, 0x30	; 48
          }
        }
      }
          
      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {        
    16c6:	b5 e0       	ldi	r27, 0x05	; 5
    16c8:	5b 16       	cp	r5, r27
    16ca:	09 f4       	brne	.+2      	; 0x16ce <gc_execute_line+0xab8>
    16cc:	46 c0       	rjmp	.+140    	; 0x175a <gc_execute_line+0xb44>
    16ce:	e7 e0       	ldi	r30, 0x07	; 7
    16d0:	5e 16       	cp	r5, r30
    16d2:	09 f4       	brne	.+2      	; 0x16d6 <gc_execute_line+0xac0>
    16d4:	50 c0       	rjmp	.+160    	; 0x1776 <gc_execute_line+0xb60>
    16d6:	f3 e0       	ldi	r31, 0x03	; 3
    16d8:	5f 12       	cpse	r5, r31
    16da:	52 c0       	rjmp	.+164    	; 0x1780 <gc_execute_line+0xb6a>
    16dc:	34 c0       	rjmp	.+104    	; 0x1746 <gc_execute_line+0xb30>
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
                  gc_block.values.xyz[idx] += coordinate_data[idx] + gc_state.coord_offset[idx];
                  if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
                } else {  // Incremental mode
                  gc_block.values.xyz[idx] += gc_state.position[idx];
    16de:	d6 01       	movw	r26, r12
    16e0:	57 96       	adiw	r26, 0x17	; 23
    16e2:	2d 91       	ld	r18, X+
    16e4:	3d 91       	ld	r19, X+
    16e6:	4d 91       	ld	r20, X+
    16e8:	5c 91       	ld	r21, X
    16ea:	5a 97       	sbiw	r26, 0x1a	; 26
    16ec:	f7 01       	movw	r30, r14
    16ee:	65 a5       	ldd	r22, Z+45	; 0x2d
    16f0:	76 a5       	ldd	r23, Z+46	; 0x2e
    16f2:	87 a5       	ldd	r24, Z+47	; 0x2f
    16f4:	90 a9       	ldd	r25, Z+48	; 0x30
    16f6:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    16fa:	d7 01       	movw	r26, r14
    16fc:	9d 96       	adiw	r26, 0x2d	; 45
    16fe:	6d 93       	st	X+, r22
    1700:	7d 93       	st	X+, r23
    1702:	8d 93       	st	X+, r24
    1704:	9c 93       	st	X, r25
    1706:	d0 97       	sbiw	r26, 0x30	; 48
    1708:	0f 5f       	subi	r16, 0xFF	; 255
    170a:	1f 4f       	sbci	r17, 0xFF	; 255
    170c:	b4 e0       	ldi	r27, 0x04	; 4
    170e:	cb 0e       	add	r12, r27
    1710:	d1 1c       	adc	r13, r1
    1712:	e4 e0       	ldi	r30, 0x04	; 4
    1714:	ee 0e       	add	r14, r30
    1716:	f1 1c       	adc	r15, r1
    1718:	f4 e0       	ldi	r31, 0x04	; 4
    171a:	af 0e       	add	r10, r31
    171c:	b1 1c       	adc	r11, r1
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    171e:	03 30       	cpi	r16, 0x03	; 3
    1720:	11 05       	cpc	r17, r1
    1722:	09 f0       	breq	.+2      	; 0x1726 <gc_execute_line+0xb10>
    1724:	7f cf       	rjmp	.-258    	; 0x1624 <gc_execute_line+0xa0e>
    1726:	2a c5       	rjmp	.+2644   	; 0x217c <gc_execute_line+0x1566>
          }
        }
      }
          
      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {        
    1728:	25 e0       	ldi	r18, 0x05	; 5
    172a:	52 16       	cp	r5, r18
    172c:	b1 f0       	breq	.+44     	; 0x175a <gc_execute_line+0xb44>
    172e:	37 e0       	ldi	r19, 0x07	; 7
    1730:	53 16       	cp	r5, r19
    1732:	09 f1       	breq	.+66     	; 0x1776 <gc_execute_line+0xb60>
    1734:	83 e0       	ldi	r24, 0x03	; 3
    1736:	58 12       	cpse	r5, r24
    1738:	23 c0       	rjmp	.+70     	; 0x1780 <gc_execute_line+0xb6a>
        case NON_MODAL_GO_HOME_0: 
          // [G28 Errors]: Cutter compensation is enabled. 
          // Retreive G28 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
    173a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    173c:	91 11       	cpse	r25, r1
    173e:	03 c0       	rjmp	.+6      	; 0x1746 <gc_execute_line+0xb30>
    1740:	1a a2       	std	Y+34, r1	; 0x22
    1742:	01 c0       	rjmp	.+2      	; 0x1746 <gc_execute_line+0xb30>
    1744:	1a a2       	std	Y+34, r1	; 0x22
          if (!settings_read_coord_data(SETTING_INDEX_G28,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    1746:	be 01       	movw	r22, r28
    1748:	63 5f       	subi	r22, 0xF3	; 243
    174a:	7f 4f       	sbci	r23, 0xFF	; 255
    174c:	86 e0       	ldi	r24, 0x06	; 6
    174e:	0e 94 0a 2a 	call	0x5414	; 0x5414 <settings_read_coord_data>
    1752:	88 23       	and	r24, r24
    1754:	09 f4       	brne	.+2      	; 0x1758 <gc_execute_line+0xb42>
    1756:	ae c4       	rjmp	.+2396   	; 0x20b4 <gc_execute_line+0x149e>
    1758:	13 c0       	rjmp	.+38     	; 0x1780 <gc_execute_line+0xb6a>
          break;
        case NON_MODAL_GO_HOME_1:
          // [G30 Errors]: Cutter compensation is enabled. 
          // Retreive G30 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
    175a:	ae 8d       	ldd	r26, Y+30	; 0x1e
    175c:	a1 11       	cpse	r26, r1
    175e:	01 c0       	rjmp	.+2      	; 0x1762 <gc_execute_line+0xb4c>
    1760:	1a a2       	std	Y+34, r1	; 0x22
          if (!settings_read_coord_data(SETTING_INDEX_G30,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    1762:	be 01       	movw	r22, r28
    1764:	63 5f       	subi	r22, 0xF3	; 243
    1766:	7f 4f       	sbci	r23, 0xFF	; 255
    1768:	87 e0       	ldi	r24, 0x07	; 7
    176a:	0e 94 0a 2a 	call	0x5414	; 0x5414 <settings_read_coord_data>
    176e:	88 23       	and	r24, r24
    1770:	09 f4       	brne	.+2      	; 0x1774 <gc_execute_line+0xb5e>
    1772:	a2 c4       	rjmp	.+2372   	; 0x20b8 <gc_execute_line+0x14a2>
    1774:	05 c0       	rjmp	.+10     	; 0x1780 <gc_execute_line+0xb6a>
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
    1776:	80 91 68 05 	lds	r24, 0x0568	; 0x800568 <gc_block+0x1>
    177a:	82 30       	cpi	r24, 0x02	; 2
    177c:	08 f0       	brcs	.+2      	; 0x1780 <gc_execute_line+0xb6a>
    177e:	9e c4       	rjmp	.+2364   	; 0x20bc <gc_execute_line+0x14a6>
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    1780:	10 91 68 05 	lds	r17, 0x0568	; 0x800568 <gc_block+0x1>
    1784:	18 30       	cpi	r17, 0x08	; 8
    1786:	61 f4       	brne	.+24     	; 0x17a0 <gc_execute_line+0xb8a>
    // [G80 Errors]: Axis word exist and are not used by a non-modal command.
    if ((axis_words) && (axis_command != AXIS_COMMAND_NON_MODAL)) { 
    1788:	be 8d       	ldd	r27, Y+30	; 0x1e
    178a:	bb 23       	and	r27, r27
    178c:	09 f4       	brne	.+2      	; 0x1790 <gc_execute_line+0xb7a>
    178e:	2f c2       	rjmp	.+1118   	; 0x1bee <gc_execute_line+0xfd8>
    1790:	1f a2       	std	Y+39, r1	; 0x27
    1792:	01 c0       	rjmp	.+2      	; 0x1796 <gc_execute_line+0xb80>
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    1794:	1f a2       	std	Y+39, r1	; 0x27
    // [G80 Errors]: Axis word exist and are not used by a non-modal command.
    if ((axis_words) && (axis_command != AXIS_COMMAND_NON_MODAL)) { 
    1796:	ea a1       	ldd	r30, Y+34	; 0x22
    1798:	e1 30       	cpi	r30, 0x01	; 1
    179a:	09 f0       	breq	.+2      	; 0x179e <gc_execute_line+0xb88>
    179c:	91 c4       	rjmp	.+2338   	; 0x20c0 <gc_execute_line+0x14aa>
    179e:	30 c2       	rjmp	.+1120   	; 0x1c00 <gc_execute_line+0xfea>
    17a0:	1f a2       	std	Y+39, r1	; 0x27
      FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); // [No axis words allowed]
    }

  // Check remaining motion modes, if axis word are implicit (exist and not used by G10/28/30/92), or 
  // was explicitly commanded in the g-code block.
  } else if ( axis_command == AXIS_COMMAND_MOTION_MODE ) {
    17a2:	fa a1       	ldd	r31, Y+34	; 0x22
    17a4:	f2 30       	cpi	r31, 0x02	; 2
    17a6:	09 f0       	breq	.+2      	; 0x17aa <gc_execute_line+0xb94>
    17a8:	23 c2       	rjmp	.+1094   	; 0x1bf0 <gc_execute_line+0xfda>
  
    if (gc_block.modal.motion == MOTION_MODE_SEEK) {
    17aa:	11 11       	cpse	r17, r1
    17ac:	05 c0       	rjmp	.+10     	; 0x17b8 <gc_execute_line+0xba2>
      // [G0 Errors]: Axis letter not configured or without real value (done.)
      // Axis words are optional. If missing, set axis command flag to ignore execution.
      if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    17ae:	2e 8d       	ldd	r18, Y+30	; 0x1e
    17b0:	22 23       	and	r18, r18
    17b2:	09 f4       	brne	.+2      	; 0x17b6 <gc_execute_line+0xba0>
    17b4:	01 c5       	rjmp	.+2562   	; 0x21b8 <gc_execute_line+0x15a2>
    17b6:	24 c2       	rjmp	.+1096   	; 0x1c00 <gc_execute_line+0xfea>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {      
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    17b8:	20 e0       	ldi	r18, 0x00	; 0
    17ba:	30 e0       	ldi	r19, 0x00	; 0
    17bc:	a9 01       	movw	r20, r18
    17be:	60 91 72 05 	lds	r22, 0x0572	; 0x800572 <gc_block+0xb>
    17c2:	70 91 73 05 	lds	r23, 0x0573	; 0x800573 <gc_block+0xc>
    17c6:	80 91 74 05 	lds	r24, 0x0574	; 0x800574 <gc_block+0xd>
    17ca:	90 91 75 05 	lds	r25, 0x0575	; 0x800575 <gc_block+0xe>
    17ce:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    17d2:	88 23       	and	r24, r24
    17d4:	09 f4       	brne	.+2      	; 0x17d8 <gc_execute_line+0xbc2>
    17d6:	76 c4       	rjmp	.+2284   	; 0x20c4 <gc_execute_line+0x14ae>
     
      switch (gc_block.modal.motion) {
    17d8:	14 30       	cpi	r17, 0x04	; 4
    17da:	28 f4       	brcc	.+10     	; 0x17e6 <gc_execute_line+0xbd0>
    17dc:	12 30       	cpi	r17, 0x02	; 2
    17de:	60 f4       	brcc	.+24     	; 0x17f8 <gc_execute_line+0xbe2>
    17e0:	11 30       	cpi	r17, 0x01	; 1
    17e2:	29 f0       	breq	.+10     	; 0x17ee <gc_execute_line+0xbd8>
    17e4:	05 c2       	rjmp	.+1034   	; 0x1bf0 <gc_execute_line+0xfda>
    17e6:	18 30       	cpi	r17, 0x08	; 8
    17e8:	08 f4       	brcc	.+2      	; 0x17ec <gc_execute_line+0xbd6>
    17ea:	f4 c1       	rjmp	.+1000   	; 0x1bd4 <gc_execute_line+0xfbe>
    17ec:	01 c2       	rjmp	.+1026   	; 0x1bf0 <gc_execute_line+0xfda>
        case MOTION_MODE_LINEAR: 
          // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
          // Axis words are optional. If missing, set axis command flag to ignore execution.
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    17ee:	3e 8d       	ldd	r19, Y+30	; 0x1e
    17f0:	33 23       	and	r19, r19
    17f2:	09 f4       	brne	.+2      	; 0x17f6 <gc_execute_line+0xbe0>
    17f4:	e1 c4       	rjmp	.+2498   	; 0x21b8 <gc_execute_line+0x15a2>
    17f6:	04 c2       	rjmp	.+1032   	; 0x1c00 <gc_execute_line+0xfea>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current 
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).   
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.        
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.
        
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    17f8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    17fa:	88 23       	and	r24, r24
    17fc:	09 f4       	brne	.+2      	; 0x1800 <gc_execute_line+0xbea>
    17fe:	64 c4       	rjmp	.+2248   	; 0x20c8 <gc_execute_line+0x14b2>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    1800:	9c a1       	ldd	r25, Y+36	; 0x24
    1802:	a9 2e       	mov	r10, r25
    1804:	b1 2c       	mov	r11, r1
    1806:	ad a1       	ldd	r26, Y+37	; 0x25
    1808:	8a 2e       	mov	r8, r26
    180a:	91 2c       	mov	r9, r1
    180c:	81 e0       	ldi	r24, 0x01	; 1
    180e:	90 e0       	ldi	r25, 0x00	; 0
    1810:	8c 01       	movw	r16, r24
    1812:	0c a0       	ldd	r0, Y+36	; 0x24
    1814:	02 c0       	rjmp	.+4      	; 0x181a <gc_execute_line+0xc04>
    1816:	00 0f       	add	r16, r16
    1818:	11 1f       	adc	r17, r17
    181a:	0a 94       	dec	r0
    181c:	e2 f7       	brpl	.-8      	; 0x1816 <gc_execute_line+0xc00>
    181e:	02 c0       	rjmp	.+4      	; 0x1824 <gc_execute_line+0xc0e>
    1820:	88 0f       	add	r24, r24
    1822:	99 1f       	adc	r25, r25
    1824:	aa 95       	dec	r26
    1826:	e2 f7       	brpl	.-8      	; 0x1820 <gc_execute_line+0xc0a>
    1828:	08 2b       	or	r16, r24
    182a:	19 2b       	or	r17, r25
    182c:	be 8d       	ldd	r27, Y+30	; 0x1e
    182e:	8b 2f       	mov	r24, r27
    1830:	90 e0       	ldi	r25, 0x00	; 0
    1832:	80 23       	and	r24, r16
    1834:	91 23       	and	r25, r17
    1836:	89 2b       	or	r24, r25
    1838:	09 f4       	brne	.+2      	; 0x183c <gc_execute_line+0xc26>
    183a:	48 c4       	rjmp	.+2192   	; 0x20cc <gc_execute_line+0x14b6>
        
          // Calculate the change in position along each selected axis
          float x,y;
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
    183c:	c5 01       	movw	r24, r10
    183e:	88 0f       	add	r24, r24
    1840:	99 1f       	adc	r25, r25
    1842:	88 0f       	add	r24, r24
    1844:	99 1f       	adc	r25, r25
    1846:	fc 01       	movw	r30, r24
    1848:	e9 59       	subi	r30, 0x99	; 153
    184a:	fa 4f       	sbci	r31, 0xFA	; 250
    184c:	dc 01       	movw	r26, r24
    184e:	a8 5d       	subi	r26, 0xD8	; 216
    1850:	ba 4f       	sbci	r27, 0xFA	; 250
    1852:	57 96       	adiw	r26, 0x17	; 23
    1854:	2d 91       	ld	r18, X+
    1856:	3d 91       	ld	r19, X+
    1858:	4d 91       	ld	r20, X+
    185a:	5c 91       	ld	r21, X
    185c:	5a 97       	sbiw	r26, 0x1a	; 26
    185e:	65 a5       	ldd	r22, Z+45	; 0x2d
    1860:	76 a5       	ldd	r23, Z+46	; 0x2e
    1862:	87 a5       	ldd	r24, Z+47	; 0x2f
    1864:	90 a9       	ldd	r25, Z+48	; 0x30
    1866:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    186a:	6e 8f       	std	Y+30, r22	; 0x1e
    186c:	7f 8f       	std	Y+31, r23	; 0x1f
    186e:	88 a3       	std	Y+32, r24	; 0x20
    1870:	99 a3       	std	Y+33, r25	; 0x21
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target
    1872:	c4 01       	movw	r24, r8
    1874:	88 0f       	add	r24, r24
    1876:	99 1f       	adc	r25, r25
    1878:	88 0f       	add	r24, r24
    187a:	99 1f       	adc	r25, r25
    187c:	fc 01       	movw	r30, r24
    187e:	e9 59       	subi	r30, 0x99	; 153
    1880:	fa 4f       	sbci	r31, 0xFA	; 250
    1882:	dc 01       	movw	r26, r24
    1884:	a8 5d       	subi	r26, 0xD8	; 216
    1886:	ba 4f       	sbci	r27, 0xFA	; 250
    1888:	57 96       	adiw	r26, 0x17	; 23
    188a:	2d 91       	ld	r18, X+
    188c:	3d 91       	ld	r19, X+
    188e:	4d 91       	ld	r20, X+
    1890:	5c 91       	ld	r21, X
    1892:	5a 97       	sbiw	r26, 0x1a	; 26
    1894:	65 a5       	ldd	r22, Z+45	; 0x2d
    1896:	76 a5       	ldd	r23, Z+46	; 0x2e
    1898:	87 a5       	ldd	r24, Z+47	; 0x2f
    189a:	90 a9       	ldd	r25, Z+48	; 0x30
    189c:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    18a0:	68 a7       	std	Y+40, r22	; 0x28
    18a2:	79 a7       	std	Y+41, r23	; 0x29
    18a4:	8a a7       	std	Y+42, r24	; 0x2a
    18a6:	9b a7       	std	Y+43, r25	; 0x2b

          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
    18a8:	67 fe       	sbrs	r6, 7
    18aa:	e6 c0       	rjmp	.+460    	; 0x1a78 <gc_execute_line+0xe62>
            bit_false(value_words,bit(WORD_R));
    18ac:	e8 94       	clt
    18ae:	67 f8       	bld	r6, 7
            if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    18b0:	64 e9       	ldi	r22, 0x94	; 148
    18b2:	75 e0       	ldi	r23, 0x05	; 5
    18b4:	8f e3       	ldi	r24, 0x3F	; 63
    18b6:	95 e0       	ldi	r25, 0x05	; 5
    18b8:	0e 94 ca 05 	call	0xb94	; 0xb94 <gc_check_same_position>
    18bc:	81 11       	cpse	r24, r1
    18be:	08 c4       	rjmp	.+2064   	; 0x20d0 <gc_execute_line+0x14ba>
          
            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
    18c0:	80 91 6a 05 	lds	r24, 0x056A	; 0x80056a <gc_block+0x3>
    18c4:	81 30       	cpi	r24, 0x01	; 1
    18c6:	a1 f4       	brne	.+40     	; 0x18f0 <gc_execute_line+0xcda>
    18c8:	07 e6       	ldi	r16, 0x67	; 103
    18ca:	15 e0       	ldi	r17, 0x05	; 5
    18cc:	23 e3       	ldi	r18, 0x33	; 51
    18ce:	33 e3       	ldi	r19, 0x33	; 51
    18d0:	4b ec       	ldi	r20, 0xCB	; 203
    18d2:	51 e4       	ldi	r21, 0x41	; 65
    18d4:	f8 01       	movw	r30, r16
    18d6:	64 a1       	ldd	r22, Z+36	; 0x24
    18d8:	75 a1       	ldd	r23, Z+37	; 0x25
    18da:	86 a1       	ldd	r24, Z+38	; 0x26
    18dc:	97 a1       	ldd	r25, Z+39	; 0x27
    18de:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    18e2:	d8 01       	movw	r26, r16
    18e4:	94 96       	adiw	r26, 0x24	; 36
    18e6:	6d 93       	st	X+, r22
    18e8:	7d 93       	st	X+, r23
    18ea:	8d 93       	st	X+, r24
    18ec:	9c 93       	st	X, r25
    18ee:	97 97       	sbiw	r26, 0x27	; 39
                j = (y + (x * h_x2_div_d))/2       
            */      

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;
    18f0:	c0 90 8b 05 	lds	r12, 0x058B	; 0x80058b <gc_block+0x24>
    18f4:	d0 90 8c 05 	lds	r13, 0x058C	; 0x80058c <gc_block+0x25>
    18f8:	e0 90 8d 05 	lds	r14, 0x058D	; 0x80058d <gc_block+0x26>
    18fc:	f0 90 8e 05 	lds	r15, 0x058E	; 0x80058e <gc_block+0x27>
    1900:	20 e0       	ldi	r18, 0x00	; 0
    1902:	30 e0       	ldi	r19, 0x00	; 0
    1904:	40 e8       	ldi	r20, 0x80	; 128
    1906:	50 e4       	ldi	r21, 0x40	; 64
    1908:	c7 01       	movw	r24, r14
    190a:	b6 01       	movw	r22, r12
    190c:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    1910:	a7 01       	movw	r20, r14
    1912:	96 01       	movw	r18, r12
    1914:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    1918:	6b 01       	movw	r12, r22
    191a:	7c 01       	movw	r14, r24
    191c:	2e 8d       	ldd	r18, Y+30	; 0x1e
    191e:	3f 8d       	ldd	r19, Y+31	; 0x1f
    1920:	48 a1       	ldd	r20, Y+32	; 0x20
    1922:	59 a1       	ldd	r21, Y+33	; 0x21
    1924:	ca 01       	movw	r24, r20
    1926:	b9 01       	movw	r22, r18
    1928:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    192c:	9b 01       	movw	r18, r22
    192e:	ac 01       	movw	r20, r24
    1930:	c7 01       	movw	r24, r14
    1932:	b6 01       	movw	r22, r12
    1934:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    1938:	6b 01       	movw	r12, r22
    193a:	7c 01       	movw	r14, r24
    193c:	28 a5       	ldd	r18, Y+40	; 0x28
    193e:	39 a5       	ldd	r19, Y+41	; 0x29
    1940:	4a a5       	ldd	r20, Y+42	; 0x2a
    1942:	5b a5       	ldd	r21, Y+43	; 0x2b
    1944:	ca 01       	movw	r24, r20
    1946:	b9 01       	movw	r22, r18
    1948:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    194c:	9b 01       	movw	r18, r22
    194e:	ac 01       	movw	r20, r24
    1950:	c7 01       	movw	r24, r14
    1952:	b6 01       	movw	r22, r12
    1954:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    1958:	6b 01       	movw	r12, r22
    195a:	7c 01       	movw	r14, r24

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    195c:	20 e0       	ldi	r18, 0x00	; 0
    195e:	30 e0       	ldi	r19, 0x00	; 0
    1960:	a9 01       	movw	r20, r18
    1962:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    1966:	88 23       	and	r24, r24
    1968:	0c f4       	brge	.+2      	; 0x196c <gc_execute_line+0xd56>
    196a:	b4 c3       	rjmp	.+1896   	; 0x20d4 <gc_execute_line+0x14be>
    
            // Finish computing h_x2_div_d.
            h_x2_div_d = -sqrt(h_x2_div_d)/hypot_f(x,y); // == -(h * 2 / d)
    196c:	c7 01       	movw	r24, r14
    196e:	b6 01       	movw	r22, r12
    1970:	0e 94 a0 3c 	call	0x7940	; 0x7940 <sqrt>
    1974:	6b 01       	movw	r12, r22
    1976:	7c 01       	movw	r14, r24
    1978:	28 a5       	ldd	r18, Y+40	; 0x28
    197a:	39 a5       	ldd	r19, Y+41	; 0x29
    197c:	4a a5       	ldd	r20, Y+42	; 0x2a
    197e:	5b a5       	ldd	r21, Y+43	; 0x2b
    1980:	6e 8d       	ldd	r22, Y+30	; 0x1e
    1982:	7f 8d       	ldd	r23, Y+31	; 0x1f
    1984:	88 a1       	ldd	r24, Y+32	; 0x20
    1986:	99 a1       	ldd	r25, Y+33	; 0x21
    1988:	0e 94 36 19 	call	0x326c	; 0x326c <hypot_f>
    198c:	9b 01       	movw	r18, r22
    198e:	ac 01       	movw	r20, r24
    1990:	c7 01       	movw	r24, r14
    1992:	b6 01       	movw	r22, r12
    1994:	90 58       	subi	r25, 0x80	; 128
    1996:	0e 94 a9 39 	call	0x7352	; 0x7352 <__divsf3>
    199a:	6b 01       	movw	r12, r22
    199c:	7c 01       	movw	r14, r24
            // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)
            if (gc_block.modal.motion == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }  
    199e:	80 91 68 05 	lds	r24, 0x0568	; 0x800568 <gc_block+0x1>
    19a2:	83 30       	cpi	r24, 0x03	; 3
    19a4:	21 f4       	brne	.+8      	; 0x19ae <gc_execute_line+0xd98>
    19a6:	f7 fa       	bst	r15, 7
    19a8:	f0 94       	com	r15
    19aa:	f7 f8       	bld	r15, 7
    19ac:	f0 94       	com	r15
            */  
            // Negative R is g-code-alese for "I want a circle with more than 180 degrees of travel" (go figure!), 
            // even though it is advised against ever generating such circles in a single line of g-code. By 
            // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite side of the line of
            // travel and thus we get the unadvisably long arcs as prescribed.
            if (gc_block.values.r < 0) { 
    19ae:	20 90 8b 05 	lds	r2, 0x058B	; 0x80058b <gc_block+0x24>
    19b2:	30 90 8c 05 	lds	r3, 0x058C	; 0x80058c <gc_block+0x25>
    19b6:	40 90 8d 05 	lds	r4, 0x058D	; 0x80058d <gc_block+0x26>
    19ba:	50 90 8e 05 	lds	r5, 0x058E	; 0x80058e <gc_block+0x27>
    19be:	20 e0       	ldi	r18, 0x00	; 0
    19c0:	30 e0       	ldi	r19, 0x00	; 0
    19c2:	a9 01       	movw	r20, r18
    19c4:	c2 01       	movw	r24, r4
    19c6:	b1 01       	movw	r22, r2
    19c8:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    19cc:	88 23       	and	r24, r24
    19ce:	7c f4       	brge	.+30     	; 0x19ee <gc_execute_line+0xdd8>
                h_x2_div_d = -h_x2_div_d; 
    19d0:	f7 fa       	bst	r15, 7
    19d2:	f0 94       	com	r15
    19d4:	f7 f8       	bld	r15, 7
    19d6:	f0 94       	com	r15
                gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
    19d8:	d2 01       	movw	r26, r4
    19da:	c1 01       	movw	r24, r2
    19dc:	b0 58       	subi	r27, 0x80	; 128
    19de:	80 93 8b 05 	sts	0x058B, r24	; 0x80058b <gc_block+0x24>
    19e2:	90 93 8c 05 	sts	0x058C, r25	; 0x80058c <gc_block+0x25>
    19e6:	a0 93 8d 05 	sts	0x058D, r26	; 0x80058d <gc_block+0x26>
    19ea:	b0 93 8e 05 	sts	0x058E, r27	; 0x80058e <gc_block+0x27>
            }        
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
    19ee:	85 01       	movw	r16, r10
    19f0:	00 0f       	add	r16, r16
    19f2:	11 1f       	adc	r17, r17
    19f4:	00 0f       	add	r16, r16
    19f6:	11 1f       	adc	r17, r17
    19f8:	05 59       	subi	r16, 0x95	; 149
    19fa:	1a 4f       	sbci	r17, 0xFA	; 250
    19fc:	28 a5       	ldd	r18, Y+40	; 0x28
    19fe:	39 a5       	ldd	r19, Y+41	; 0x29
    1a00:	4a a5       	ldd	r20, Y+42	; 0x2a
    1a02:	5b a5       	ldd	r21, Y+43	; 0x2b
    1a04:	c7 01       	movw	r24, r14
    1a06:	b6 01       	movw	r22, r12
    1a08:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    1a0c:	9b 01       	movw	r18, r22
    1a0e:	ac 01       	movw	r20, r24
    1a10:	6e 8d       	ldd	r22, Y+30	; 0x1e
    1a12:	7f 8d       	ldd	r23, Y+31	; 0x1f
    1a14:	88 a1       	ldd	r24, Y+32	; 0x20
    1a16:	99 a1       	ldd	r25, Y+33	; 0x21
    1a18:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    1a1c:	20 e0       	ldi	r18, 0x00	; 0
    1a1e:	30 e0       	ldi	r19, 0x00	; 0
    1a20:	40 e0       	ldi	r20, 0x00	; 0
    1a22:	5f e3       	ldi	r21, 0x3F	; 63
    1a24:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    1a28:	f8 01       	movw	r30, r16
    1a2a:	63 87       	std	Z+11, r22	; 0x0b
    1a2c:	74 87       	std	Z+12, r23	; 0x0c
    1a2e:	85 87       	std	Z+13, r24	; 0x0d
    1a30:	96 87       	std	Z+14, r25	; 0x0e
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
    1a32:	84 01       	movw	r16, r8
    1a34:	00 0f       	add	r16, r16
    1a36:	11 1f       	adc	r17, r17
    1a38:	00 0f       	add	r16, r16
    1a3a:	11 1f       	adc	r17, r17
    1a3c:	05 59       	subi	r16, 0x95	; 149
    1a3e:	1a 4f       	sbci	r17, 0xFA	; 250
    1a40:	2e 8d       	ldd	r18, Y+30	; 0x1e
    1a42:	3f 8d       	ldd	r19, Y+31	; 0x1f
    1a44:	48 a1       	ldd	r20, Y+32	; 0x20
    1a46:	59 a1       	ldd	r21, Y+33	; 0x21
    1a48:	c7 01       	movw	r24, r14
    1a4a:	b6 01       	movw	r22, r12
    1a4c:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    1a50:	28 a5       	ldd	r18, Y+40	; 0x28
    1a52:	39 a5       	ldd	r19, Y+41	; 0x29
    1a54:	4a a5       	ldd	r20, Y+42	; 0x2a
    1a56:	5b a5       	ldd	r21, Y+43	; 0x2b
    1a58:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    1a5c:	20 e0       	ldi	r18, 0x00	; 0
    1a5e:	30 e0       	ldi	r19, 0x00	; 0
    1a60:	40 e0       	ldi	r20, 0x00	; 0
    1a62:	5f e3       	ldi	r21, 0x3F	; 63
    1a64:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    1a68:	d8 01       	movw	r26, r16
    1a6a:	1b 96       	adiw	r26, 0x0b	; 11
    1a6c:	6d 93       	st	X+, r22
    1a6e:	7d 93       	st	X+, r23
    1a70:	8d 93       	st	X+, r24
    1a72:	9c 93       	st	X, r25
    1a74:	1e 97       	sbiw	r26, 0x0e	; 14
    1a76:	c4 c0       	rjmp	.+392    	; 0x1c00 <gc_execute_line+0xfea>
          
          } else { // Arc Center Format Offset Mode  
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    1a78:	bb a1       	ldd	r27, Y+35	; 0x23
    1a7a:	cb 2e       	mov	r12, r27
    1a7c:	d1 2c       	mov	r13, r1
    1a7e:	0c 21       	and	r16, r12
    1a80:	1d 21       	and	r17, r13
    1a82:	01 2b       	or	r16, r17
    1a84:	09 f4       	brne	.+2      	; 0x1a88 <gc_execute_line+0xe72>
    1a86:	28 c3       	rjmp	.+1616   	; 0x20d8 <gc_execute_line+0x14c2>
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));  
    1a88:	e1 ef       	ldi	r30, 0xF1	; 241
    1a8a:	6e 22       	and	r6, r30
          
            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
    1a8c:	80 91 6a 05 	lds	r24, 0x056A	; 0x80056a <gc_block+0x3>
    1a90:	81 30       	cpi	r24, 0x01	; 1
    1a92:	41 f5       	brne	.+80     	; 0x1ae4 <gc_execute_line+0xece>
    1a94:	07 e6       	ldi	r16, 0x67	; 103
    1a96:	15 e0       	ldi	r17, 0x05	; 5
    1a98:	e1 2c       	mov	r14, r1
    1a9a:	f1 2c       	mov	r15, r1
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
    1a9c:	c6 01       	movw	r24, r12
    1a9e:	0e 2c       	mov	r0, r14
    1aa0:	02 c0       	rjmp	.+4      	; 0x1aa6 <gc_execute_line+0xe90>
    1aa2:	95 95       	asr	r25
    1aa4:	87 95       	ror	r24
    1aa6:	0a 94       	dec	r0
    1aa8:	e2 f7       	brpl	.-8      	; 0x1aa2 <gc_execute_line+0xe8c>
    1aaa:	80 ff       	sbrs	r24, 0
    1aac:	12 c0       	rjmp	.+36     	; 0x1ad2 <gc_execute_line+0xebc>
    1aae:	23 e3       	ldi	r18, 0x33	; 51
    1ab0:	33 e3       	ldi	r19, 0x33	; 51
    1ab2:	4b ec       	ldi	r20, 0xCB	; 203
    1ab4:	51 e4       	ldi	r21, 0x41	; 65
    1ab6:	d8 01       	movw	r26, r16
    1ab8:	1f 96       	adiw	r26, 0x0f	; 15
    1aba:	6d 91       	ld	r22, X+
    1abc:	7d 91       	ld	r23, X+
    1abe:	8d 91       	ld	r24, X+
    1ac0:	9c 91       	ld	r25, X
    1ac2:	52 97       	sbiw	r26, 0x12	; 18
    1ac4:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    1ac8:	f8 01       	movw	r30, r16
    1aca:	67 87       	std	Z+15, r22	; 0x0f
    1acc:	70 8b       	std	Z+16, r23	; 0x10
    1ace:	81 8b       	std	Z+17, r24	; 0x11
    1ad0:	92 8b       	std	Z+18, r25	; 0x12
    1ad2:	ff ef       	ldi	r31, 0xFF	; 255
    1ad4:	ef 1a       	sub	r14, r31
    1ad6:	ff 0a       	sbc	r15, r31
    1ad8:	0c 5f       	subi	r16, 0xFC	; 252
    1ada:	1f 4f       	sbci	r17, 0xFF	; 255
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));  
          
            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    1adc:	23 e0       	ldi	r18, 0x03	; 3
    1ade:	e2 16       	cp	r14, r18
    1ae0:	f1 04       	cpc	r15, r1
    1ae2:	e1 f6       	brne	.-72     	; 0x1a9c <gc_execute_line+0xe86>
              }
            }         

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
    1ae4:	c4 01       	movw	r24, r8
    1ae6:	88 0f       	add	r24, r24
    1ae8:	99 1f       	adc	r25, r25
    1aea:	88 0f       	add	r24, r24
    1aec:	99 1f       	adc	r25, r25
    1aee:	dc 01       	movw	r26, r24
    1af0:	a5 59       	subi	r26, 0x95	; 149
    1af2:	ba 4f       	sbci	r27, 0xFA	; 250
    1af4:	7d 01       	movw	r14, r26
            float target_r = hypot_f(x,y); 
    1af6:	1b 96       	adiw	r26, 0x0b	; 11
    1af8:	2d 91       	ld	r18, X+
    1afa:	3d 91       	ld	r19, X+
    1afc:	4d 91       	ld	r20, X+
    1afe:	5c 91       	ld	r21, X
    1b00:	1e 97       	sbiw	r26, 0x0e	; 14
    1b02:	68 a5       	ldd	r22, Y+40	; 0x28
    1b04:	79 a5       	ldd	r23, Y+41	; 0x29
    1b06:	8a a5       	ldd	r24, Y+42	; 0x2a
    1b08:	9b a5       	ldd	r25, Y+43	; 0x2b
    1b0a:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    1b0e:	1b 01       	movw	r2, r22
    1b10:	2c 01       	movw	r4, r24
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
              }
            }         

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
    1b12:	85 01       	movw	r16, r10
    1b14:	00 0f       	add	r16, r16
    1b16:	11 1f       	adc	r17, r17
    1b18:	00 0f       	add	r16, r16
    1b1a:	11 1f       	adc	r17, r17
    1b1c:	05 59       	subi	r16, 0x95	; 149
    1b1e:	1a 4f       	sbci	r17, 0xFA	; 250
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
            float target_r = hypot_f(x,y); 
    1b20:	f8 01       	movw	r30, r16
    1b22:	23 85       	ldd	r18, Z+11	; 0x0b
    1b24:	34 85       	ldd	r19, Z+12	; 0x0c
    1b26:	45 85       	ldd	r20, Z+13	; 0x0d
    1b28:	56 85       	ldd	r21, Z+14	; 0x0e
    1b2a:	6e 8d       	ldd	r22, Y+30	; 0x1e
    1b2c:	7f 8d       	ldd	r23, Y+31	; 0x1f
    1b2e:	88 a1       	ldd	r24, Y+32	; 0x20
    1b30:	99 a1       	ldd	r25, Y+33	; 0x21
    1b32:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    1b36:	a2 01       	movw	r20, r4
    1b38:	91 01       	movw	r18, r2
    1b3a:	0e 94 36 19 	call	0x326c	; 0x326c <hypot_f>
    1b3e:	4b 01       	movw	r8, r22
    1b40:	5c 01       	movw	r10, r24

            // Compute arc radius for mc_arc. Defined from current location to center.
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]); 
    1b42:	d7 01       	movw	r26, r14
    1b44:	1b 96       	adiw	r26, 0x0b	; 11
    1b46:	2d 91       	ld	r18, X+
    1b48:	3d 91       	ld	r19, X+
    1b4a:	4d 91       	ld	r20, X+
    1b4c:	5c 91       	ld	r21, X
    1b4e:	1e 97       	sbiw	r26, 0x0e	; 14
    1b50:	f8 01       	movw	r30, r16
    1b52:	63 85       	ldd	r22, Z+11	; 0x0b
    1b54:	74 85       	ldd	r23, Z+12	; 0x0c
    1b56:	85 85       	ldd	r24, Z+13	; 0x0d
    1b58:	96 85       	ldd	r25, Z+14	; 0x0e
    1b5a:	0e 94 36 19 	call	0x326c	; 0x326c <hypot_f>
    1b5e:	6b 01       	movw	r12, r22
    1b60:	7c 01       	movw	r14, r24
    1b62:	60 93 8b 05 	sts	0x058B, r22	; 0x80058b <gc_block+0x24>
    1b66:	70 93 8c 05 	sts	0x058C, r23	; 0x80058c <gc_block+0x25>
    1b6a:	80 93 8d 05 	sts	0x058D, r24	; 0x80058d <gc_block+0x26>
    1b6e:	90 93 8e 05 	sts	0x058E, r25	; 0x80058e <gc_block+0x27>
            
            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
    1b72:	9b 01       	movw	r18, r22
    1b74:	ac 01       	movw	r20, r24
    1b76:	c5 01       	movw	r24, r10
    1b78:	b4 01       	movw	r22, r8
    1b7a:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    1b7e:	4b 01       	movw	r8, r22
    1b80:	5c 01       	movw	r10, r24
    1b82:	e8 94       	clt
    1b84:	b7 f8       	bld	r11, 7
            if (delta_r > 0.005) { 
    1b86:	2a e0       	ldi	r18, 0x0A	; 10
    1b88:	37 ed       	ldi	r19, 0xD7	; 215
    1b8a:	43 ea       	ldi	r20, 0xA3	; 163
    1b8c:	5b e3       	ldi	r21, 0x3B	; 59
    1b8e:	c5 01       	movw	r24, r10
    1b90:	b4 01       	movw	r22, r8
    1b92:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    1b96:	18 16       	cp	r1, r24
    1b98:	9c f5       	brge	.+102    	; 0x1c00 <gc_execute_line+0xfea>
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    1b9a:	20 e0       	ldi	r18, 0x00	; 0
    1b9c:	30 e0       	ldi	r19, 0x00	; 0
    1b9e:	40 e0       	ldi	r20, 0x00	; 0
    1ba0:	5f e3       	ldi	r21, 0x3F	; 63
    1ba2:	c5 01       	movw	r24, r10
    1ba4:	b4 01       	movw	r22, r8
    1ba6:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    1baa:	18 16       	cp	r1, r24
    1bac:	0c f4       	brge	.+2      	; 0x1bb0 <gc_execute_line+0xf9a>
    1bae:	96 c2       	rjmp	.+1324   	; 0x20dc <gc_execute_line+0x14c6>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    1bb0:	2f e6       	ldi	r18, 0x6F	; 111
    1bb2:	32 e1       	ldi	r19, 0x12	; 18
    1bb4:	43 e8       	ldi	r20, 0x83	; 131
    1bb6:	5a e3       	ldi	r21, 0x3A	; 58
    1bb8:	c7 01       	movw	r24, r14
    1bba:	b6 01       	movw	r22, r12
    1bbc:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    1bc0:	9b 01       	movw	r18, r22
    1bc2:	ac 01       	movw	r20, r24
    1bc4:	c5 01       	movw	r24, r10
    1bc6:	b4 01       	movw	r22, r8
    1bc8:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    1bcc:	18 16       	cp	r1, r24
    1bce:	0c f4       	brge	.+2      	; 0x1bd2 <gc_execute_line+0xfbc>
    1bd0:	87 c2       	rjmp	.+1294   	; 0x20e0 <gc_execute_line+0x14ca>
    1bd2:	16 c0       	rjmp	.+44     	; 0x1c00 <gc_execute_line+0xfea>
        case MOTION_MODE_PROBE_AWAY: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to 
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1bd4:	fe 8d       	ldd	r31, Y+30	; 0x1e
    1bd6:	ff 23       	and	r31, r31
    1bd8:	09 f4       	brne	.+2      	; 0x1bdc <gc_execute_line+0xfc6>
    1bda:	84 c2       	rjmp	.+1288   	; 0x20e4 <gc_execute_line+0x14ce>
          if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    1bdc:	64 e9       	ldi	r22, 0x94	; 148
    1bde:	75 e0       	ldi	r23, 0x05	; 5
    1be0:	8f e3       	ldi	r24, 0x3F	; 63
    1be2:	95 e0       	ldi	r25, 0x05	; 5
    1be4:	0e 94 ca 05 	call	0xb94	; 0xb94 <gc_check_same_position>
    1be8:	81 11       	cpse	r24, r1
    1bea:	7e c2       	rjmp	.+1276   	; 0x20e8 <gc_execute_line+0x14d2>
    1bec:	09 c0       	rjmp	.+18     	; 0x1c00 <gc_execute_line+0xfea>
    1bee:	1f a2       	std	Y+39, r1	; 0x27
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
    1bf0:	2a a1       	ldd	r18, Y+34	; 0x22
    1bf2:	21 11       	cpse	r18, r1
    1bf4:	05 c0       	rjmp	.+10     	; 0x1c00 <gc_execute_line+0xfea>
  
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
    1bf6:	3e ed       	ldi	r19, 0xDE	; 222
    1bf8:	63 22       	and	r6, r19
    1bfa:	3c ef       	ldi	r19, 0xFC	; 252
    1bfc:	73 22       	and	r7, r19
    1bfe:	04 c0       	rjmp	.+8      	; 0x1c08 <gc_execute_line+0xff2>
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
    1c00:	8e ed       	ldi	r24, 0xDE	; 222
    1c02:	68 22       	and	r6, r24
    1c04:	80 ee       	ldi	r24, 0xE0	; 224
    1c06:	78 22       	and	r7, r24
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    1c08:	67 28       	or	r6, r7
    1c0a:	09 f0       	breq	.+2      	; 0x1c0e <gc_execute_line+0xff8>
    1c0c:	6f c2       	rjmp	.+1246   	; 0x20ec <gc_execute_line+0x14d6>
     Assumes that all error-checking has been completed and no failure modes exist. We just
     need to update the state and execute the block according to the order-of-execution.
  */ 
  
  // [0. Non-specific/common error-checks and miscellaneous setup]: 
  gc_state.line_number = gc_block.values.n;
    1c0e:	e8 e2       	ldi	r30, 0x28	; 40
    1c10:	f5 e0       	ldi	r31, 0x05	; 5
    1c12:	a7 e6       	ldi	r26, 0x67	; 103
    1c14:	b5 e0       	ldi	r27, 0x05	; 5
    1c16:	5c 96       	adiw	r26, 0x1c	; 28
    1c18:	4d 91       	ld	r20, X+
    1c1a:	5d 91       	ld	r21, X+
    1c1c:	6d 91       	ld	r22, X+
    1c1e:	7c 91       	ld	r23, X
    1c20:	5f 97       	sbiw	r26, 0x1f	; 31
    1c22:	43 8b       	std	Z+19, r20	; 0x13
    1c24:	54 8b       	std	Z+20, r21	; 0x14
    1c26:	65 8b       	std	Z+21, r22	; 0x15
    1c28:	76 8b       	std	Z+22, r23	; 0x16
  
  // [1. Comments feedback ]:  NOT SUPPORTED
  
  // [2. Set feed rate mode ]:
  gc_state.modal.feed_rate = gc_block.modal.feed_rate;
    1c2a:	12 96       	adiw	r26, 0x02	; 2
    1c2c:	8c 91       	ld	r24, X
    1c2e:	12 97       	sbiw	r26, 0x02	; 2
    1c30:	81 83       	std	Z+1, r24	; 0x01
  
  // [3. Set feed rate ]:
  gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
    1c32:	1b 96       	adiw	r26, 0x0b	; 11
    1c34:	4d 91       	ld	r20, X+
    1c36:	5d 91       	ld	r21, X+
    1c38:	6d 91       	ld	r22, X+
    1c3a:	7c 91       	ld	r23, X
    1c3c:	1e 97       	sbiw	r26, 0x0e	; 14
    1c3e:	46 87       	std	Z+14, r20	; 0x0e
    1c40:	57 87       	std	Z+15, r21	; 0x0f
    1c42:	60 8b       	std	Z+16, r22	; 0x10
    1c44:	71 8b       	std	Z+17, r23	; 0x11

  // [4. Set spindle speed ]:
  if (gc_state.spindle_speed != gc_block.values.s) { 
    1c46:	98 96       	adiw	r26, 0x28	; 40
    1c48:	cd 90       	ld	r12, X+
    1c4a:	dd 90       	ld	r13, X+
    1c4c:	ed 90       	ld	r14, X+
    1c4e:	fc 90       	ld	r15, X
    1c50:	9b 97       	sbiw	r26, 0x2b	; 43
    1c52:	a7 01       	movw	r20, r14
    1c54:	96 01       	movw	r18, r12
    1c56:	62 85       	ldd	r22, Z+10	; 0x0a
    1c58:	73 85       	ldd	r23, Z+11	; 0x0b
    1c5a:	84 85       	ldd	r24, Z+12	; 0x0c
    1c5c:	95 85       	ldd	r25, Z+13	; 0x0d
    1c5e:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    1c62:	88 23       	and	r24, r24
    1c64:	c1 f0       	breq	.+48     	; 0x1c96 <gc_execute_line+0x1080>
    // Update running spindle only if not in check mode and not already enabled.
    if (gc_state.modal.spindle != SPINDLE_DISABLE) { spindle_run(gc_state.modal.spindle, gc_block.values.s); }
    1c66:	80 91 31 05 	lds	r24, 0x0531	; 0x800531 <gc_state+0x9>
    1c6a:	88 23       	and	r24, r24
    1c6c:	21 f0       	breq	.+8      	; 0x1c76 <gc_execute_line+0x1060>
    1c6e:	b7 01       	movw	r22, r14
    1c70:	a6 01       	movw	r20, r12
    1c72:	0e 94 23 2c 	call	0x5846	; 0x5846 <spindle_run>
    gc_state.spindle_speed = gc_block.values.s; 
    1c76:	80 91 8f 05 	lds	r24, 0x058F	; 0x80058f <gc_block+0x28>
    1c7a:	90 91 90 05 	lds	r25, 0x0590	; 0x800590 <gc_block+0x29>
    1c7e:	a0 91 91 05 	lds	r26, 0x0591	; 0x800591 <gc_block+0x2a>
    1c82:	b0 91 92 05 	lds	r27, 0x0592	; 0x800592 <gc_block+0x2b>
    1c86:	80 93 32 05 	sts	0x0532, r24	; 0x800532 <gc_state+0xa>
    1c8a:	90 93 33 05 	sts	0x0533, r25	; 0x800533 <gc_state+0xb>
    1c8e:	a0 93 34 05 	sts	0x0534, r26	; 0x800534 <gc_state+0xc>
    1c92:	b0 93 35 05 	sts	0x0535, r27	; 0x800535 <gc_state+0xd>
  }
    
  // [5. Select tool ]: NOT SUPPORTED. Only tracks tool value.
  gc_state.tool = gc_block.values.t;
    1c96:	e8 e2       	ldi	r30, 0x28	; 40
    1c98:	f5 e0       	ldi	r31, 0x05	; 5
    1c9a:	a7 e6       	ldi	r26, 0x67	; 103
    1c9c:	b5 e0       	ldi	r27, 0x05	; 5
    1c9e:	9c 96       	adiw	r26, 0x2c	; 44
    1ca0:	8c 91       	ld	r24, X
    1ca2:	9c 97       	sbiw	r26, 0x2c	; 44
    1ca4:	82 8b       	std	Z+18, r24	; 0x12

  // [6. Change tool ]: NOT SUPPORTED

  // [7. Spindle control ]:
  if (gc_state.modal.spindle != gc_block.modal.spindle) {
    1ca6:	1a 96       	adiw	r26, 0x0a	; 10
    1ca8:	8c 91       	ld	r24, X
    1caa:	91 85       	ldd	r25, Z+9	; 0x09
    1cac:	98 17       	cp	r25, r24
    1cae:	59 f0       	breq	.+22     	; 0x1cc6 <gc_execute_line+0x10b0>
    // Update spindle control and apply spindle speed when enabling it in this block.    
    spindle_run(gc_block.modal.spindle, gc_state.spindle_speed);
    1cb0:	8f 01       	movw	r16, r30
    1cb2:	42 85       	ldd	r20, Z+10	; 0x0a
    1cb4:	53 85       	ldd	r21, Z+11	; 0x0b
    1cb6:	64 85       	ldd	r22, Z+12	; 0x0c
    1cb8:	75 85       	ldd	r23, Z+13	; 0x0d
    1cba:	0e 94 23 2c 	call	0x5846	; 0x5846 <spindle_run>
    gc_state.modal.spindle = gc_block.modal.spindle;    
    1cbe:	80 91 71 05 	lds	r24, 0x0571	; 0x800571 <gc_block+0xa>
    1cc2:	f8 01       	movw	r30, r16
    1cc4:	81 87       	std	Z+9, r24	; 0x09
  }

  // [8. Coolant control ]:  
  if (gc_state.modal.coolant != gc_block.modal.coolant) {
    1cc6:	80 91 70 05 	lds	r24, 0x0570	; 0x800570 <gc_block+0x9>
    1cca:	90 91 30 05 	lds	r25, 0x0530	; 0x800530 <gc_state+0x8>
    1cce:	98 17       	cp	r25, r24
    1cd0:	31 f0       	breq	.+12     	; 0x1cde <gc_execute_line+0x10c8>
    coolant_run(gc_block.modal.coolant);
    1cd2:	0e 94 06 05 	call	0xa0c	; 0xa0c <coolant_run>
    gc_state.modal.coolant = gc_block.modal.coolant;
    1cd6:	80 91 70 05 	lds	r24, 0x0570	; 0x800570 <gc_block+0x9>
    1cda:	80 93 30 05 	sts	0x0530, r24	; 0x800530 <gc_state+0x8>
  }
  
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED

  // [10. Dwell ]:
  if (gc_block.non_modal_command == NON_MODAL_DWELL) { mc_dwell(gc_block.values.p); }
    1cde:	80 91 67 05 	lds	r24, 0x0567	; 0x800567 <gc_block>
    1ce2:	81 30       	cpi	r24, 0x01	; 1
    1ce4:	51 f4       	brne	.+20     	; 0x1cfa <gc_execute_line+0x10e4>
    1ce6:	60 91 87 05 	lds	r22, 0x0587	; 0x800587 <gc_block+0x20>
    1cea:	70 91 88 05 	lds	r23, 0x0588	; 0x800588 <gc_block+0x21>
    1cee:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <gc_block+0x22>
    1cf2:	90 91 8a 05 	lds	r25, 0x058A	; 0x80058a <gc_block+0x23>
    1cf6:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <mc_dwell>
  
  // [11. Set active plane ]:
  gc_state.modal.plane_select = gc_block.modal.plane_select;  
    1cfa:	e8 e2       	ldi	r30, 0x28	; 40
    1cfc:	f5 e0       	ldi	r31, 0x05	; 5
    1cfe:	a7 e6       	ldi	r26, 0x67	; 103
    1d00:	b5 e0       	ldi	r27, 0x05	; 5
    1d02:	15 96       	adiw	r26, 0x05	; 5
    1d04:	8c 91       	ld	r24, X
    1d06:	15 97       	sbiw	r26, 0x05	; 5
    1d08:	84 83       	std	Z+4, r24	; 0x04

  // [12. Set length units ]:
  gc_state.modal.units = gc_block.modal.units;
    1d0a:	13 96       	adiw	r26, 0x03	; 3
    1d0c:	8c 91       	ld	r24, X
    1d0e:	82 83       	std	Z+2, r24	; 0x02

  // [14. Cutter length compensation ]: G43.1 and G49 supported. G43 NOT SUPPORTED.
  // NOTE: If G43 were supported, its operation wouldn't be any different from G43.1 in terms
  // of execution. The error-checking step would simply load the offset value into the correct
  // axis of the block XYZ value array. 
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates a change.
    1d10:	fa a1       	ldd	r31, Y+34	; 0x22
    1d12:	f3 30       	cpi	r31, 0x03	; 3
    1d14:	f9 f4       	brne	.+62     	; 0x1d54 <gc_execute_line+0x113e>
    gc_state.modal.tool_length = gc_block.modal.tool_length;
    1d16:	80 91 6d 05 	lds	r24, 0x056D	; 0x80056d <gc_block+0x6>
    1d1a:	80 93 2d 05 	sts	0x052D, r24	; 0x80052d <gc_state+0x5>
    if (gc_state.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) { // G43.1
    1d1e:	81 30       	cpi	r24, 0x01	; 1
    1d20:	89 f4       	brne	.+34     	; 0x1d44 <gc_execute_line+0x112e>
      gc_state.tool_length_offset = gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS];
    1d22:	80 91 9c 05 	lds	r24, 0x059C	; 0x80059c <gc_block+0x35>
    1d26:	90 91 9d 05 	lds	r25, 0x059D	; 0x80059d <gc_block+0x36>
    1d2a:	a0 91 9e 05 	lds	r26, 0x059E	; 0x80059e <gc_block+0x37>
    1d2e:	b0 91 9f 05 	lds	r27, 0x059F	; 0x80059f <gc_block+0x38>
    1d32:	80 93 63 05 	sts	0x0563, r24	; 0x800563 <gc_state+0x3b>
    1d36:	90 93 64 05 	sts	0x0564, r25	; 0x800564 <gc_state+0x3c>
    1d3a:	a0 93 65 05 	sts	0x0565, r26	; 0x800565 <gc_state+0x3d>
    1d3e:	b0 93 66 05 	sts	0x0566, r27	; 0x800566 <gc_state+0x3e>
    1d42:	08 c0       	rjmp	.+16     	; 0x1d54 <gc_execute_line+0x113e>
    } else { // G49
      gc_state.tool_length_offset = 0.0;
    1d44:	10 92 63 05 	sts	0x0563, r1	; 0x800563 <gc_state+0x3b>
    1d48:	10 92 64 05 	sts	0x0564, r1	; 0x800564 <gc_state+0x3c>
    1d4c:	10 92 65 05 	sts	0x0565, r1	; 0x800565 <gc_state+0x3d>
    1d50:	10 92 66 05 	sts	0x0566, r1	; 0x800566 <gc_state+0x3e>
    }
  }
  
  // [15. Coordinate system selection ]:
  if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    1d54:	80 91 6e 05 	lds	r24, 0x056E	; 0x80056e <gc_block+0x7>
    1d58:	90 91 2e 05 	lds	r25, 0x052E	; 0x80052e <gc_state+0x6>
    1d5c:	98 17       	cp	r25, r24
    1d5e:	59 f0       	breq	.+22     	; 0x1d76 <gc_execute_line+0x1160>
    gc_state.modal.coord_select = gc_block.modal.coord_select;
    1d60:	80 93 2e 05 	sts	0x052E, r24	; 0x80052e <gc_state+0x6>
    memcpy(gc_state.coord_system,coordinate_data,sizeof(coordinate_data));
    1d64:	8c e0       	ldi	r24, 0x0C	; 12
    1d66:	fe 01       	movw	r30, r28
    1d68:	31 96       	adiw	r30, 0x01	; 1
    1d6a:	ab e4       	ldi	r26, 0x4B	; 75
    1d6c:	b5 e0       	ldi	r27, 0x05	; 5
    1d6e:	01 90       	ld	r0, Z+
    1d70:	0d 92       	st	X+, r0
    1d72:	8a 95       	dec	r24
    1d74:	e1 f7       	brne	.-8      	; 0x1d6e <gc_execute_line+0x1158>
  
  // [16. Set path control mode ]: G61.1/G64 NOT SUPPORTED
  // gc_state.modal.control = gc_block.modal.control; // NOTE: Always default.
  
  // [17. Set distance mode ]:
  gc_state.modal.distance = gc_block.modal.distance;
    1d76:	e7 e6       	ldi	r30, 0x67	; 103
    1d78:	f5 e0       	ldi	r31, 0x05	; 5
    1d7a:	84 81       	ldd	r24, Z+4	; 0x04
    1d7c:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <gc_state+0x3>
  
  // [18. Set retract mode ]: NOT SUPPORTED
    
  // [19. Go to predefined position, Set G10, or Set axis offsets ]:
  switch(gc_block.non_modal_command) {
    1d80:	80 81       	ld	r24, Z
    1d82:	90 e0       	ldi	r25, 0x00	; 0
    1d84:	fc 01       	movw	r30, r24
    1d86:	32 97       	sbiw	r30, 0x02	; 2
    1d88:	e8 30       	cpi	r30, 0x08	; 8
    1d8a:	f1 05       	cpc	r31, r1
    1d8c:	08 f0       	brcs	.+2      	; 0x1d90 <gc_execute_line+0x117a>
    1d8e:	55 c0       	rjmp	.+170    	; 0x1e3a <gc_execute_line+0x1224>
    1d90:	e9 53       	subi	r30, 0x39	; 57
    1d92:	ff 4f       	sbci	r31, 0xFF	; 255
    1d94:	0c 94 38 3d 	jmp	0x7a70	; 0x7a70 <__tablejump2__>
    case NON_MODAL_SET_COORDINATE_DATA:    
      settings_write_coord_data(coord_select,parameter_data);
    1d98:	be 01       	movw	r22, r28
    1d9a:	63 5f       	subi	r22, 0xF3	; 243
    1d9c:	7f 4f       	sbci	r23, 0xFF	; 255
    1d9e:	8f a1       	ldd	r24, Y+39	; 0x27
    1da0:	0e 94 fc 28 	call	0x51f8	; 0x51f8 <settings_write_coord_data>
      // Update system coordinate system if currently active.
      if (gc_state.modal.coord_select == coord_select) { memcpy(gc_state.coord_system,parameter_data,sizeof(parameter_data)); }
    1da4:	80 91 2e 05 	lds	r24, 0x052E	; 0x80052e <gc_state+0x6>
    1da8:	2f a1       	ldd	r18, Y+39	; 0x27
    1daa:	82 13       	cpse	r24, r18
    1dac:	46 c0       	rjmp	.+140    	; 0x1e3a <gc_execute_line+0x1224>
    1dae:	8c e0       	ldi	r24, 0x0C	; 12
    1db0:	fe 01       	movw	r30, r28
    1db2:	3d 96       	adiw	r30, 0x0d	; 13
    1db4:	ab e4       	ldi	r26, 0x4B	; 75
    1db6:	b5 e0       	ldi	r27, 0x05	; 5
    1db8:	01 90       	ld	r0, Z+
    1dba:	0d 92       	st	X+, r0
    1dbc:	8a 95       	dec	r24
    1dbe:	e1 f7       	brne	.-8      	; 0x1db8 <gc_execute_line+0x11a2>
    1dc0:	3c c0       	rjmp	.+120    	; 0x1e3a <gc_execute_line+0x1224>
      break;
    case NON_MODAL_GO_HOME_0: case NON_MODAL_GO_HOME_1: 
      // Move to intermediate position before going home. Obeys current coordinate system and offsets 
      // and absolute and incremental modes.
      if (axis_command) {
    1dc2:	3a a1       	ldd	r19, Y+34	; 0x22
    1dc4:	33 23       	and	r19, r19
    1dc6:	49 f0       	breq	.+18     	; 0x1dda <gc_execute_line+0x11c4>
        #ifdef USE_LINE_NUMBERS
          mc_line(gc_block.values.xyz, -1.0, false, gc_state.line_number);
        #else
          mc_line(gc_block.values.xyz, -1.0, false);
    1dc8:	20 e0       	ldi	r18, 0x00	; 0
    1dca:	40 e0       	ldi	r20, 0x00	; 0
    1dcc:	50 e0       	ldi	r21, 0x00	; 0
    1dce:	60 e8       	ldi	r22, 0x80	; 128
    1dd0:	7f eb       	ldi	r23, 0xBF	; 191
    1dd2:	84 e9       	ldi	r24, 0x94	; 148
    1dd4:	95 e0       	ldi	r25, 0x05	; 5
    1dd6:	0e 94 26 14 	call	0x284c	; 0x284c <mc_line>
        #endif
      }
      #ifdef USE_LINE_NUMBERS
        mc_line(parameter_data, -1.0, false, gc_state.line_number); 
      #else
        mc_line(parameter_data, -1.0, false); 
    1dda:	20 e0       	ldi	r18, 0x00	; 0
    1ddc:	40 e0       	ldi	r20, 0x00	; 0
    1dde:	50 e0       	ldi	r21, 0x00	; 0
    1de0:	60 e8       	ldi	r22, 0x80	; 128
    1de2:	7f eb       	ldi	r23, 0xBF	; 191
    1de4:	ce 01       	movw	r24, r28
    1de6:	0d 96       	adiw	r24, 0x0d	; 13
    1de8:	0e 94 26 14 	call	0x284c	; 0x284c <mc_line>
      #endif
      memcpy(gc_state.position, parameter_data, sizeof(parameter_data));
    1dec:	8c e0       	ldi	r24, 0x0C	; 12
    1dee:	fe 01       	movw	r30, r28
    1df0:	3d 96       	adiw	r30, 0x0d	; 13
    1df2:	af e3       	ldi	r26, 0x3F	; 63
    1df4:	b5 e0       	ldi	r27, 0x05	; 5
    1df6:	01 90       	ld	r0, Z+
    1df8:	0d 92       	st	X+, r0
    1dfa:	8a 95       	dec	r24
    1dfc:	e1 f7       	brne	.-8      	; 0x1df6 <gc_execute_line+0x11e0>
      break;
    1dfe:	1d c0       	rjmp	.+58     	; 0x1e3a <gc_execute_line+0x1224>
    case NON_MODAL_SET_HOME_0: 
      settings_write_coord_data(SETTING_INDEX_G28,gc_state.position);
    1e00:	6f e3       	ldi	r22, 0x3F	; 63
    1e02:	75 e0       	ldi	r23, 0x05	; 5
    1e04:	86 e0       	ldi	r24, 0x06	; 6
    1e06:	0e 94 fc 28 	call	0x51f8	; 0x51f8 <settings_write_coord_data>
      break;
    1e0a:	17 c0       	rjmp	.+46     	; 0x1e3a <gc_execute_line+0x1224>
    case NON_MODAL_SET_HOME_1:
      settings_write_coord_data(SETTING_INDEX_G30,gc_state.position);
    1e0c:	6f e3       	ldi	r22, 0x3F	; 63
    1e0e:	75 e0       	ldi	r23, 0x05	; 5
    1e10:	87 e0       	ldi	r24, 0x07	; 7
    1e12:	0e 94 fc 28 	call	0x51f8	; 0x51f8 <settings_write_coord_data>
      break;
    1e16:	11 c0       	rjmp	.+34     	; 0x1e3a <gc_execute_line+0x1224>
    case NON_MODAL_SET_COORDINATE_OFFSET:
      memcpy(gc_state.coord_offset,gc_block.values.xyz,sizeof(gc_block.values.xyz));
    1e18:	8c e0       	ldi	r24, 0x0C	; 12
    1e1a:	e4 e9       	ldi	r30, 0x94	; 148
    1e1c:	f5 e0       	ldi	r31, 0x05	; 5
    1e1e:	a7 e5       	ldi	r26, 0x57	; 87
    1e20:	b5 e0       	ldi	r27, 0x05	; 5
    1e22:	01 90       	ld	r0, Z+
    1e24:	0d 92       	st	X+, r0
    1e26:	8a 95       	dec	r24
    1e28:	e1 f7       	brne	.-8      	; 0x1e22 <gc_execute_line+0x120c>
      break;
    1e2a:	07 c0       	rjmp	.+14     	; 0x1e3a <gc_execute_line+0x1224>
    case NON_MODAL_RESET_COORDINATE_OFFSET: 
      clear_vector(gc_state.coord_offset); // Disable G92 offsets by zeroing offset vector.
    1e2c:	8c e0       	ldi	r24, 0x0C	; 12
    1e2e:	e7 e5       	ldi	r30, 0x57	; 87
    1e30:	f5 e0       	ldi	r31, 0x05	; 5
    1e32:	df 01       	movw	r26, r30
    1e34:	1d 92       	st	X+, r1
    1e36:	8a 95       	dec	r24
    1e38:	e9 f7       	brne	.-6      	; 0x1e34 <gc_execute_line+0x121e>

  
  // [20. Motion modes ]:
  // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes. 
  // Enter motion modes only if there are axis words or a motion mode command word in the block.
  gc_state.modal.motion = gc_block.modal.motion;
    1e3a:	80 91 68 05 	lds	r24, 0x0568	; 0x800568 <gc_block+0x1>
    1e3e:	80 93 28 05 	sts	0x0528, r24	; 0x800528 <gc_state>
  if (gc_state.modal.motion != MOTION_MODE_NONE) {
    1e42:	88 30       	cpi	r24, 0x08	; 8
    1e44:	09 f4       	brne	.+2      	; 0x1e48 <gc_execute_line+0x1232>
    1e46:	a9 c0       	rjmp	.+338    	; 0x1f9a <gc_execute_line+0x1384>
    if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    1e48:	ba a1       	ldd	r27, Y+34	; 0x22
    1e4a:	b2 30       	cpi	r27, 0x02	; 2
    1e4c:	09 f0       	breq	.+2      	; 0x1e50 <gc_execute_line+0x123a>
    1e4e:	a5 c0       	rjmp	.+330    	; 0x1f9a <gc_execute_line+0x1384>
      switch (gc_state.modal.motion) {
    1e50:	90 e0       	ldi	r25, 0x00	; 0
    1e52:	88 30       	cpi	r24, 0x08	; 8
    1e54:	91 05       	cpc	r25, r1
    1e56:	08 f0       	brcs	.+2      	; 0x1e5a <gc_execute_line+0x1244>
    1e58:	97 c0       	rjmp	.+302    	; 0x1f88 <gc_execute_line+0x1372>
    1e5a:	fc 01       	movw	r30, r24
    1e5c:	e1 53       	subi	r30, 0x31	; 49
    1e5e:	ff 4f       	sbci	r31, 0xFF	; 255
    1e60:	0c 94 38 3d 	jmp	0x7a70	; 0x7a70 <__tablejump2__>
        case MOTION_MODE_SEEK:
          #ifdef USE_LINE_NUMBERS
            mc_line(gc_block.values.xyz, -1.0, false, gc_state.line_number);
          #else
            mc_line(gc_block.values.xyz, -1.0, false);
    1e64:	20 e0       	ldi	r18, 0x00	; 0
    1e66:	40 e0       	ldi	r20, 0x00	; 0
    1e68:	50 e0       	ldi	r21, 0x00	; 0
    1e6a:	60 e8       	ldi	r22, 0x80	; 128
    1e6c:	7f eb       	ldi	r23, 0xBF	; 191
    1e6e:	84 e9       	ldi	r24, 0x94	; 148
    1e70:	95 e0       	ldi	r25, 0x05	; 5
    1e72:	0e 94 26 14 	call	0x284c	; 0x284c <mc_line>
          #endif
          break;
    1e76:	88 c0       	rjmp	.+272    	; 0x1f88 <gc_execute_line+0x1372>
        case MOTION_MODE_LINEAR:
          #ifdef USE_LINE_NUMBERS
            mc_line(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, gc_state.line_number);
          #else
            mc_line(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate);
    1e78:	e8 e2       	ldi	r30, 0x28	; 40
    1e7a:	f5 e0       	ldi	r31, 0x05	; 5
    1e7c:	46 85       	ldd	r20, Z+14	; 0x0e
    1e7e:	57 85       	ldd	r21, Z+15	; 0x0f
    1e80:	60 89       	ldd	r22, Z+16	; 0x10
    1e82:	71 89       	ldd	r23, Z+17	; 0x11
    1e84:	21 81       	ldd	r18, Z+1	; 0x01
    1e86:	84 e9       	ldi	r24, 0x94	; 148
    1e88:	95 e0       	ldi	r25, 0x05	; 5
    1e8a:	0e 94 26 14 	call	0x284c	; 0x284c <mc_line>
          #endif
          break;
    1e8e:	7c c0       	rjmp	.+248    	; 0x1f88 <gc_execute_line+0x1372>
        case MOTION_MODE_CW_ARC: 
          #ifdef USE_LINE_NUMBERS
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, true, gc_state.line_number);  
          #else
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
    1e90:	e8 e2       	ldi	r30, 0x28	; 40
    1e92:	f5 e0       	ldi	r31, 0x05	; 5
    1e94:	c6 84       	ldd	r12, Z+14	; 0x0e
    1e96:	d7 84       	ldd	r13, Z+15	; 0x0f
    1e98:	e0 88       	ldd	r14, Z+16	; 0x10
    1e9a:	f1 88       	ldd	r15, Z+17	; 0x11
    1e9c:	00 91 8b 05 	lds	r16, 0x058B	; 0x80058b <gc_block+0x24>
    1ea0:	10 91 8c 05 	lds	r17, 0x058C	; 0x80058c <gc_block+0x25>
    1ea4:	20 91 8d 05 	lds	r18, 0x058D	; 0x80058d <gc_block+0x26>
    1ea8:	30 91 8e 05 	lds	r19, 0x058E	; 0x80058e <gc_block+0x27>
    1eac:	81 e0       	ldi	r24, 0x01	; 1
    1eae:	8f 93       	push	r24
    1eb0:	8e a1       	ldd	r24, Y+38	; 0x26
    1eb2:	8f 93       	push	r24
    1eb4:	9d a1       	ldd	r25, Y+37	; 0x25
    1eb6:	9f 93       	push	r25
    1eb8:	8c a0       	ldd	r8, Y+36	; 0x24
    1eba:	a1 80       	ldd	r10, Z+1	; 0x01
    1ebc:	46 e7       	ldi	r20, 0x76	; 118
    1ebe:	55 e0       	ldi	r21, 0x05	; 5
    1ec0:	64 e9       	ldi	r22, 0x94	; 148
    1ec2:	75 e0       	ldi	r23, 0x05	; 5
    1ec4:	8f e3       	ldi	r24, 0x3F	; 63
    1ec6:	95 e0       	ldi	r25, 0x05	; 5
    1ec8:	0e 94 5c 14 	call	0x28b8	; 0x28b8 <mc_arc>
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, true); 
          #endif
          break;        
    1ecc:	0f 90       	pop	r0
    1ece:	0f 90       	pop	r0
    1ed0:	0f 90       	pop	r0
    1ed2:	5a c0       	rjmp	.+180    	; 0x1f88 <gc_execute_line+0x1372>
        case MOTION_MODE_CCW_ARC:
          #ifdef USE_LINE_NUMBERS
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, false, gc_state.line_number);  
          #else
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
    1ed4:	e8 e2       	ldi	r30, 0x28	; 40
    1ed6:	f5 e0       	ldi	r31, 0x05	; 5
    1ed8:	c6 84       	ldd	r12, Z+14	; 0x0e
    1eda:	d7 84       	ldd	r13, Z+15	; 0x0f
    1edc:	e0 88       	ldd	r14, Z+16	; 0x10
    1ede:	f1 88       	ldd	r15, Z+17	; 0x11
    1ee0:	00 91 8b 05 	lds	r16, 0x058B	; 0x80058b <gc_block+0x24>
    1ee4:	10 91 8c 05 	lds	r17, 0x058C	; 0x80058c <gc_block+0x25>
    1ee8:	20 91 8d 05 	lds	r18, 0x058D	; 0x80058d <gc_block+0x26>
    1eec:	30 91 8e 05 	lds	r19, 0x058E	; 0x80058e <gc_block+0x27>
    1ef0:	1f 92       	push	r1
    1ef2:	ae a1       	ldd	r26, Y+38	; 0x26
    1ef4:	af 93       	push	r26
    1ef6:	bd a1       	ldd	r27, Y+37	; 0x25
    1ef8:	bf 93       	push	r27
    1efa:	8c a0       	ldd	r8, Y+36	; 0x24
    1efc:	a1 80       	ldd	r10, Z+1	; 0x01
    1efe:	46 e7       	ldi	r20, 0x76	; 118
    1f00:	55 e0       	ldi	r21, 0x05	; 5
    1f02:	64 e9       	ldi	r22, 0x94	; 148
    1f04:	75 e0       	ldi	r23, 0x05	; 5
    1f06:	8f e3       	ldi	r24, 0x3F	; 63
    1f08:	95 e0       	ldi	r25, 0x05	; 5
    1f0a:	0e 94 5c 14 	call	0x28b8	; 0x28b8 <mc_arc>
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, false); 
          #endif
          break;
    1f0e:	0f 90       	pop	r0
    1f10:	0f 90       	pop	r0
    1f12:	0f 90       	pop	r0
    1f14:	39 c0       	rjmp	.+114    	; 0x1f88 <gc_execute_line+0x1372>
          // NOTE: gc_block.values.xyz is returned from mc_probe_cycle with the updated position value. So
          // upon a successful probing cycle, the machine position and the returned value should be the same.
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, false, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, false);
    1f16:	e8 e2       	ldi	r30, 0x28	; 40
    1f18:	f5 e0       	ldi	r31, 0x05	; 5
    1f1a:	46 85       	ldd	r20, Z+14	; 0x0e
    1f1c:	57 85       	ldd	r21, Z+15	; 0x0f
    1f1e:	60 89       	ldd	r22, Z+16	; 0x10
    1f20:	71 89       	ldd	r23, Z+17	; 0x11
    1f22:	e1 2c       	mov	r14, r1
    1f24:	00 e0       	ldi	r16, 0x00	; 0
    1f26:	21 81       	ldd	r18, Z+1	; 0x01
    1f28:	84 e9       	ldi	r24, 0x94	; 148
    1f2a:	95 e0       	ldi	r25, 0x05	; 5
    1f2c:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <mc_probe_cycle>
          #endif
          break;
    1f30:	2b c0       	rjmp	.+86     	; 0x1f88 <gc_execute_line+0x1372>
        case MOTION_MODE_PROBE_TOWARD_NO_ERROR:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, true, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, true);
    1f32:	e8 e2       	ldi	r30, 0x28	; 40
    1f34:	f5 e0       	ldi	r31, 0x05	; 5
    1f36:	46 85       	ldd	r20, Z+14	; 0x0e
    1f38:	57 85       	ldd	r21, Z+15	; 0x0f
    1f3a:	60 89       	ldd	r22, Z+16	; 0x10
    1f3c:	71 89       	ldd	r23, Z+17	; 0x11
    1f3e:	ee 24       	eor	r14, r14
    1f40:	e3 94       	inc	r14
    1f42:	00 e0       	ldi	r16, 0x00	; 0
    1f44:	21 81       	ldd	r18, Z+1	; 0x01
    1f46:	84 e9       	ldi	r24, 0x94	; 148
    1f48:	95 e0       	ldi	r25, 0x05	; 5
    1f4a:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <mc_probe_cycle>
          #endif
          break;
    1f4e:	1c c0       	rjmp	.+56     	; 0x1f88 <gc_execute_line+0x1372>
        case MOTION_MODE_PROBE_AWAY:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, false, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, false);
    1f50:	e8 e2       	ldi	r30, 0x28	; 40
    1f52:	f5 e0       	ldi	r31, 0x05	; 5
    1f54:	46 85       	ldd	r20, Z+14	; 0x0e
    1f56:	57 85       	ldd	r21, Z+15	; 0x0f
    1f58:	60 89       	ldd	r22, Z+16	; 0x10
    1f5a:	71 89       	ldd	r23, Z+17	; 0x11
    1f5c:	e1 2c       	mov	r14, r1
    1f5e:	01 e0       	ldi	r16, 0x01	; 1
    1f60:	21 81       	ldd	r18, Z+1	; 0x01
    1f62:	84 e9       	ldi	r24, 0x94	; 148
    1f64:	95 e0       	ldi	r25, 0x05	; 5
    1f66:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <mc_probe_cycle>
          #endif
          break;
    1f6a:	0e c0       	rjmp	.+28     	; 0x1f88 <gc_execute_line+0x1372>
        case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, true, gc_state.line_number);
          #else        
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, true);
    1f6c:	e8 e2       	ldi	r30, 0x28	; 40
    1f6e:	f5 e0       	ldi	r31, 0x05	; 5
    1f70:	46 85       	ldd	r20, Z+14	; 0x0e
    1f72:	57 85       	ldd	r21, Z+15	; 0x0f
    1f74:	60 89       	ldd	r22, Z+16	; 0x10
    1f76:	71 89       	ldd	r23, Z+17	; 0x11
    1f78:	ee 24       	eor	r14, r14
    1f7a:	e3 94       	inc	r14
    1f7c:	01 e0       	ldi	r16, 0x01	; 1
    1f7e:	21 81       	ldd	r18, Z+1	; 0x01
    1f80:	84 e9       	ldi	r24, 0x94	; 148
    1f82:	95 e0       	ldi	r25, 0x05	; 5
    1f84:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <mc_probe_cycle>
      }
    
      // As far as the parser is concerned, the position is now == target. In reality the
      // motion control system might still be processing the action and the real tool position
      // in any intermediate location.
      memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); // gc_state.position[] = gc_block.values.xyz[]
    1f88:	8c e0       	ldi	r24, 0x0C	; 12
    1f8a:	e4 e9       	ldi	r30, 0x94	; 148
    1f8c:	f5 e0       	ldi	r31, 0x05	; 5
    1f8e:	af e3       	ldi	r26, 0x3F	; 63
    1f90:	b5 e0       	ldi	r27, 0x05	; 5
    1f92:	01 90       	ld	r0, Z+
    1f94:	0d 92       	st	X+, r0
    1f96:	8a 95       	dec	r24
    1f98:	e1 f7       	brne	.-8      	; 0x1f92 <gc_execute_line+0x137c>
  }
  
  // [21. Program flow ]:
  // M0,M1,M2,M30: Perform non-running program flow actions. During a program pause, the buffer may 
  // refill and can only be resumed by the cycle start run-time command.
  gc_state.modal.program_flow = gc_block.modal.program_flow;
    1f9a:	80 91 6f 05 	lds	r24, 0x056F	; 0x80056f <gc_block+0x8>
    1f9e:	80 93 2f 05 	sts	0x052F, r24	; 0x80052f <gc_state+0x7>
  if (gc_state.modal.program_flow) { 
    1fa2:	88 23       	and	r24, r24
    1fa4:	09 f4       	brne	.+2      	; 0x1fa8 <gc_execute_line+0x1392>
    1fa6:	0e c1       	rjmp	.+540    	; 0x21c4 <gc_execute_line+0x15ae>
	protocol_buffer_synchronize(); // Sync and finish all remaining buffered motions before moving on.
    1fa8:	0e 94 2a 22 	call	0x4454	; 0x4454 <protocol_buffer_synchronize>
	if (gc_state.modal.program_flow == PROGRAM_FLOW_PAUSED) {
    1fac:	80 91 2f 05 	lds	r24, 0x052F	; 0x80052f <gc_state+0x7>
    1fb0:	81 30       	cpi	r24, 0x01	; 1
    1fb2:	79 f4       	brne	.+30     	; 0x1fd2 <gc_execute_line+0x13bc>
	  if (sys.state != STATE_CHECK_MODE) {
    1fb4:	80 91 a1 05 	lds	r24, 0x05A1	; 0x8005a1 <sys+0x1>
    1fb8:	82 30       	cpi	r24, 0x02	; 2
    1fba:	91 f1       	breq	.+100    	; 0x2020 <gc_execute_line+0x140a>
		bit_true_atomic(sys_rt_exec_state, EXEC_FEED_HOLD); // Use feed hold for program pause.
    1fbc:	9f b7       	in	r25, 0x3f	; 63
    1fbe:	f8 94       	cli
    1fc0:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    1fc4:	88 60       	ori	r24, 0x08	; 8
    1fc6:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <sys_rt_exec_state>
    1fca:	9f bf       	out	0x3f, r25	; 63
		protocol_execute_realtime(); // Execute suspend.
    1fcc:	0e 94 46 20 	call	0x408c	; 0x408c <protocol_execute_realtime>
    1fd0:	27 c0       	rjmp	.+78     	; 0x2020 <gc_execute_line+0x140a>
	} else { // == PROGRAM_FLOW_COMPLETED
	  // Upon program complete, only a subset of g-codes reset to certain defaults, according to 
	  // LinuxCNC's program end descriptions and testing. Only modal groups [G-code 1,2,3,5,7,12]
	  // and [M-code 7,8,9] reset to [G1,G17,G90,G94,G40,G54,M5,M9,M48]. The remaining modal groups
	  // [G-code 4,6,8,10,13,14,15] and [M-code 4,5,6] and the modal words [F,S,T,H] do not reset.
	  gc_state.modal.motion = MOTION_MODE_LINEAR;
    1fd2:	e8 e2       	ldi	r30, 0x28	; 40
    1fd4:	f5 e0       	ldi	r31, 0x05	; 5
    1fd6:	81 e0       	ldi	r24, 0x01	; 1
    1fd8:	80 83       	st	Z, r24
	  gc_state.modal.plane_select = PLANE_SELECT_XY;
    1fda:	14 82       	std	Z+4, r1	; 0x04
	  gc_state.modal.distance = DISTANCE_MODE_ABSOLUTE;
    1fdc:	13 82       	std	Z+3, r1	; 0x03
	  gc_state.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
    1fde:	11 82       	std	Z+1, r1	; 0x01
	  // gc_state.modal.cutter_comp = CUTTER_COMP_DISABLE; // Not supported.
	  gc_state.modal.coord_select = 0; // G54
    1fe0:	16 82       	std	Z+6, r1	; 0x06
	  gc_state.modal.spindle = SPINDLE_DISABLE;
    1fe2:	11 86       	std	Z+9, r1	; 0x09
	  gc_state.modal.coolant = COOLANT_DISABLE;
    1fe4:	10 86       	std	Z+8, r1	; 0x08
	  // gc_state.modal.override = OVERRIDE_DISABLE; // Not supported.
	  
	  // Execute coordinate change and spindle/coolant stop.
	  if (sys.state != STATE_CHECK_MODE) {
    1fe6:	80 91 a1 05 	lds	r24, 0x05A1	; 0x8005a1 <sys+0x1>
    1fea:	82 30       	cpi	r24, 0x02	; 2
    1fec:	b1 f0       	breq	.+44     	; 0x201a <gc_execute_line+0x1404>
		if (!(settings_read_coord_data(gc_state.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
    1fee:	be 01       	movw	r22, r28
    1ff0:	6f 5f       	subi	r22, 0xFF	; 255
    1ff2:	7f 4f       	sbci	r23, 0xFF	; 255
    1ff4:	80 e0       	ldi	r24, 0x00	; 0
    1ff6:	0e 94 0a 2a 	call	0x5414	; 0x5414 <settings_read_coord_data>
    1ffa:	88 23       	and	r24, r24
    1ffc:	09 f4       	brne	.+2      	; 0x2000 <gc_execute_line+0x13ea>
    1ffe:	78 c0       	rjmp	.+240    	; 0x20f0 <gc_execute_line+0x14da>
		memcpy(gc_state.coord_system,coordinate_data,sizeof(coordinate_data));
    2000:	8c e0       	ldi	r24, 0x0C	; 12
    2002:	fe 01       	movw	r30, r28
    2004:	31 96       	adiw	r30, 0x01	; 1
    2006:	ab e4       	ldi	r26, 0x4B	; 75
    2008:	b5 e0       	ldi	r27, 0x05	; 5
    200a:	01 90       	ld	r0, Z+
    200c:	0d 92       	st	X+, r0
    200e:	8a 95       	dec	r24
    2010:	e1 f7       	brne	.-8      	; 0x200a <gc_execute_line+0x13f4>
		spindle_stop();
    2012:	0e 94 bb 2b 	call	0x5776	; 0x5776 <spindle_stop>
		coolant_stop();		
    2016:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <coolant_stop>
	  }
	  
	  report_feedback_message(MESSAGE_PROGRAM_END);
    201a:	87 e0       	ldi	r24, 0x07	; 7
    201c:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <report_feedback_message>
	}
    gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; // Reset program flow.
    2020:	10 92 2f 05 	sts	0x052F, r1	; 0x80052f <gc_state+0x7>
  }
    
  // TODO: % to denote start of program.
  return(STATUS_OK);
    2024:	80 e0       	ldi	r24, 0x00	; 0
    2026:	ce c0       	rjmp	.+412    	; 0x21c4 <gc_execute_line+0x15ae>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    
    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
    2028:	81 e0       	ldi	r24, 0x01	; 1
    202a:	cc c0       	rjmp	.+408    	; 0x21c4 <gc_execute_line+0x15ae>
    char_counter++;
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
    202c:	82 e0       	ldi	r24, 0x02	; 2
    202e:	ca c0       	rjmp	.+404    	; 0x21c4 <gc_execute_line+0x15ae>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
    2030:	84 e1       	ldi	r24, 0x14	; 20
    2032:	c8 c0       	rjmp	.+400    	; 0x21c4 <gc_execute_line+0x15ae>
        switch(int_value) {
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    2034:	88 e1       	ldi	r24, 0x18	; 24
    2036:	c6 c0       	rjmp	.+396    	; 0x21c4 <gc_execute_line+0x15ae>
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G28.x command]
    2038:	84 e1       	ldi	r24, 0x14	; 20
    203a:	c4 c0       	rjmp	.+392    	; 0x21c4 <gc_execute_line+0x15ae>
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
    203c:	84 e1       	ldi	r24, 0x14	; 20
    203e:	c2 c0       	rjmp	.+388    	; 0x21c4 <gc_execute_line+0x15ae>
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G92.x command]
    2040:	84 e1       	ldi	r24, 0x14	; 20
    2042:	c0 c0       	rjmp	.+384    	; 0x21c4 <gc_execute_line+0x15ae>
            }
            break;
          case 0: case 1: case 2: case 3: case 38: 
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    2044:	88 e1       	ldi	r24, 0x18	; 24
    2046:	be c0       	rjmp	.+380    	; 0x21c4 <gc_execute_line+0x15ae>
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
    2048:	84 e1       	ldi	r24, 0x14	; 20
    204a:	bc c0       	rjmp	.+376    	; 0x21c4 <gc_execute_line+0x15ae>
              word_bit = MODAL_GROUP_G3; 
              if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
              else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
    204c:	84 e1       	ldi	r24, 0x14	; 20
    204e:	ba c0       	rjmp	.+372    	; 0x21c4 <gc_execute_line+0x15ae>
    2050:	84 e1       	ldi	r24, 0x14	; 20
    2052:	b8 c0       	rjmp	.+368    	; 0x21c4 <gc_execute_line+0x15ae>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    2054:	88 e1       	ldi	r24, 0x18	; 24
    2056:	b6 c0       	rjmp	.+364    	; 0x21c4 <gc_execute_line+0x15ae>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
            } else if (mantissa == 10) { // G43.1
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
    2058:	84 e1       	ldi	r24, 0x14	; 20
    205a:	b4 c0       	rjmp	.+360    	; 0x21c4 <gc_execute_line+0x15ae>
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
    205c:	84 e1       	ldi	r24, 0x14	; 20
    205e:	b2 c0       	rjmp	.+356    	; 0x21c4 <gc_execute_line+0x15ae>
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    2060:	87 e1       	ldi	r24, 0x17	; 23
    2062:	b0 c0       	rjmp	.+352    	; 0x21c4 <gc_execute_line+0x15ae>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    2064:	85 e1       	ldi	r24, 0x15	; 21
    2066:	ae c0       	rjmp	.+348    	; 0x21c4 <gc_execute_line+0x15ae>
        break;
        
      case 'M':
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    2068:	87 e1       	ldi	r24, 0x17	; 23
    206a:	ac c0       	rjmp	.+344    	; 0x21c4 <gc_execute_line+0x15ae>
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
            }
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
    206c:	84 e1       	ldi	r24, 0x14	; 20
    206e:	aa c0       	rjmp	.+340    	; 0x21c4 <gc_execute_line+0x15ae>
        }
      
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    2070:	85 e1       	ldi	r24, 0x15	; 21
    2072:	a8 c0       	rjmp	.+336    	; 0x21c4 <gc_execute_line+0x15ae>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
    2074:	84 e1       	ldi	r24, 0x14	; 20
    2076:	a6 c0       	rjmp	.+332    	; 0x21c4 <gc_execute_line+0x15ae>
        } 
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    2078:	89 e1       	ldi	r24, 0x19	; 25
    207a:	a4 c0       	rjmp	.+328    	; 0x21c4 <gc_execute_line+0x15ae>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    207c:	84 e0       	ldi	r24, 0x04	; 4
    207e:	a2 c0       	rjmp	.+324    	; 0x21c4 <gc_execute_line+0x15ae>
  }
  
  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    2080:	8b e1       	ldi	r24, 0x1B	; 27
    2082:	a0 c0       	rjmp	.+320    	; 0x21c4 <gc_execute_line+0x15ae>
  //   is not defined after switching to G94 from G93.
  if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
    if (axis_command == AXIS_COMMAND_MOTION_MODE) { 
      if ((gc_block.modal.motion != MOTION_MODE_NONE) || (gc_block.modal.motion != MOTION_MODE_SEEK)) {
        if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    2084:	86 e1       	ldi	r24, 0x16	; 22
    2086:	9e c0       	rjmp	.+316    	; 0x21c4 <gc_execute_line+0x15ae>
  // [8. Coolant control ]: N/A
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED.
  
  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    2088:	8c e1       	ldi	r24, 0x1C	; 28
    208a:	9c c0       	rjmp	.+312    	; 0x21c4 <gc_execute_line+0x15ae>
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid 
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    208c:	85 e2       	ldi	r24, 0x25	; 37
    208e:	9a c0       	rjmp	.+308    	; 0x21c4 <gc_execute_line+0x15ae>
  // is active. The read pauses the processor temporarily and may cause a rare crash. For 
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  memcpy(coordinate_data,gc_state.coord_system,sizeof(gc_state.coord_system));
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    2090:	8d e1       	ldi	r24, 0x1D	; 29
    2092:	98 c0       	rjmp	.+304    	; 0x21c4 <gc_execute_line+0x15ae>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
      if (!(settings_read_coord_data(gc_block.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
    2094:	87 e0       	ldi	r24, 0x07	; 7
    2096:	96 c0       	rjmp	.+300    	; 0x21c4 <gc_execute_line+0x15ae>
  switch (gc_block.non_modal_command) {
    case NON_MODAL_SET_COORDINATE_DATA:  
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    2098:	8a e1       	ldi	r24, 0x1A	; 26
    209a:	94 c0       	rjmp	.+296    	; 0x21c4 <gc_execute_line+0x15ae>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    209c:	8c e1       	ldi	r24, 0x1C	; 28
    209e:	92 c0       	rjmp	.+292    	; 0x21c4 <gc_execute_line+0x15ae>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    20a0:	8d e1       	ldi	r24, 0x1D	; 29
    20a2:	90 c0       	rjmp	.+288    	; 0x21c4 <gc_execute_line+0x15ae>
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
    20a4:	84 e1       	ldi	r24, 0x14	; 20
    20a6:	8e c0       	rjmp	.+284    	; 0x21c4 <gc_execute_line+0x15ae>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    20a8:	84 e1       	ldi	r24, 0x14	; 20
    20aa:	8c c0       	rjmp	.+280    	; 0x21c4 <gc_execute_line+0x15ae>
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
      
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    20ac:	87 e0       	ldi	r24, 0x07	; 7
    20ae:	8a c0       	rjmp	.+276    	; 0x21c4 <gc_execute_line+0x15ae>
        }
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    20b0:	8a e1       	ldi	r24, 0x1A	; 26
    20b2:	88 c0       	rjmp	.+272    	; 0x21c4 <gc_execute_line+0x15ae>
      switch (gc_block.non_modal_command) {        
        case NON_MODAL_GO_HOME_0: 
          // [G28 Errors]: Cutter compensation is enabled. 
          // Retreive G28 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
          if (!settings_read_coord_data(SETTING_INDEX_G28,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    20b4:	87 e0       	ldi	r24, 0x07	; 7
    20b6:	86 c0       	rjmp	.+268    	; 0x21c4 <gc_execute_line+0x15ae>
          break;
        case NON_MODAL_GO_HOME_1:
          // [G30 Errors]: Cutter compensation is enabled. 
          // Retreive G30 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
          if (!settings_read_coord_data(SETTING_INDEX_G30,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    20b8:	87 e0       	ldi	r24, 0x07	; 7
    20ba:	84 c0       	rjmp	.+264    	; 0x21c4 <gc_execute_line+0x15ae>
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
            FAIL(STATUS_GCODE_G53_INVALID_MOTION_MODE); // [G53 G0/1 not active]
    20bc:	8e e1       	ldi	r24, 0x1E	; 30
    20be:	82 c0       	rjmp	.+260    	; 0x21c4 <gc_execute_line+0x15ae>
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word exist and are not used by a non-modal command.
    if ((axis_words) && (axis_command != AXIS_COMMAND_NON_MODAL)) { 
      FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); // [No axis words allowed]
    20c0:	8f e1       	ldi	r24, 0x1F	; 31
    20c2:	80 c0       	rjmp	.+256    	; 0x21c4 <gc_execute_line+0x15ae>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {      
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    20c4:	86 e1       	ldi	r24, 0x16	; 22
    20c6:	7e c0       	rjmp	.+252    	; 0x21c4 <gc_execute_line+0x15ae>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current 
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).   
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.        
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.
        
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    20c8:	8a e1       	ldi	r24, 0x1A	; 26
    20ca:	7c c0       	rjmp	.+248    	; 0x21c4 <gc_execute_line+0x15ae>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    20cc:	80 e2       	ldi	r24, 0x20	; 32
    20ce:	7a c0       	rjmp	.+244    	; 0x21c4 <gc_execute_line+0x15ae>
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target

          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
            bit_false(value_words,bit(WORD_R));
            if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    20d0:	81 e2       	ldi	r24, 0x21	; 33
    20d2:	78 c0       	rjmp	.+240    	; 0x21c4 <gc_execute_line+0x15ae>

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    20d4:	82 e2       	ldi	r24, 0x22	; 34
    20d6:	76 c0       	rjmp	.+236    	; 0x21c4 <gc_execute_line+0x15ae>
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
          
          } else { // Arc Center Format Offset Mode  
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    20d8:	83 e2       	ldi	r24, 0x23	; 35
    20da:	74 c0       	rjmp	.+232    	; 0x21c4 <gc_execute_line+0x15ae>
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]); 
            
            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
            if (delta_r > 0.005) { 
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    20dc:	81 e2       	ldi	r24, 0x21	; 33
    20de:	72 c0       	rjmp	.+228    	; 0x21c4 <gc_execute_line+0x15ae>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    20e0:	81 e2       	ldi	r24, 0x21	; 33
    20e2:	70 c0       	rjmp	.+224    	; 0x21c4 <gc_execute_line+0x15ae>
        case MOTION_MODE_PROBE_AWAY: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to 
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    20e4:	8a e1       	ldi	r24, 0x1A	; 26
    20e6:	6e c0       	rjmp	.+220    	; 0x21c4 <gc_execute_line+0x15ae>
          if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    20e8:	81 e2       	ldi	r24, 0x21	; 33
    20ea:	6c c0       	rjmp	.+216    	; 0x21c4 <gc_execute_line+0x15ae>

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    20ec:	84 e2       	ldi	r24, 0x24	; 36
    20ee:	6a c0       	rjmp	.+212    	; 0x21c4 <gc_execute_line+0x15ae>
	  gc_state.modal.coolant = COOLANT_DISABLE;
	  // gc_state.modal.override = OVERRIDE_DISABLE; // Not supported.
	  
	  // Execute coordinate change and spindle/coolant stop.
	  if (sys.state != STATE_CHECK_MODE) {
		if (!(settings_read_coord_data(gc_state.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
    20f0:	87 e0       	ldi	r24, 0x07	; 7
    20f2:	68 c0       	rjmp	.+208    	; 0x21c4 <gc_execute_line+0x15ae>
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    20f4:	87 e1       	ldi	r24, 0x17	; 23
    20f6:	66 c0       	rjmp	.+204    	; 0x21c4 <gc_execute_line+0x15ae>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
    20f8:	0c 31       	cpi	r16, 0x1C	; 28
    20fa:	11 f4       	brne	.+4      	; 0x2100 <gc_execute_line+0x14ea>
    20fc:	0c 94 bc 06 	jmp	0xd78	; 0xd78 <gc_execute_line+0x162>
    2100:	50 f4       	brcc	.+20     	; 0x2116 <gc_execute_line+0x1500>
    2102:	04 30       	cpi	r16, 0x04	; 4
    2104:	11 f4       	brne	.+4      	; 0x210a <gc_execute_line+0x14f4>
    2106:	0c 94 ac 06 	jmp	0xd58	; 0xd58 <gc_execute_line+0x142>
    210a:	0a 30       	cpi	r16, 0x0A	; 10
    210c:	11 f0       	breq	.+4      	; 0x2112 <gc_execute_line+0x14fc>
    210e:	0c 94 ca 07 	jmp	0xf94	; 0xf94 <gc_execute_line+0x37e>
    2112:	0c 94 b4 06 	jmp	0xd68	; 0xd68 <gc_execute_line+0x152>
    2116:	05 33       	cpi	r16, 0x35	; 53
    2118:	11 f4       	brne	.+4      	; 0x211e <gc_execute_line+0x1508>
    211a:	0c 94 e8 06 	jmp	0xdd0	; 0xdd0 <gc_execute_line+0x1ba>
    211e:	0c 35       	cpi	r16, 0x5C	; 92
    2120:	11 f4       	brne	.+4      	; 0x2126 <gc_execute_line+0x1510>
    2122:	0c 94 f0 06 	jmp	0xde0	; 0xde0 <gc_execute_line+0x1ca>
    2126:	0e 31       	cpi	r16, 0x1E	; 30
    2128:	11 f0       	breq	.+4      	; 0x212e <gc_execute_line+0x1518>
    212a:	0c 94 ca 07 	jmp	0xf94	; 0xf94 <gc_execute_line+0x37e>
    212e:	0c 94 d2 06 	jmp	0xda4	; 0xda4 <gc_execute_line+0x18e>
    2132:	0c 31       	cpi	r16, 0x1C	; 28
    2134:	11 f4       	brne	.+4      	; 0x213a <gc_execute_line+0x1524>
    2136:	0c 94 be 06 	jmp	0xd7c	; 0xd7c <gc_execute_line+0x166>
    213a:	48 f4       	brcc	.+18     	; 0x214e <gc_execute_line+0x1538>
    213c:	04 30       	cpi	r16, 0x04	; 4
    213e:	11 f4       	brne	.+4      	; 0x2144 <gc_execute_line+0x152e>
    2140:	0c 94 ae 06 	jmp	0xd5c	; 0xd5c <gc_execute_line+0x146>
    2144:	0a 30       	cpi	r16, 0x0A	; 10
    2146:	11 f4       	brne	.+4      	; 0x214c <gc_execute_line+0x1536>
    2148:	0c 94 b6 06 	jmp	0xd6c	; 0xd6c <gc_execute_line+0x156>
    214c:	d3 cf       	rjmp	.-90     	; 0x20f4 <gc_execute_line+0x14de>
    214e:	05 33       	cpi	r16, 0x35	; 53
    2150:	11 f4       	brne	.+4      	; 0x2156 <gc_execute_line+0x1540>
    2152:	0c 94 ea 06 	jmp	0xdd4	; 0xdd4 <gc_execute_line+0x1be>
    2156:	0c 35       	cpi	r16, 0x5C	; 92
    2158:	11 f4       	brne	.+4      	; 0x215e <gc_execute_line+0x1548>
    215a:	0c 94 f2 06 	jmp	0xde4	; 0xde4 <gc_execute_line+0x1ce>
    215e:	0e 31       	cpi	r16, 0x1E	; 30
    2160:	49 f6       	brne	.-110    	; 0x20f4 <gc_execute_line+0x14de>
    2162:	0c 94 d4 06 	jmp	0xda8	; 0xda8 <gc_execute_line+0x192>
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
    2166:	e1 e0       	ldi	r30, 0x01	; 1
    2168:	ee a3       	std	Y+38, r30	; 0x26
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
    216a:	1d a2       	std	Y+37, r1	; 0x25
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
    216c:	f2 e0       	ldi	r31, 0x02	; 2
    216e:	fc a3       	std	Y+36, r31	; 0x24
  }   
            
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    2170:	80 91 6a 05 	lds	r24, 0x056A	; 0x80056a <gc_block+0x3>
    2174:	81 30       	cpi	r24, 0x01	; 1
    2176:	09 f0       	breq	.+2      	; 0x217a <gc_execute_line+0x1564>
    2178:	eb c8       	rjmp	.-3626   	; 0x1350 <gc_execute_line+0x73a>
    217a:	b6 c8       	rjmp	.-3732   	; 0x12e8 <gc_execute_line+0x6d2>
          }
        }
      }
          
      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {        
    217c:	25 e0       	ldi	r18, 0x05	; 5
    217e:	52 16       	cp	r5, r18
    2180:	09 f4       	brne	.+2      	; 0x2184 <gc_execute_line+0x156e>
    2182:	eb ca       	rjmp	.-2602   	; 0x175a <gc_execute_line+0xb44>
    2184:	37 e0       	ldi	r19, 0x07	; 7
    2186:	53 16       	cp	r5, r19
    2188:	09 f4       	brne	.+2      	; 0x218c <gc_execute_line+0x1576>
    218a:	f5 ca       	rjmp	.-2582   	; 0x1776 <gc_execute_line+0xb60>
    218c:	83 e0       	ldi	r24, 0x03	; 3
    218e:	58 12       	cpse	r5, r24
    2190:	f7 ca       	rjmp	.-2578   	; 0x1780 <gc_execute_line+0xb6a>
    2192:	d9 ca       	rjmp	.-2638   	; 0x1746 <gc_execute_line+0xb30>
    2194:	95 e0       	ldi	r25, 0x05	; 5
    2196:	59 16       	cp	r5, r25
    2198:	09 f4       	brne	.+2      	; 0x219c <gc_execute_line+0x1586>
    219a:	df ca       	rjmp	.-2626   	; 0x175a <gc_execute_line+0xb44>
    219c:	a7 e0       	ldi	r26, 0x07	; 7
    219e:	5a 16       	cp	r5, r26
    21a0:	09 f4       	brne	.+2      	; 0x21a4 <gc_execute_line+0x158e>
    21a2:	e9 ca       	rjmp	.-2606   	; 0x1776 <gc_execute_line+0xb60>
    21a4:	b3 e0       	ldi	r27, 0x03	; 3
    21a6:	5b 12       	cpse	r5, r27
    21a8:	eb ca       	rjmp	.-2602   	; 0x1780 <gc_execute_line+0xb6a>
    21aa:	cc ca       	rjmp	.-2664   	; 0x1744 <gc_execute_line+0xb2e>
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    21ac:	10 91 68 05 	lds	r17, 0x0568	; 0x800568 <gc_block+0x1>
    21b0:	18 30       	cpi	r17, 0x08	; 8
    21b2:	09 f0       	breq	.+2      	; 0x21b6 <gc_execute_line+0x15a0>
    21b4:	f6 ca       	rjmp	.-2580   	; 0x17a2 <gc_execute_line+0xb8c>
    21b6:	ef ca       	rjmp	.-2594   	; 0x1796 <gc_execute_line+0xb80>
  
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
    21b8:	ee ed       	ldi	r30, 0xDE	; 222
    21ba:	6e 22       	and	r6, r30
    21bc:	ec ef       	ldi	r30, 0xFC	; 252
    21be:	7e 22       	and	r7, r30
    21c0:	1a a2       	std	Y+34, r1	; 0x22
    21c2:	22 cd       	rjmp	.-1468   	; 0x1c08 <gc_execute_line+0xff2>
    gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; // Reset program flow.
  }
    
  // TODO: % to denote start of program.
  return(STATUS_OK);
}
    21c4:	ab 96       	adiw	r28, 0x2b	; 43
    21c6:	0f b6       	in	r0, 0x3f	; 63
    21c8:	f8 94       	cli
    21ca:	de bf       	out	0x3e, r29	; 62
    21cc:	0f be       	out	0x3f, r0	; 63
    21ce:	cd bf       	out	0x3d, r28	; 61
    21d0:	df 91       	pop	r29
    21d2:	cf 91       	pop	r28
    21d4:	1f 91       	pop	r17
    21d6:	0f 91       	pop	r16
    21d8:	ff 90       	pop	r15
    21da:	ef 90       	pop	r14
    21dc:	df 90       	pop	r13
    21de:	cf 90       	pop	r12
    21e0:	bf 90       	pop	r11
    21e2:	af 90       	pop	r10
    21e4:	9f 90       	pop	r9
    21e6:	8f 90       	pop	r8
    21e8:	7f 90       	pop	r7
    21ea:	6f 90       	pop	r6
    21ec:	5f 90       	pop	r5
    21ee:	4f 90       	pop	r4
    21f0:	3f 90       	pop	r3
    21f2:	2f 90       	pop	r2
    21f4:	08 95       	ret

000021f6 <limits_disable>:


// Disables hard limits.
void limits_disable()
{
  LIMIT_PCMSK &= ~LIMIT_MASK;  // Disable specific pins of the Pin Change Interrupt
    21f6:	eb e6       	ldi	r30, 0x6B	; 107
    21f8:	f0 e0       	ldi	r31, 0x00	; 0
    21fa:	80 81       	ld	r24, Z
    21fc:	89 7e       	andi	r24, 0xE9	; 233
    21fe:	80 83       	st	Z, r24
  PCICR &= ~(1 << LIMIT_INT);  // Disable Pin Change Interrupt
    2200:	e8 e6       	ldi	r30, 0x68	; 104
    2202:	f0 e0       	ldi	r31, 0x00	; 0
    2204:	80 81       	ld	r24, Z
    2206:	8e 7f       	andi	r24, 0xFE	; 254
    2208:	80 83       	st	Z, r24
    220a:	08 95       	ret

0000220c <limits_init>:
  #define HOMING_AXIS_LOCATE_SCALAR  5.0 // Must be > 1 to ensure limit switch is cleared.
#endif

void limits_init() 
{
  LIMIT_DDR &= ~(LIMIT_MASK); // Set as input pins
    220c:	84 b1       	in	r24, 0x04	; 4
    220e:	89 7e       	andi	r24, 0xE9	; 233
    2210:	84 b9       	out	0x04, r24	; 4

  #ifdef DISABLE_LIMIT_PIN_PULL_UP
    LIMIT_PORT &= ~(LIMIT_MASK); // Normal low operation. Requires external pull-down.
  #else
    LIMIT_PORT |= (LIMIT_MASK);  // Enable internal pull-up resistors. Normal high operation.
    2212:	85 b1       	in	r24, 0x05	; 5
    2214:	86 61       	ori	r24, 0x16	; 22
    2216:	85 b9       	out	0x05, r24	; 5
  #endif

  if (bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE)) {
    2218:	80 91 bc 06 	lds	r24, 0x06BC	; 0x8006bc <settings+0x3d>
    221c:	83 ff       	sbrs	r24, 3
    221e:	0b c0       	rjmp	.+22     	; 0x2236 <limits_init+0x2a>
    LIMIT_PCMSK |= LIMIT_MASK; // Enable specific pins of the Pin Change Interrupt
    2220:	eb e6       	ldi	r30, 0x6B	; 107
    2222:	f0 e0       	ldi	r31, 0x00	; 0
    2224:	80 81       	ld	r24, Z
    2226:	86 61       	ori	r24, 0x16	; 22
    2228:	80 83       	st	Z, r24
    PCICR |= (1 << LIMIT_INT); // Enable Pin Change Interrupt
    222a:	e8 e6       	ldi	r30, 0x68	; 104
    222c:	f0 e0       	ldi	r31, 0x00	; 0
    222e:	80 81       	ld	r24, Z
    2230:	81 60       	ori	r24, 0x01	; 1
    2232:	80 83       	st	Z, r24
    2234:	08 95       	ret
  } else {
    limits_disable(); 
    2236:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <limits_disable>
    223a:	08 95       	ret

0000223c <limits_get_state>:

// Returns limit state as a bit-wise uint8 variable. Each bit indicates an axis limit, where 
// triggered is 1 and not triggered is 0. Invert mask is applied. Axes are defined by their
// number in bit position, i.e. Z_AXIS is (1<<2) or bit 2, and Y_AXIS is (1<<1) or bit 1.
uint8_t limits_get_state()
{
    223c:	ef 92       	push	r14
    223e:	ff 92       	push	r15
    2240:	0f 93       	push	r16
    2242:	1f 93       	push	r17
    2244:	cf 93       	push	r28
    2246:	df 93       	push	r29
  uint8_t limit_state = 0;
  uint8_t pin = (LIMIT_PIN & LIMIT_MASK);
    2248:	13 b1       	in	r17, 0x03	; 3
    224a:	16 71       	andi	r17, 0x16	; 22
  #ifdef INVERT_LIMIT_PIN_MASK
    pin ^= INVERT_LIMIT_PIN_MASK;
  #endif
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
    224c:	80 91 bc 06 	lds	r24, 0x06BC	; 0x8006bc <settings+0x3d>
    2250:	86 fd       	sbrc	r24, 6
    2252:	1b c0       	rjmp	.+54     	; 0x228a <limits_get_state+0x4e>
    2254:	86 e1       	ldi	r24, 0x16	; 22
    2256:	18 27       	eor	r17, r24
    2258:	18 c0       	rjmp	.+48     	; 0x228a <limits_get_state+0x4e>
  if (pin) {  
    225a:	c0 e0       	ldi	r28, 0x00	; 0
    225c:	d0 e0       	ldi	r29, 0x00	; 0
    225e:	00 e0       	ldi	r16, 0x00	; 0
    uint8_t idx;
    for (idx=0; idx<N_AXIS; idx++) {
      if (pin & get_limit_pin_mask(idx)) { limit_state |= (1 << idx); }
    2260:	ee 24       	eor	r14, r14
    2262:	e3 94       	inc	r14
    2264:	f1 2c       	mov	r15, r1
    2266:	8c 2f       	mov	r24, r28
    2268:	0e 94 b1 2b 	call	0x5762	; 0x5762 <get_limit_pin_mask>
    226c:	81 23       	and	r24, r17
    226e:	41 f0       	breq	.+16     	; 0x2280 <limits_get_state+0x44>
    2270:	c7 01       	movw	r24, r14
    2272:	0c 2e       	mov	r0, r28
    2274:	02 c0       	rjmp	.+4      	; 0x227a <limits_get_state+0x3e>
    2276:	88 0f       	add	r24, r24
    2278:	99 1f       	adc	r25, r25
    227a:	0a 94       	dec	r0
    227c:	e2 f7       	brpl	.-8      	; 0x2276 <limits_get_state+0x3a>
    227e:	08 2b       	or	r16, r24
    2280:	21 96       	adiw	r28, 0x01	; 1
    pin ^= INVERT_LIMIT_PIN_MASK;
  #endif
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
  if (pin) {  
    uint8_t idx;
    for (idx=0; idx<N_AXIS; idx++) {
    2282:	c3 30       	cpi	r28, 0x03	; 3
    2284:	d1 05       	cpc	r29, r1
    2286:	79 f7       	brne	.-34     	; 0x2266 <limits_get_state+0x2a>
    2288:	03 c0       	rjmp	.+6      	; 0x2290 <limits_get_state+0x54>
  uint8_t pin = (LIMIT_PIN & LIMIT_MASK);
  #ifdef INVERT_LIMIT_PIN_MASK
    pin ^= INVERT_LIMIT_PIN_MASK;
  #endif
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
  if (pin) {  
    228a:	11 11       	cpse	r17, r1
    228c:	e6 cf       	rjmp	.-52     	; 0x225a <limits_get_state+0x1e>
// Returns limit state as a bit-wise uint8 variable. Each bit indicates an axis limit, where 
// triggered is 1 and not triggered is 0. Invert mask is applied. Axes are defined by their
// number in bit position, i.e. Z_AXIS is (1<<2) or bit 2, and Y_AXIS is (1<<1) or bit 1.
uint8_t limits_get_state()
{
  uint8_t limit_state = 0;
    228e:	00 e0       	ldi	r16, 0x00	; 0
    for (idx=0; idx<N_AXIS; idx++) {
      if (pin & get_limit_pin_mask(idx)) { limit_state |= (1 << idx); }
    }
  }
  return(limit_state);
}
    2290:	80 2f       	mov	r24, r16
    2292:	df 91       	pop	r29
    2294:	cf 91       	pop	r28
    2296:	1f 91       	pop	r17
    2298:	0f 91       	pop	r16
    229a:	ff 90       	pop	r15
    229c:	ef 90       	pop	r14
    229e:	08 95       	ret

000022a0 <__vector_3>:
// homing cycles and will not respond correctly. Upon user request or need, there may be a
// special pinout for an e-stop, but it is generally recommended to just directly connect
// your e-stop switch to the Arduino reset pin, since it is the most correct way to do this.
#ifndef ENABLE_SOFTWARE_DEBOUNCE
  ISR(LIMIT_INT_vect) // DEFAULT: Limit pin change interrupt process. 
  {
    22a0:	1f 92       	push	r1
    22a2:	0f 92       	push	r0
    22a4:	0f b6       	in	r0, 0x3f	; 63
    22a6:	0f 92       	push	r0
    22a8:	11 24       	eor	r1, r1
    22aa:	2f 93       	push	r18
    22ac:	3f 93       	push	r19
    22ae:	4f 93       	push	r20
    22b0:	5f 93       	push	r21
    22b2:	6f 93       	push	r22
    22b4:	7f 93       	push	r23
    22b6:	8f 93       	push	r24
    22b8:	9f 93       	push	r25
    22ba:	af 93       	push	r26
    22bc:	bf 93       	push	r27
    22be:	ef 93       	push	r30
    22c0:	ff 93       	push	r31
    // Ignore limit switches if already in an alarm state or in-process of executing an alarm.
    // When in the alarm state, Grbl should have been reset or will force a reset, so any pending 
    // moves in the planner and serial buffers are all cleared and newly sent blocks will be 
    // locked out until a homing cycle or a kill lock command. Allows the user to disable the hard
    // limit setting if their limits are constantly triggering after a reset and move their axes.
    if (sys.state != STATE_ALARM) { 
    22c2:	80 91 a1 05 	lds	r24, 0x05A1	; 0x8005a1 <sys+0x1>
    22c6:	81 30       	cpi	r24, 0x01	; 1
    22c8:	71 f0       	breq	.+28     	; 0x22e6 <__vector_3+0x46>
      if (!(sys_rt_exec_alarm)) {
    22ca:	80 91 27 05 	lds	r24, 0x0527	; 0x800527 <sys_rt_exec_alarm>
    22ce:	81 11       	cpse	r24, r1
    22d0:	0a c0       	rjmp	.+20     	; 0x22e6 <__vector_3+0x46>
          if (limits_get_state()) {
            mc_reset(); // Initiate system kill.
            bit_true_atomic(sys_rt_exec_alarm, (EXEC_ALARM_HARD_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate hard limit critical event
          }
        #else
          mc_reset(); // Initiate system kill.
    22d2:	0e 94 36 18 	call	0x306c	; 0x306c <mc_reset>
          bit_true_atomic(sys_rt_exec_alarm, (EXEC_ALARM_HARD_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate hard limit critical event
    22d6:	9f b7       	in	r25, 0x3f	; 63
    22d8:	f8 94       	cli
    22da:	80 91 27 05 	lds	r24, 0x0527	; 0x800527 <sys_rt_exec_alarm>
    22de:	83 60       	ori	r24, 0x03	; 3
    22e0:	80 93 27 05 	sts	0x0527, r24	; 0x800527 <sys_rt_exec_alarm>
    22e4:	9f bf       	out	0x3f, r25	; 63
        #endif
      }
    }
  }  
    22e6:	ff 91       	pop	r31
    22e8:	ef 91       	pop	r30
    22ea:	bf 91       	pop	r27
    22ec:	af 91       	pop	r26
    22ee:	9f 91       	pop	r25
    22f0:	8f 91       	pop	r24
    22f2:	7f 91       	pop	r23
    22f4:	6f 91       	pop	r22
    22f6:	5f 91       	pop	r21
    22f8:	4f 91       	pop	r20
    22fa:	3f 91       	pop	r19
    22fc:	2f 91       	pop	r18
    22fe:	0f 90       	pop	r0
    2300:	0f be       	out	0x3f, r0	; 63
    2302:	0f 90       	pop	r0
    2304:	1f 90       	pop	r1
    2306:	18 95       	reti

00002308 <limits_go_home>:
// mask, which prevents the stepper algorithm from executing step pulses. Homing motions typically 
// circumvent the processes for executing motions in normal operation.
// NOTE: Only the abort realtime command can interrupt this process.
// TODO: Move limit pin-specific calls to a general function for portability.
void limits_go_home(uint8_t cycle_mask) 
{
    2308:	2f 92       	push	r2
    230a:	3f 92       	push	r3
    230c:	4f 92       	push	r4
    230e:	5f 92       	push	r5
    2310:	6f 92       	push	r6
    2312:	7f 92       	push	r7
    2314:	8f 92       	push	r8
    2316:	9f 92       	push	r9
    2318:	af 92       	push	r10
    231a:	bf 92       	push	r11
    231c:	cf 92       	push	r12
    231e:	df 92       	push	r13
    2320:	ef 92       	push	r14
    2322:	ff 92       	push	r15
    2324:	0f 93       	push	r16
    2326:	1f 93       	push	r17
    2328:	cf 93       	push	r28
    232a:	df 93       	push	r29
    232c:	cd b7       	in	r28, 0x3d	; 61
    232e:	de b7       	in	r29, 0x3e	; 62
    2330:	6a 97       	sbiw	r28, 0x1a	; 26
    2332:	0f b6       	in	r0, 0x3f	; 63
    2334:	f8 94       	cli
    2336:	de bf       	out	0x3e, r29	; 62
    2338:	0f be       	out	0x3f, r0	; 63
    233a:	cd bf       	out	0x3d, r28	; 61
  if (sys.abort) { return; } // Block if system reset has been issued.
    233c:	90 91 a0 05 	lds	r25, 0x05A0	; 0x8005a0 <sys>
    2340:	91 11       	cpse	r25, r1
    2342:	c9 c1       	rjmp	.+914    	; 0x26d6 <limits_go_home+0x3ce>
    2344:	88 8f       	std	Y+24, r24	; 0x18
    2346:	2f e7       	ldi	r18, 0x7F	; 127
    2348:	36 e0       	ldi	r19, 0x06	; 6
    234a:	3f 8b       	std	Y+23, r19	; 0x17
    234c:	2e 8b       	std	Y+22, r18	; 0x16
    234e:	79 01       	movw	r14, r18
    2350:	ce 01       	movw	r24, r28
    2352:	01 96       	adiw	r24, 0x01	; 1
    2354:	5c 01       	movw	r10, r24
    2356:	00 e0       	ldi	r16, 0x00	; 0
    2358:	10 e0       	ldi	r17, 0x00	; 0
    235a:	41 2c       	mov	r4, r1
    235c:	51 2c       	mov	r5, r1
    235e:	32 01       	movw	r6, r4
    step_pin[idx] = get_step_pin_mask(idx);
    #ifdef COREXY    
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (get_step_pin_mask(X_AXIS)|get_step_pin_mask(Y_AXIS)); } 
    #endif

    if (bit_istrue(cycle_mask,bit(idx))) { 
    2360:	98 8d       	ldd	r25, Y+24	; 0x18
    2362:	c9 2e       	mov	r12, r25
    2364:	d1 2c       	mov	r13, r1
  float target[N_AXIS];
  float max_travel = 0.0;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {  
    // Initialize step pin masks
    step_pin[idx] = get_step_pin_mask(idx);
    2366:	80 2f       	mov	r24, r16
    2368:	0e 94 9d 2b 	call	0x573a	; 0x573a <get_step_pin_mask>
    236c:	d5 01       	movw	r26, r10
    236e:	8d 93       	st	X+, r24
    2370:	5d 01       	movw	r10, r26
    #ifdef COREXY    
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (get_step_pin_mask(X_AXIS)|get_step_pin_mask(Y_AXIS)); } 
    #endif

    if (bit_istrue(cycle_mask,bit(idx))) { 
    2372:	d9 8a       	std	Y+17, r13	; 0x11
    2374:	c8 8a       	std	Y+16, r12	; 0x10
    2376:	c6 01       	movw	r24, r12
    2378:	00 2e       	mov	r0, r16
    237a:	02 c0       	rjmp	.+4      	; 0x2380 <limits_go_home+0x78>
    237c:	95 95       	asr	r25
    237e:	87 95       	ror	r24
    2380:	0a 94       	dec	r0
    2382:	e2 f7       	brpl	.-8      	; 0x237c <limits_go_home+0x74>
    2384:	80 ff       	sbrs	r24, 0
    2386:	19 c0       	rjmp	.+50     	; 0x23ba <limits_go_home+0xb2>
      // Set target based on max_travel setting. Ensure homing switches engaged with search scalar.
      // NOTE: settings.max_travel[] is stored as a negative value.
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    2388:	20 e0       	ldi	r18, 0x00	; 0
    238a:	30 e0       	ldi	r19, 0x00	; 0
    238c:	40 ec       	ldi	r20, 0xC0	; 192
    238e:	5f eb       	ldi	r21, 0xBF	; 191
    2390:	f7 01       	movw	r30, r14
    2392:	64 a1       	ldd	r22, Z+36	; 0x24
    2394:	75 a1       	ldd	r23, Z+37	; 0x25
    2396:	86 a1       	ldd	r24, Z+38	; 0x26
    2398:	97 a1       	ldd	r25, Z+39	; 0x27
    239a:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    239e:	86 2e       	mov	r8, r22
    23a0:	97 2e       	mov	r9, r23
    23a2:	28 2e       	mov	r2, r24
    23a4:	39 2e       	mov	r3, r25
    23a6:	a3 01       	movw	r20, r6
    23a8:	92 01       	movw	r18, r4
    23aa:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    23ae:	88 23       	and	r24, r24
    23b0:	24 f0       	brlt	.+8      	; 0x23ba <limits_go_home+0xb2>
    23b2:	48 2c       	mov	r4, r8
    23b4:	59 2c       	mov	r5, r9
    23b6:	62 2c       	mov	r6, r2
    23b8:	73 2c       	mov	r7, r3
    23ba:	0f 5f       	subi	r16, 0xFF	; 255
    23bc:	1f 4f       	sbci	r17, 0xFF	; 255
    23be:	f4 e0       	ldi	r31, 0x04	; 4
    23c0:	ef 0e       	add	r14, r31
    23c2:	f1 1c       	adc	r15, r1
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  uint8_t step_pin[N_AXIS];
  float target[N_AXIS];
  float max_travel = 0.0;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {  
    23c4:	03 30       	cpi	r16, 0x03	; 3
    23c6:	11 05       	cpc	r17, r1
    23c8:	71 f6       	brne	.-100    	; 0x2366 <limits_go_home+0x5e>
    23ca:	28 88       	ldd	r2, Y+16	; 0x10
    23cc:	39 88       	ldd	r3, Y+17	; 0x11
    }
  }

  // Set search mode with approach at seek rate to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
  float homing_rate = settings.homing_seek_rate;
    23ce:	80 91 c2 06 	lds	r24, 0x06C2	; 0x8006c2 <settings+0x43>
    23d2:	90 91 c3 06 	lds	r25, 0x06C3	; 0x8006c3 <settings+0x44>
    23d6:	a0 91 c4 06 	lds	r26, 0x06C4	; 0x8006c4 <settings+0x45>
    23da:	b0 91 c5 06 	lds	r27, 0x06C5	; 0x8006c5 <settings+0x46>
    23de:	8a 8b       	std	Y+18, r24	; 0x12
    23e0:	9b 8b       	std	Y+19, r25	; 0x13
    23e2:	ac 8b       	std	Y+20, r26	; 0x14
    23e4:	bd 8b       	std	Y+21, r27	; 0x15
    23e6:	94 e0       	ldi	r25, 0x04	; 4
    23e8:	98 8b       	std	Y+16, r25	; 0x10
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    }
  }

  // Set search mode with approach at seek rate to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
    23ea:	01 e0       	ldi	r16, 0x01	; 1
  float homing_rate = settings.homing_seek_rate;

  uint8_t limit_state, axislock, n_active_axis;
  do {

    system_convert_array_steps_to_mpos(target,sys.position);
    23ec:	64 ea       	ldi	r22, 0xA4	; 164
    23ee:	75 e0       	ldi	r23, 0x05	; 5
    23f0:	ce 01       	movw	r24, r28
    23f2:	04 96       	adiw	r24, 0x04	; 4
    23f4:	0e 94 8e 38 	call	0x711c	; 0x711c <system_convert_array_steps_to_mpos>
        #else
          sys.position[idx] = 0;
        #endif
        // Set target direction based on cycle mask and homing cycle approach state.
        // NOTE: This happens to compile smaller than any other implementation tried.
        if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
    23f8:	80 91 bd 06 	lds	r24, 0x06BD	; 0x8006bd <settings+0x3e>
    23fc:	e8 2e       	mov	r14, r24
    23fe:	f1 2c       	mov	r15, r1
    2400:	ae 01       	movw	r20, r28
    2402:	4c 5f       	subi	r20, 0xFC	; 252
    2404:	5f 4f       	sbci	r21, 0xFF	; 255
    2406:	0f 2e       	mov	r0, r31
    2408:	f0 ea       	ldi	r31, 0xA0	; 160
    240a:	cf 2e       	mov	r12, r31
    240c:	f5 e0       	ldi	r31, 0x05	; 5
    240e:	df 2e       	mov	r13, r31
    2410:	f0 2d       	mov	r31, r0
    2412:	f6 01       	movw	r30, r12
    2414:	de 01       	movw	r26, r28
    2416:	11 96       	adiw	r26, 0x01	; 1
    2418:	80 e0       	ldi	r24, 0x00	; 0
    241a:	90 e0       	ldi	r25, 0x00	; 0

    system_convert_array_steps_to_mpos(target,sys.position);

    // Initialize and declare variables needed for homing routine.
    axislock = 0;
    n_active_axis = 0;
    241c:	60 e0       	ldi	r22, 0x00	; 0
  do {

    system_convert_array_steps_to_mpos(target,sys.position);

    // Initialize and declare variables needed for homing routine.
    axislock = 0;
    241e:	10 e0       	ldi	r17, 0x00	; 0
        if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
          if (approach) { target[idx] = -max_travel; }
          else { target[idx] = max_travel; }
        } else { 
          if (approach) { target[idx] = max_travel; }
          else { target[idx] = -max_travel; }
    2420:	53 01       	movw	r10, r6
    2422:	42 01       	movw	r8, r4
    2424:	b7 fa       	bst	r11, 7
    2426:	b0 94       	com	r11
    2428:	b7 f8       	bld	r11, 7
    242a:	b0 94       	com	r11
    242c:	ba 8f       	std	Y+26, r27	; 0x1a
    242e:	a9 8f       	std	Y+25, r26	; 0x19
    // Initialize and declare variables needed for homing routine.
    axislock = 0;
    n_active_axis = 0;
    for (idx=0; idx<N_AXIS; idx++) {
      // Set target location for active axes and setup computation for homing rate.
      if (bit_istrue(cycle_mask,bit(idx))) {
    2430:	91 01       	movw	r18, r2
    2432:	08 2e       	mov	r0, r24
    2434:	02 c0       	rjmp	.+4      	; 0x243a <limits_go_home+0x132>
    2436:	35 95       	asr	r19
    2438:	27 95       	ror	r18
    243a:	0a 94       	dec	r0
    243c:	e2 f7       	brpl	.-8      	; 0x2436 <limits_go_home+0x12e>
    243e:	20 ff       	sbrs	r18, 0
    2440:	31 c0       	rjmp	.+98     	; 0x24a4 <limits_go_home+0x19c>
        n_active_axis++;
    2442:	6f 5f       	subi	r22, 0xFF	; 255
            sys.position[A_MOTOR] = sys.position[B_MOTOR] = axis_position;
          } else { 
            sys.position[Z_AXIS] = 0; 
          }
        #else
          sys.position[idx] = 0;
    2444:	14 82       	std	Z+4, r1	; 0x04
    2446:	15 82       	std	Z+5, r1	; 0x05
    2448:	16 82       	std	Z+6, r1	; 0x06
    244a:	17 82       	std	Z+7, r1	; 0x07
        #endif
        // Set target direction based on cycle mask and homing cycle approach state.
        // NOTE: This happens to compile smaller than any other implementation tried.
        if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
    244c:	97 01       	movw	r18, r14
    244e:	08 2e       	mov	r0, r24
    2450:	02 c0       	rjmp	.+4      	; 0x2456 <limits_go_home+0x14e>
    2452:	35 95       	asr	r19
    2454:	27 95       	ror	r18
    2456:	0a 94       	dec	r0
    2458:	e2 f7       	brpl	.-8      	; 0x2452 <limits_go_home+0x14a>
    245a:	20 ff       	sbrs	r18, 0
    245c:	10 c0       	rjmp	.+32     	; 0x247e <limits_go_home+0x176>
          if (approach) { target[idx] = -max_travel; }
    245e:	00 23       	and	r16, r16
    2460:	39 f0       	breq	.+14     	; 0x2470 <limits_go_home+0x168>
    2462:	da 01       	movw	r26, r20
    2464:	8d 92       	st	X+, r8
    2466:	9d 92       	st	X+, r9
    2468:	ad 92       	st	X+, r10
    246a:	bc 92       	st	X, r11
    246c:	13 97       	sbiw	r26, 0x03	; 3
    246e:	16 c0       	rjmp	.+44     	; 0x249c <limits_go_home+0x194>
          else { target[idx] = max_travel; }
    2470:	da 01       	movw	r26, r20
    2472:	4d 92       	st	X+, r4
    2474:	5d 92       	st	X+, r5
    2476:	6d 92       	st	X+, r6
    2478:	7c 92       	st	X, r7
    247a:	13 97       	sbiw	r26, 0x03	; 3
    247c:	0f c0       	rjmp	.+30     	; 0x249c <limits_go_home+0x194>
        } else { 
          if (approach) { target[idx] = max_travel; }
    247e:	00 23       	and	r16, r16
    2480:	39 f0       	breq	.+14     	; 0x2490 <limits_go_home+0x188>
    2482:	da 01       	movw	r26, r20
    2484:	4d 92       	st	X+, r4
    2486:	5d 92       	st	X+, r5
    2488:	6d 92       	st	X+, r6
    248a:	7c 92       	st	X, r7
    248c:	13 97       	sbiw	r26, 0x03	; 3
    248e:	06 c0       	rjmp	.+12     	; 0x249c <limits_go_home+0x194>
          else { target[idx] = -max_travel; }
    2490:	da 01       	movw	r26, r20
    2492:	8d 92       	st	X+, r8
    2494:	9d 92       	st	X+, r9
    2496:	ad 92       	st	X+, r10
    2498:	bc 92       	st	X, r11
    249a:	13 97       	sbiw	r26, 0x03	; 3
        }        
        // Apply axislock to the step port pins active in this cycle.
        axislock |= step_pin[idx];
    249c:	a9 8d       	ldd	r26, Y+25	; 0x19
    249e:	ba 8d       	ldd	r27, Y+26	; 0x1a
    24a0:	2c 91       	ld	r18, X
    24a2:	12 2b       	or	r17, r18
    24a4:	01 96       	adiw	r24, 0x01	; 1
    24a6:	29 8d       	ldd	r18, Y+25	; 0x19
    24a8:	3a 8d       	ldd	r19, Y+26	; 0x1a
    24aa:	2f 5f       	subi	r18, 0xFF	; 255
    24ac:	3f 4f       	sbci	r19, 0xFF	; 255
    24ae:	3a 8f       	std	Y+26, r19	; 0x1a
    24b0:	29 8f       	std	Y+25, r18	; 0x19
    24b2:	4c 5f       	subi	r20, 0xFC	; 252
    24b4:	5f 4f       	sbci	r21, 0xFF	; 255
    24b6:	34 96       	adiw	r30, 0x04	; 4
    system_convert_array_steps_to_mpos(target,sys.position);

    // Initialize and declare variables needed for homing routine.
    axislock = 0;
    n_active_axis = 0;
    for (idx=0; idx<N_AXIS; idx++) {
    24b8:	83 30       	cpi	r24, 0x03	; 3
    24ba:	91 05       	cpc	r25, r1
    24bc:	09 f0       	breq	.+2      	; 0x24c0 <limits_go_home+0x1b8>
    24be:	b8 cf       	rjmp	.-144    	; 0x2430 <limits_go_home+0x128>
        // Apply axislock to the step port pins active in this cycle.
        axislock |= step_pin[idx];
      }

    }
    homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    24c0:	46 2e       	mov	r4, r22
    24c2:	51 2c       	mov	r5, r1
    24c4:	61 2c       	mov	r6, r1
    24c6:	71 2c       	mov	r7, r1
    24c8:	c3 01       	movw	r24, r6
    24ca:	b2 01       	movw	r22, r4
    24cc:	0e 94 51 3a 	call	0x74a2	; 0x74a2 <__floatunsisf>
    24d0:	0e 94 a0 3c 	call	0x7940	; 0x7940 <sqrt>
    24d4:	9b 01       	movw	r18, r22
    24d6:	ac 01       	movw	r20, r24
    24d8:	6a 89       	ldd	r22, Y+18	; 0x12
    24da:	7b 89       	ldd	r23, Y+19	; 0x13
    24dc:	8c 89       	ldd	r24, Y+20	; 0x14
    24de:	9d 89       	ldd	r25, Y+21	; 0x15
    24e0:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    24e4:	4b 01       	movw	r8, r22
    24e6:	5c 01       	movw	r10, r24
    sys.homing_axis_lock = axislock;
    24e8:	10 93 bd 05 	sts	0x05BD, r17	; 0x8005bd <sys+0x1d>

    plan_sync_position(); // Sync planner position to current machine position.
    24ec:	0e 94 96 1e 	call	0x3d2c	; 0x3d2c <plan_sync_position>
    
    // Perform homing cycle. Planner buffer should be empty, as required to initiate the homing cycle.
    #ifdef USE_LINE_NUMBERS
      plan_buffer_line(target, homing_rate, false, HOMING_CYCLE_LINE_NUMBER); // Bypass mc_line(). Directly plan homing motion.
    #else
      plan_buffer_line(target, homing_rate, false); // Bypass mc_line(). Directly plan homing motion.
    24f0:	20 e0       	ldi	r18, 0x00	; 0
    24f2:	b5 01       	movw	r22, r10
    24f4:	a4 01       	movw	r20, r8
    24f6:	ce 01       	movw	r24, r28
    24f8:	04 96       	adiw	r24, 0x04	; 4
    24fa:	0e 94 27 1b 	call	0x364e	; 0x364e <plan_buffer_line>
    #endif
    
    st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
    24fe:	0e 94 2a 2f 	call	0x5e54	; 0x5e54 <st_prep_buffer>
    st_wake_up(); // Initiate motion
    2502:	0e 94 3c 2c 	call	0x5878	; 0x5878 <st_wake_up>
    do {
      if (approach) {
    2506:	00 23       	and	r16, r16
    2508:	f1 f0       	breq	.+60     	; 0x2546 <limits_go_home+0x23e>
        // Check limit state. Lock out cycle axes when they change.
        limit_state = limits_get_state();
    250a:	0e 94 1e 11 	call	0x223c	; 0x223c <limits_get_state>
    250e:	fe 01       	movw	r30, r28
    2510:	31 96       	adiw	r30, 0x01	; 1
    2512:	20 e0       	ldi	r18, 0x00	; 0
    2514:	30 e0       	ldi	r19, 0x00	; 0
        for (idx=0; idx<N_AXIS; idx++) {
          if (axislock & step_pin[idx]) {
            if (limit_state & (1 << idx)) { 
    2516:	68 2f       	mov	r22, r24
    2518:	70 e0       	ldi	r23, 0x00	; 0
    do {
      if (approach) {
        // Check limit state. Lock out cycle axes when they change.
        limit_state = limits_get_state();
        for (idx=0; idx<N_AXIS; idx++) {
          if (axislock & step_pin[idx]) {
    251a:	81 91       	ld	r24, Z+
    251c:	98 2f       	mov	r25, r24
    251e:	91 23       	and	r25, r17
    2520:	59 f0       	breq	.+22     	; 0x2538 <limits_go_home+0x230>
            if (limit_state & (1 << idx)) { 
    2522:	ab 01       	movw	r20, r22
    2524:	02 2e       	mov	r0, r18
    2526:	02 c0       	rjmp	.+4      	; 0x252c <limits_go_home+0x224>
    2528:	55 95       	asr	r21
    252a:	47 95       	ror	r20
    252c:	0a 94       	dec	r0
    252e:	e2 f7       	brpl	.-8      	; 0x2528 <limits_go_home+0x220>
    2530:	40 ff       	sbrs	r20, 0
    2532:	02 c0       	rjmp	.+4      	; 0x2538 <limits_go_home+0x230>
              #ifdef COREXY
                if (idx==Z_AXIS) { axislock &= ~(step_pin[Z_AXIS]); }
                else { axislock &= ~(step_pin[A_MOTOR]|step_pin[B_MOTOR]); }
              #else
                axislock &= ~(step_pin[idx]); 
    2534:	80 95       	com	r24
    2536:	18 23       	and	r17, r24
    2538:	2f 5f       	subi	r18, 0xFF	; 255
    253a:	3f 4f       	sbci	r19, 0xFF	; 255
    st_wake_up(); // Initiate motion
    do {
      if (approach) {
        // Check limit state. Lock out cycle axes when they change.
        limit_state = limits_get_state();
        for (idx=0; idx<N_AXIS; idx++) {
    253c:	23 30       	cpi	r18, 0x03	; 3
    253e:	31 05       	cpc	r19, r1
    2540:	61 f7       	brne	.-40     	; 0x251a <limits_go_home+0x212>
                axislock &= ~(step_pin[idx]); 
              #endif
            }
          }
        }
        sys.homing_axis_lock = axislock;
    2542:	10 93 bd 05 	sts	0x05BD, r17	; 0x8005bd <sys+0x1d>
      }

      st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
    2546:	0e 94 2a 2f 	call	0x5e54	; 0x5e54 <st_prep_buffer>

      // Exit routines: No time to run protocol_execute_realtime() in this loop.
      if (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_STOP)) {
    254a:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    254e:	84 73       	andi	r24, 0x34	; 52
    2550:	c9 f0       	breq	.+50     	; 0x2584 <limits_go_home+0x27c>
        // Homing failure: Limit switches are still engaged after pull-off motion
        if ( (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET)) ||  // Safety door or reset issued
    2552:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    2556:	80 73       	andi	r24, 0x30	; 48
    2558:	39 f4       	brne	.+14     	; 0x2568 <limits_go_home+0x260>
    255a:	01 11       	cpse	r16, r1
    255c:	b7 c0       	rjmp	.+366    	; 0x26cc <limits_go_home+0x3c4>
           (!approach && (limits_get_state() & cycle_mask)) ||  // Limit switch still engaged after pull-off motion
    255e:	0e 94 1e 11 	call	0x223c	; 0x223c <limits_get_state>
    2562:	38 8d       	ldd	r19, Y+24	; 0x18
    2564:	83 23       	and	r24, r19
    2566:	29 f0       	breq	.+10     	; 0x2572 <limits_go_home+0x26a>
           ( approach && (sys_rt_exec_state & EXEC_CYCLE_STOP)) ) { // Limit switch not found during approach.
          mc_reset(); // Stop motors, if they are running.
    2568:	0e 94 36 18 	call	0x306c	; 0x306c <mc_reset>
          protocol_execute_realtime();
    256c:	0e 94 46 20 	call	0x408c	; 0x408c <protocol_execute_realtime>
          return;
    2570:	b2 c0       	rjmp	.+356    	; 0x26d6 <limits_go_home+0x3ce>
        } else {
          // Pull-off motion complete. Disable CYCLE_STOP from executing.
          bit_false_atomic(sys_rt_exec_state,EXEC_CYCLE_STOP);
    2572:	9f b7       	in	r25, 0x3f	; 63
    2574:	f8 94       	cli
    2576:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    257a:	8b 7f       	andi	r24, 0xFB	; 251
    257c:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <sys_rt_exec_state>
    2580:	9f bf       	out	0x3f, r25	; 63
          break;
    2582:	04 c0       	rjmp	.+8      	; 0x258c <limits_go_home+0x284>
        } 
      }

    } while (STEP_MASK & axislock);
    2584:	81 2f       	mov	r24, r17
    2586:	8c 71       	andi	r24, 0x1C	; 28
    2588:	09 f0       	breq	.+2      	; 0x258c <limits_go_home+0x284>
    258a:	bd cf       	rjmp	.-134    	; 0x2506 <limits_go_home+0x1fe>

    st_reset(); // Immediately force kill steppers and reset step segment buffer.
    258c:	0e 94 bd 2e 	call	0x5d7a	; 0x5d7a <st_reset>
    plan_reset(); // Reset planner buffer to zero planner current position and to clear previous motions.
    2590:	0e 94 cf 1a 	call	0x359e	; 0x359e <plan_reset>

    delay_ms(settings.homing_debounce_delay); // Delay to allow transient dynamics to dissipate.
    2594:	a6 ec       	ldi	r26, 0xC6	; 198
    2596:	b6 e0       	ldi	r27, 0x06	; 6
    2598:	8d 91       	ld	r24, X+
    259a:	9c 91       	ld	r25, X
    259c:	0e 94 2b 19 	call	0x3256	; 0x3256 <delay_ms>

    // Reverse direction and reset homing rate for locate cycle(s).
    approach = !approach;
    25a0:	b1 e0       	ldi	r27, 0x01	; 1
    25a2:	0b 27       	eor	r16, r27

    // After first cycle, homing enters locating phase. Shorten search to pull-off distance.
    if (approach) { 
    25a4:	d1 f0       	breq	.+52     	; 0x25da <limits_go_home+0x2d2>
      max_travel = settings.homing_pulloff*HOMING_AXIS_LOCATE_SCALAR; 
    25a6:	20 e0       	ldi	r18, 0x00	; 0
    25a8:	30 e0       	ldi	r19, 0x00	; 0
    25aa:	40 ea       	ldi	r20, 0xA0	; 160
    25ac:	50 e4       	ldi	r21, 0x40	; 64
    25ae:	e8 ec       	ldi	r30, 0xC8	; 200
    25b0:	f6 e0       	ldi	r31, 0x06	; 6
    25b2:	60 81       	ld	r22, Z
    25b4:	71 81       	ldd	r23, Z+1	; 0x01
    25b6:	82 81       	ldd	r24, Z+2	; 0x02
    25b8:	93 81       	ldd	r25, Z+3	; 0x03
    25ba:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    25be:	2b 01       	movw	r4, r22
    25c0:	3c 01       	movw	r6, r24
      homing_rate = settings.homing_feed_rate;
    25c2:	ae eb       	ldi	r26, 0xBE	; 190
    25c4:	b6 e0       	ldi	r27, 0x06	; 6
    25c6:	8d 91       	ld	r24, X+
    25c8:	9d 91       	ld	r25, X+
    25ca:	0d 90       	ld	r0, X+
    25cc:	bc 91       	ld	r27, X
    25ce:	a0 2d       	mov	r26, r0
    25d0:	8a 8b       	std	Y+18, r24	; 0x12
    25d2:	9b 8b       	std	Y+19, r25	; 0x13
    25d4:	ac 8b       	std	Y+20, r26	; 0x14
    25d6:	bd 8b       	std	Y+21, r27	; 0x15
    25d8:	11 c0       	rjmp	.+34     	; 0x25fc <limits_go_home+0x2f4>
    } else {
      max_travel = settings.homing_pulloff;    
    25da:	e8 ec       	ldi	r30, 0xC8	; 200
    25dc:	f6 e0       	ldi	r31, 0x06	; 6
    25de:	40 80       	ld	r4, Z
    25e0:	51 80       	ldd	r5, Z+1	; 0x01
    25e2:	62 80       	ldd	r6, Z+2	; 0x02
    25e4:	73 80       	ldd	r7, Z+3	; 0x03
      homing_rate = settings.homing_seek_rate;
    25e6:	a2 ec       	ldi	r26, 0xC2	; 194
    25e8:	b6 e0       	ldi	r27, 0x06	; 6
    25ea:	8d 91       	ld	r24, X+
    25ec:	9d 91       	ld	r25, X+
    25ee:	0d 90       	ld	r0, X+
    25f0:	bc 91       	ld	r27, X
    25f2:	a0 2d       	mov	r26, r0
    25f4:	8a 8b       	std	Y+18, r24	; 0x12
    25f6:	9b 8b       	std	Y+19, r25	; 0x13
    25f8:	ac 8b       	std	Y+20, r26	; 0x14
    25fa:	bd 8b       	std	Y+21, r27	; 0x15
    25fc:	b8 89       	ldd	r27, Y+16	; 0x10
    25fe:	b1 50       	subi	r27, 0x01	; 1
    2600:	b8 8b       	std	Y+16, r27	; 0x10
    }
    
  } while (n_cycle-- > 0);
    2602:	b1 11       	cpse	r27, r1
    2604:	f3 ce       	rjmp	.-538    	; 0x23ec <limits_go_home+0xe4>
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
      #ifdef HOMING_FORCE_SET_ORIGIN
        set_axis_position = 0;
      #else 
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    2606:	e0 90 bd 06 	lds	r14, 0x06BD	; 0x8006bd <settings+0x3e>
    260a:	f1 2c       	mov	r15, r1
          set_axis_position = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
    260c:	80 90 c8 06 	lds	r8, 0x06C8	; 0x8006c8 <settings+0x49>
    2610:	90 90 c9 06 	lds	r9, 0x06C9	; 0x8006c9 <settings+0x4a>
    2614:	a0 90 ca 06 	lds	r10, 0x06CA	; 0x8006ca <settings+0x4b>
    2618:	b0 90 cb 06 	lds	r11, 0x06CB	; 0x8006cb <settings+0x4c>
        } else {
          set_axis_position = lround(-settings.homing_pulloff*settings.steps_per_mm[idx]);
    261c:	24 01       	movw	r4, r8
    261e:	35 01       	movw	r6, r10
    2620:	77 fa       	bst	r7, 7
    2622:	70 94       	com	r7
    2624:	77 f8       	bld	r7, 7
    2626:	70 94       	com	r7
    2628:	00 e0       	ldi	r16, 0x00	; 0
    262a:	10 e0       	ldi	r17, 0x00	; 0
  // triggering when hard limits are enabled or when more than one axes shares a limit pin.
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
    262c:	c1 01       	movw	r24, r2
    262e:	00 2e       	mov	r0, r16
    2630:	02 c0       	rjmp	.+4      	; 0x2636 <limits_go_home+0x32e>
    2632:	95 95       	asr	r25
    2634:	87 95       	ror	r24
    2636:	0a 94       	dec	r0
    2638:	e2 f7       	brpl	.-8      	; 0x2632 <limits_go_home+0x32a>
    263a:	80 ff       	sbrs	r24, 0
    263c:	36 c0       	rjmp	.+108    	; 0x26aa <limits_go_home+0x3a2>
      #ifdef HOMING_FORCE_SET_ORIGIN
        set_axis_position = 0;
      #else 
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    263e:	c7 01       	movw	r24, r14
    2640:	00 2e       	mov	r0, r16
    2642:	02 c0       	rjmp	.+4      	; 0x2648 <limits_go_home+0x340>
    2644:	95 95       	asr	r25
    2646:	87 95       	ror	r24
    2648:	0a 94       	dec	r0
    264a:	e2 f7       	brpl	.-8      	; 0x2644 <limits_go_home+0x33c>
    264c:	80 ff       	sbrs	r24, 0
    264e:	15 c0       	rjmp	.+42     	; 0x267a <limits_go_home+0x372>
          set_axis_position = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
    2650:	ee 89       	ldd	r30, Y+22	; 0x16
    2652:	ff 89       	ldd	r31, Y+23	; 0x17
    2654:	24 a1       	ldd	r18, Z+36	; 0x24
    2656:	35 a1       	ldd	r19, Z+37	; 0x25
    2658:	46 a1       	ldd	r20, Z+38	; 0x26
    265a:	57 a1       	ldd	r21, Z+39	; 0x27
    265c:	c5 01       	movw	r24, r10
    265e:	b4 01       	movw	r22, r8
    2660:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    2664:	ae 89       	ldd	r26, Y+22	; 0x16
    2666:	bf 89       	ldd	r27, Y+23	; 0x17
    2668:	2d 91       	ld	r18, X+
    266a:	3d 91       	ld	r19, X+
    266c:	4d 91       	ld	r20, X+
    266e:	5c 91       	ld	r21, X
    2670:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2674:	0e 94 ce 3b 	call	0x779c	; 0x779c <lround>
    2678:	0c c0       	rjmp	.+24     	; 0x2692 <limits_go_home+0x38a>
        } else {
          set_axis_position = lround(-settings.homing_pulloff*settings.steps_per_mm[idx]);
    267a:	ee 89       	ldd	r30, Y+22	; 0x16
    267c:	ff 89       	ldd	r31, Y+23	; 0x17
    267e:	20 81       	ld	r18, Z
    2680:	31 81       	ldd	r19, Z+1	; 0x01
    2682:	42 81       	ldd	r20, Z+2	; 0x02
    2684:	53 81       	ldd	r21, Z+3	; 0x03
    2686:	c3 01       	movw	r24, r6
    2688:	b2 01       	movw	r22, r4
    268a:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    268e:	0e 94 ce 3b 	call	0x779c	; 0x779c <lround>
          sys.position[B_MOTOR] = off_axis_position - set_axis_position;
        } else {
          sys.position[idx] = set_axis_position;
        }        
      #else 
        sys.position[idx] = set_axis_position;
    2692:	d6 01       	movw	r26, r12
    2694:	14 96       	adiw	r26, 0x04	; 4
    2696:	6c 93       	st	X, r22
    2698:	14 97       	sbiw	r26, 0x04	; 4
    269a:	15 96       	adiw	r26, 0x05	; 5
    269c:	7c 93       	st	X, r23
    269e:	15 97       	sbiw	r26, 0x05	; 5
    26a0:	16 96       	adiw	r26, 0x06	; 6
    26a2:	8c 93       	st	X, r24
    26a4:	16 97       	sbiw	r26, 0x06	; 6
    26a6:	17 96       	adiw	r26, 0x07	; 7
    26a8:	9c 93       	st	X, r25
    26aa:	0f 5f       	subi	r16, 0xFF	; 255
    26ac:	1f 4f       	sbci	r17, 0xFF	; 255
    26ae:	b4 e0       	ldi	r27, 0x04	; 4
    26b0:	cb 0e       	add	r12, r27
    26b2:	d1 1c       	adc	r13, r1
    26b4:	ee 89       	ldd	r30, Y+22	; 0x16
    26b6:	ff 89       	ldd	r31, Y+23	; 0x17
    26b8:	34 96       	adiw	r30, 0x04	; 4
    26ba:	ff 8b       	std	Y+23, r31	; 0x17
    26bc:	ee 8b       	std	Y+22, r30	; 0x16
  // set up pull-off maneuver from axes limit switches that have been homed. This provides
  // some initial clearance off the switches and should also help prevent them from falsely
  // triggering when hard limits are enabled or when more than one axes shares a limit pin.
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    26be:	03 30       	cpi	r16, 0x03	; 3
    26c0:	11 05       	cpc	r17, r1
    26c2:	09 f0       	breq	.+2      	; 0x26c6 <limits_go_home+0x3be>
    26c4:	b3 cf       	rjmp	.-154    	; 0x262c <limits_go_home+0x324>
        sys.position[idx] = set_axis_position;
      #endif

    }
  }
  plan_sync_position(); // Sync planner position to homed machine position.
    26c6:	0e 94 96 1e 	call	0x3d2c	; 0x3d2c <plan_sync_position>
    26ca:	05 c0       	rjmp	.+10     	; 0x26d6 <limits_go_home+0x3ce>
      // Exit routines: No time to run protocol_execute_realtime() in this loop.
      if (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_STOP)) {
        // Homing failure: Limit switches are still engaged after pull-off motion
        if ( (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET)) ||  // Safety door or reset issued
           (!approach && (limits_get_state() & cycle_mask)) ||  // Limit switch still engaged after pull-off motion
           ( approach && (sys_rt_exec_state & EXEC_CYCLE_STOP)) ) { // Limit switch not found during approach.
    26cc:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    26d0:	82 ff       	sbrs	r24, 2
    26d2:	4f cf       	rjmp	.-354    	; 0x2572 <limits_go_home+0x26a>
    26d4:	49 cf       	rjmp	.-366    	; 0x2568 <limits_go_home+0x260>
    }
  }
  plan_sync_position(); // Sync planner position to homed machine position.
    
  // sys.state = STATE_HOMING; // Ensure system state set as homing before returning. 
}
    26d6:	6a 96       	adiw	r28, 0x1a	; 26
    26d8:	0f b6       	in	r0, 0x3f	; 63
    26da:	f8 94       	cli
    26dc:	de bf       	out	0x3e, r29	; 62
    26de:	0f be       	out	0x3f, r0	; 63
    26e0:	cd bf       	out	0x3d, r28	; 61
    26e2:	df 91       	pop	r29
    26e4:	cf 91       	pop	r28
    26e6:	1f 91       	pop	r17
    26e8:	0f 91       	pop	r16
    26ea:	ff 90       	pop	r15
    26ec:	ef 90       	pop	r14
    26ee:	df 90       	pop	r13
    26f0:	cf 90       	pop	r12
    26f2:	bf 90       	pop	r11
    26f4:	af 90       	pop	r10
    26f6:	9f 90       	pop	r9
    26f8:	8f 90       	pop	r8
    26fa:	7f 90       	pop	r7
    26fc:	6f 90       	pop	r6
    26fe:	5f 90       	pop	r5
    2700:	4f 90       	pop	r4
    2702:	3f 90       	pop	r3
    2704:	2f 90       	pop	r2
    2706:	08 95       	ret

00002708 <limits_soft_check>:


// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
void limits_soft_check(float *target)
{
    2708:	9f 92       	push	r9
    270a:	af 92       	push	r10
    270c:	bf 92       	push	r11
    270e:	cf 92       	push	r12
    2710:	df 92       	push	r13
    2712:	ef 92       	push	r14
    2714:	ff 92       	push	r15
    2716:	0f 93       	push	r16
    2718:	1f 93       	push	r17
    271a:	cf 93       	push	r28
    271c:	df 93       	push	r29
    #else  
      // NOTE: max_travel is stored as negative
      if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { sys.soft_limit = true; }
    #endif
    
    if (sys.soft_limit) {
    271e:	90 90 a3 05 	lds	r9, 0x05A3	; 0x8005a3 <sys+0x3>
    2722:	ec 01       	movw	r28, r24
    2724:	0f 2e       	mov	r0, r31
    2726:	f3 ea       	ldi	r31, 0xA3	; 163
    2728:	af 2e       	mov	r10, r31
    272a:	f6 e0       	ldi	r31, 0x06	; 6
    272c:	bf 2e       	mov	r11, r31
    272e:	f0 2d       	mov	r31, r0
    2730:	8c 01       	movw	r16, r24
    2732:	04 5f       	subi	r16, 0xF4	; 244
    2734:	1f 4f       	sbci	r17, 0xFF	; 255
      } else {
        if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { sys.soft_limit = true; }
      }
    #else  
      // NOTE: max_travel is stored as negative
      if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { sys.soft_limit = true; }
    2736:	c9 90       	ld	r12, Y+
    2738:	d9 90       	ld	r13, Y+
    273a:	e9 90       	ld	r14, Y+
    273c:	f9 90       	ld	r15, Y+
    273e:	20 e0       	ldi	r18, 0x00	; 0
    2740:	30 e0       	ldi	r19, 0x00	; 0
    2742:	a9 01       	movw	r20, r18
    2744:	c7 01       	movw	r24, r14
    2746:	b6 01       	movw	r22, r12
    2748:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    274c:	18 16       	cp	r1, r24
    274e:	64 f0       	brlt	.+24     	; 0x2768 <limits_soft_check+0x60>
    2750:	f5 01       	movw	r30, r10
    2752:	21 91       	ld	r18, Z+
    2754:	31 91       	ld	r19, Z+
    2756:	41 91       	ld	r20, Z+
    2758:	51 91       	ld	r21, Z+
    275a:	5f 01       	movw	r10, r30
    275c:	c7 01       	movw	r24, r14
    275e:	b6 01       	movw	r22, r12
    2760:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    2764:	88 23       	and	r24, r24
    2766:	24 f4       	brge	.+8      	; 0x2770 <limits_soft_check+0x68>
    2768:	81 e0       	ldi	r24, 0x01	; 1
    276a:	80 93 a3 05 	sts	0x05A3, r24	; 0x8005a3 <sys+0x3>
    276e:	02 c0       	rjmp	.+4      	; 0x2774 <limits_soft_check+0x6c>
    #endif
    
    if (sys.soft_limit) {
    2770:	99 20       	and	r9, r9
    2772:	19 f1       	breq	.+70     	; 0x27ba <limits_soft_check+0xb2>
      // Force feed hold if cycle is active. All buffered blocks are guaranteed to be within 
      // workspace volume so just come to a controlled stop so position is not lost. When complete
      // enter alarm mode.
      if (sys.state == STATE_CYCLE) {
    2774:	80 91 a1 05 	lds	r24, 0x05A1	; 0x8005a1 <sys+0x1>
    2778:	88 30       	cpi	r24, 0x08	; 8
    277a:	91 f4       	brne	.+36     	; 0x27a0 <limits_soft_check+0x98>
        bit_true_atomic(sys_rt_exec_state, EXEC_FEED_HOLD);
    277c:	9f b7       	in	r25, 0x3f	; 63
    277e:	f8 94       	cli
    2780:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    2784:	88 60       	ori	r24, 0x08	; 8
    2786:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <sys_rt_exec_state>
    278a:	9f bf       	out	0x3f, r25	; 63
        do {
          protocol_execute_realtime();
          if (sys.abort) { return; }
    278c:	c0 ea       	ldi	r28, 0xA0	; 160
    278e:	d5 e0       	ldi	r29, 0x05	; 5
      // workspace volume so just come to a controlled stop so position is not lost. When complete
      // enter alarm mode.
      if (sys.state == STATE_CYCLE) {
        bit_true_atomic(sys_rt_exec_state, EXEC_FEED_HOLD);
        do {
          protocol_execute_realtime();
    2790:	0e 94 46 20 	call	0x408c	; 0x408c <protocol_execute_realtime>
          if (sys.abort) { return; }
    2794:	88 81       	ld	r24, Y
    2796:	81 11       	cpse	r24, r1
    2798:	14 c0       	rjmp	.+40     	; 0x27c2 <limits_soft_check+0xba>
        } while ( sys.state != STATE_IDLE );
    279a:	89 81       	ldd	r24, Y+1	; 0x01
    279c:	81 11       	cpse	r24, r1
    279e:	f8 cf       	rjmp	.-16     	; 0x2790 <limits_soft_check+0x88>
      }
    
      mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
    27a0:	0e 94 36 18 	call	0x306c	; 0x306c <mc_reset>
      bit_true_atomic(sys_rt_exec_alarm, (EXEC_ALARM_SOFT_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate soft limit critical event
    27a4:	9f b7       	in	r25, 0x3f	; 63
    27a6:	f8 94       	cli
    27a8:	80 91 27 05 	lds	r24, 0x0527	; 0x800527 <sys_rt_exec_alarm>
    27ac:	85 60       	ori	r24, 0x05	; 5
    27ae:	80 93 27 05 	sts	0x0527, r24	; 0x800527 <sys_rt_exec_alarm>
    27b2:	9f bf       	out	0x3f, r25	; 63
      protocol_execute_realtime(); // Execute to enter critical event loop and system abort
    27b4:	0e 94 46 20 	call	0x408c	; 0x408c <protocol_execute_realtime>
      return;
    27b8:	04 c0       	rjmp	.+8      	; 0x27c2 <limits_soft_check+0xba>
// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
void limits_soft_check(float *target)
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    27ba:	c0 17       	cp	r28, r16
    27bc:	d1 07       	cpc	r29, r17
    27be:	09 f0       	breq	.+2      	; 0x27c2 <limits_soft_check+0xba>
    27c0:	ba cf       	rjmp	.-140    	; 0x2736 <limits_soft_check+0x2e>
      bit_true_atomic(sys_rt_exec_alarm, (EXEC_ALARM_SOFT_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate soft limit critical event
      protocol_execute_realtime(); // Execute to enter critical event loop and system abort
      return;
    }
  }
}
    27c2:	df 91       	pop	r29
    27c4:	cf 91       	pop	r28
    27c6:	1f 91       	pop	r17
    27c8:	0f 91       	pop	r16
    27ca:	ff 90       	pop	r15
    27cc:	ef 90       	pop	r14
    27ce:	df 90       	pop	r13
    27d0:	cf 90       	pop	r12
    27d2:	bf 90       	pop	r11
    27d4:	af 90       	pop	r10
    27d6:	9f 90       	pop	r9
    27d8:	08 95       	ret

000027da <main>:


int main(void)
{
  // Initialize system upon power-up.
  serial_init();   // Setup serial baud rate and interrupts
    27da:	0e 94 0c 28 	call	0x5018	; 0x5018 <serial_init>
  settings_init(); // Load Grbl settings from EEPROM
    27de:	0e 94 90 2b 	call	0x5720	; 0x5720 <settings_init>
  stepper_init();  // Configure stepper pins and interrupt timers
    27e2:	0e 94 e9 2e 	call	0x5dd2	; 0x5dd2 <stepper_init>
  system_init();   // Configure pinout pins and pin-change interrupt
    27e6:	0e 94 12 36 	call	0x6c24	; 0x6c24 <system_init>
  
  memset(&sys, 0, sizeof(system_t));  // Clear all system variables
    27ea:	e0 ea       	ldi	r30, 0xA0	; 160
    27ec:	f5 e0       	ldi	r31, 0x05	; 5
    27ee:	8e e1       	ldi	r24, 0x1E	; 30
    27f0:	df 01       	movw	r26, r30
    27f2:	1d 92       	st	X+, r1
    27f4:	8a 95       	dec	r24
    27f6:	e9 f7       	brne	.-6      	; 0x27f2 <main+0x18>
  sys.abort = true;   // Set abort to complete initialization
    27f8:	81 e0       	ldi	r24, 0x01	; 1
    27fa:	80 83       	st	Z, r24
  sei(); // Enable interrupts
    27fc:	78 94       	sei
  // cycle '$H' or kill alarm locks '$X' will disable the alarm.
  // NOTE: The startup script will run after successful completion of the homing cycle, but
  // not after disabling the alarm locks. Prevents motion startup blocks from crashing into
  // things uncontrollably. Very bad.
  #ifdef HOMING_INIT_LOCK
    if (bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) { sys.state = STATE_ALARM; }
    27fe:	80 91 bc 06 	lds	r24, 0x06BC	; 0x8006bc <settings+0x3d>
    2802:	84 ff       	sbrs	r24, 4
    2804:	03 c0       	rjmp	.+6      	; 0x280c <main+0x32>
    2806:	81 e0       	ldi	r24, 0x01	; 1
    2808:	80 93 a1 05 	sts	0x05A1, r24	; 0x8005a1 <sys+0x1>
    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
    gc_sync_position();

    // Reset system variables.
    sys.abort = false;
    280c:	c0 ea       	ldi	r28, 0xA0	; 160
    280e:	d5 e0       	ldi	r29, 0x05	; 5

    // TODO: Separate configure task that require interrupts to be disabled, especially upon
    // a system abort and ensuring any active interrupts are cleanly reset.
  
    // Reset Grbl primary systems.
    serial_reset_read_buffer(); // Clear serial read buffer
    2810:	0e 94 e5 28 	call	0x51ca	; 0x51ca <serial_reset_read_buffer>
    gc_init(); // Set g-code parser to default state
    2814:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <gc_init>
    spindle_init();
    2818:	0e 94 c1 2b 	call	0x5782	; 0x5782 <spindle_init>
    coolant_init();
    281c:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <coolant_init>
    limits_init(); 
    2820:	0e 94 06 11 	call	0x220c	; 0x220c <limits_init>
    probe_init();
    2824:	0e 94 12 20 	call	0x4024	; 0x4024 <probe_init>
    plan_reset(); // Clear block buffer and planner variables
    2828:	0e 94 cf 1a 	call	0x359e	; 0x359e <plan_reset>
    st_reset(); // Clear stepper subsystem variables.
    282c:	0e 94 bd 2e 	call	0x5d7a	; 0x5d7a <st_reset>

    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
    2830:	0e 94 96 1e 	call	0x3d2c	; 0x3d2c <plan_sync_position>
    gc_sync_position();
    2834:	0e 94 04 06 	call	0xc08	; 0xc08 <gc_sync_position>

    // Reset system variables.
    sys.abort = false;
    2838:	18 82       	st	Y, r1
    sys_rt_exec_state = 0;
    283a:	10 92 25 05 	sts	0x0525, r1	; 0x800525 <sys_rt_exec_state>
    sys_rt_exec_alarm = 0;
    283e:	10 92 27 05 	sts	0x0527, r1	; 0x800527 <sys_rt_exec_alarm>
    sys.suspend = false;
    2842:	1a 82       	std	Y+2, r1	; 0x02
    sys.soft_limit = false;
    2844:	1b 82       	std	Y+3, r1	; 0x03
              
    // Start Grbl main loop. Processes program inputs and executes them.
    protocol_main_loop();
    2846:	0e 94 7d 21 	call	0x42fa	; 0x42fa <protocol_main_loop>
    284a:	e2 cf       	rjmp	.-60     	; 0x2810 <main+0x36>

0000284c <mc_line>:
#ifdef USE_LINE_NUMBERS
  void mc_line(float *target, float feed_rate, uint8_t invert_feed_rate, int32_t line_number)
#else
  void mc_line(float *target, float feed_rate, uint8_t invert_feed_rate)
#endif
{
    284c:	bf 92       	push	r11
    284e:	cf 92       	push	r12
    2850:	df 92       	push	r13
    2852:	ef 92       	push	r14
    2854:	ff 92       	push	r15
    2856:	0f 93       	push	r16
    2858:	1f 93       	push	r17
    285a:	cf 93       	push	r28
    285c:	df 93       	push	r29
    285e:	8c 01       	movw	r16, r24
    2860:	6a 01       	movw	r12, r20
    2862:	7b 01       	movw	r14, r22
    2864:	b2 2e       	mov	r11, r18
  // If enabled, check for soft limit violations. Placed here all line motions are picked up
  // from everywhere in Grbl.
  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) { limits_soft_check(target); }    
    2866:	80 91 bc 06 	lds	r24, 0x06BC	; 0x8006bc <settings+0x3d>
    286a:	85 ff       	sbrs	r24, 5
    286c:	03 c0       	rjmp	.+6      	; 0x2874 <mc_line+0x28>
    286e:	c8 01       	movw	r24, r16
    2870:	0e 94 84 13 	call	0x2708	; 0x2708 <limits_soft_check>
      
  // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
  if (sys.state == STATE_CHECK_MODE) { return; }
    2874:	80 91 a1 05 	lds	r24, 0x05A1	; 0x8005a1 <sys+0x1>
    2878:	82 30       	cpi	r24, 0x02	; 2
    287a:	a1 f0       	breq	.+40     	; 0x28a4 <mc_line+0x58>

  // If the buffer is full: good! That means we are well ahead of the robot. 
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
    if (sys.abort) { return; } // Bail, if system abort.
    287c:	c0 ea       	ldi	r28, 0xA0	; 160
    287e:	d5 e0       	ldi	r29, 0x05	; 5
  // parser and planner are separate from the system machine positions, this is doable.

  // If the buffer is full: good! That means we are well ahead of the robot. 
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
    2880:	0e 94 46 20 	call	0x408c	; 0x408c <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail, if system abort.
    2884:	88 81       	ld	r24, Y
    2886:	81 11       	cpse	r24, r1
    2888:	0d c0       	rjmp	.+26     	; 0x28a4 <mc_line+0x58>
    if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffer is full.
    288a:	0e 94 1f 1b 	call	0x363e	; 0x363e <plan_check_full_buffer>
    288e:	88 23       	and	r24, r24
    2890:	19 f0       	breq	.+6      	; 0x2898 <mc_line+0x4c>
    2892:	0e 94 74 21 	call	0x42e8	; 0x42e8 <protocol_auto_cycle_start>
    else { break; }
  } while (1);
    2896:	f4 cf       	rjmp	.-24     	; 0x2880 <mc_line+0x34>

  // Plan and queue motion into planner buffer
  #ifdef USE_LINE_NUMBERS
    plan_buffer_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    plan_buffer_line(target, feed_rate, invert_feed_rate);
    2898:	2b 2d       	mov	r18, r11
    289a:	b7 01       	movw	r22, r14
    289c:	a6 01       	movw	r20, r12
    289e:	c8 01       	movw	r24, r16
    28a0:	0e 94 27 1b 	call	0x364e	; 0x364e <plan_buffer_line>
  #endif
}
    28a4:	df 91       	pop	r29
    28a6:	cf 91       	pop	r28
    28a8:	1f 91       	pop	r17
    28aa:	0f 91       	pop	r16
    28ac:	ff 90       	pop	r15
    28ae:	ef 90       	pop	r14
    28b0:	df 90       	pop	r13
    28b2:	cf 90       	pop	r12
    28b4:	bf 90       	pop	r11
    28b6:	08 95       	ret

000028b8 <mc_arc>:
    uint8_t invert_feed_rate, uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc, int32_t line_number)
#else
  void mc_arc(float *position, float *target, float *offset, float radius, float feed_rate,
    uint8_t invert_feed_rate, uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc)
#endif
{
    28b8:	2f 92       	push	r2
    28ba:	3f 92       	push	r3
    28bc:	4f 92       	push	r4
    28be:	5f 92       	push	r5
    28c0:	6f 92       	push	r6
    28c2:	7f 92       	push	r7
    28c4:	8f 92       	push	r8
    28c6:	9f 92       	push	r9
    28c8:	af 92       	push	r10
    28ca:	bf 92       	push	r11
    28cc:	cf 92       	push	r12
    28ce:	df 92       	push	r13
    28d0:	ef 92       	push	r14
    28d2:	ff 92       	push	r15
    28d4:	0f 93       	push	r16
    28d6:	1f 93       	push	r17
    28d8:	cf 93       	push	r28
    28da:	df 93       	push	r29
    28dc:	cd b7       	in	r28, 0x3d	; 61
    28de:	de b7       	in	r29, 0x3e	; 62
    28e0:	e4 97       	sbiw	r28, 0x34	; 52
    28e2:	0f b6       	in	r0, 0x3f	; 63
    28e4:	f8 94       	cli
    28e6:	de bf       	out	0x3e, r29	; 62
    28e8:	0f be       	out	0x3f, r0	; 63
    28ea:	cd bf       	out	0x3d, r28	; 61
    28ec:	9e 87       	std	Y+14, r25	; 0x0e
    28ee:	8d 87       	std	Y+13, r24	; 0x0d
    28f0:	7c ab       	std	Y+52, r23	; 0x34
    28f2:	6b ab       	std	Y+51, r22	; 0x33
    28f4:	3a 01       	movw	r6, r20
    28f6:	0d 83       	std	Y+5, r16	; 0x05
    28f8:	1e 83       	std	Y+6, r17	; 0x06
    28fa:	2f 83       	std	Y+7, r18	; 0x07
    28fc:	38 87       	std	Y+8, r19	; 0x08
    28fe:	cf 86       	std	Y+15, r12	; 0x0f
    2900:	d8 8a       	std	Y+16, r13	; 0x10
    2902:	e9 8a       	std	Y+17, r14	; 0x11
    2904:	fa 8a       	std	Y+18, r15	; 0x12
    2906:	0a 2d       	mov	r16, r10
  float center_axis0 = position[axis_0] + offset[axis_0];
    2908:	91 2c       	mov	r9, r1
    290a:	88 0c       	add	r8, r8
    290c:	99 1c       	adc	r9, r9
    290e:	88 0c       	add	r8, r8
    2910:	99 1c       	adc	r9, r9
    2912:	88 0d       	add	r24, r8
    2914:	99 1d       	adc	r25, r9
    2916:	9c 8b       	std	Y+20, r25	; 0x14
    2918:	8b 8b       	std	Y+19, r24	; 0x13
    291a:	ca 01       	movw	r24, r20
    291c:	88 0d       	add	r24, r8
    291e:	99 1d       	adc	r25, r9
    2920:	98 ab       	std	Y+48, r25	; 0x30
    2922:	8f a7       	std	Y+47, r24	; 0x2f
    2924:	dc 01       	movw	r26, r24
    2926:	2d 90       	ld	r2, X+
    2928:	3d 90       	ld	r3, X+
    292a:	4d 90       	ld	r4, X+
    292c:	5c 90       	ld	r5, X
    292e:	eb 89       	ldd	r30, Y+19	; 0x13
    2930:	fc 89       	ldd	r31, Y+20	; 0x14
    2932:	20 81       	ld	r18, Z
    2934:	31 81       	ldd	r19, Z+1	; 0x01
    2936:	42 81       	ldd	r20, Z+2	; 0x02
    2938:	53 81       	ldd	r21, Z+3	; 0x03
    293a:	c2 01       	movw	r24, r4
    293c:	b1 01       	movw	r22, r2
    293e:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    2942:	6d 8b       	std	Y+21, r22	; 0x15
    2944:	7e 8b       	std	Y+22, r23	; 0x16
    2946:	8f 8b       	std	Y+23, r24	; 0x17
    2948:	98 8f       	std	Y+24, r25	; 0x18
  float center_axis1 = position[axis_1] + offset[axis_1];
    294a:	2a 96       	adiw	r28, 0x0a	; 10
    294c:	af ac       	ldd	r10, Y+63	; 0x3f
    294e:	2a 97       	sbiw	r28, 0x0a	; 10
    2950:	b1 2c       	mov	r11, r1
    2952:	aa 0c       	add	r10, r10
    2954:	bb 1c       	adc	r11, r11
    2956:	aa 0c       	add	r10, r10
    2958:	bb 1c       	adc	r11, r11
    295a:	8d 85       	ldd	r24, Y+13	; 0x0d
    295c:	9e 85       	ldd	r25, Y+14	; 0x0e
    295e:	8a 0d       	add	r24, r10
    2960:	9b 1d       	adc	r25, r11
    2962:	9a 8f       	std	Y+26, r25	; 0x1a
    2964:	89 8f       	std	Y+25, r24	; 0x19
    2966:	d3 01       	movw	r26, r6
    2968:	aa 0d       	add	r26, r10
    296a:	bb 1d       	adc	r27, r11
    296c:	ba ab       	std	Y+50, r27	; 0x32
    296e:	a9 ab       	std	Y+49, r26	; 0x31
    2970:	cd 90       	ld	r12, X+
    2972:	dd 90       	ld	r13, X+
    2974:	ed 90       	ld	r14, X+
    2976:	fc 90       	ld	r15, X
    2978:	fc 01       	movw	r30, r24
    297a:	20 81       	ld	r18, Z
    297c:	31 81       	ldd	r19, Z+1	; 0x01
    297e:	42 81       	ldd	r20, Z+2	; 0x02
    2980:	53 81       	ldd	r21, Z+3	; 0x03
    2982:	c7 01       	movw	r24, r14
    2984:	b6 01       	movw	r22, r12
    2986:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    298a:	6b 8f       	std	Y+27, r22	; 0x1b
    298c:	7c 8f       	std	Y+28, r23	; 0x1c
    298e:	8d 8f       	std	Y+29, r24	; 0x1d
    2990:	9e 8f       	std	Y+30, r25	; 0x1e
  float r_axis0 = -offset[axis_0];  // Radius vector from center to current location
    2992:	d2 01       	movw	r26, r4
    2994:	c1 01       	movw	r24, r2
    2996:	b0 58       	subi	r27, 0x80	; 128
    2998:	89 83       	std	Y+1, r24	; 0x01
    299a:	9a 83       	std	Y+2, r25	; 0x02
    299c:	ab 83       	std	Y+3, r26	; 0x03
    299e:	bc 83       	std	Y+4, r27	; 0x04
  float r_axis1 = -offset[axis_1];
    29a0:	d7 01       	movw	r26, r14
    29a2:	c6 01       	movw	r24, r12
    29a4:	b0 58       	subi	r27, 0x80	; 128
    29a6:	89 87       	std	Y+9, r24	; 0x09
    29a8:	9a 87       	std	Y+10, r25	; 0x0a
    29aa:	ab 87       	std	Y+11, r26	; 0x0b
    29ac:	bc 87       	std	Y+12, r27	; 0x0c
  float rt_axis0 = target[axis_0] - center_axis0;
    29ae:	eb a9       	ldd	r30, Y+51	; 0x33
    29b0:	fc a9       	ldd	r31, Y+52	; 0x34
    29b2:	e8 0d       	add	r30, r8
    29b4:	f9 1d       	adc	r31, r9
    29b6:	2d 89       	ldd	r18, Y+21	; 0x15
    29b8:	3e 89       	ldd	r19, Y+22	; 0x16
    29ba:	4f 89       	ldd	r20, Y+23	; 0x17
    29bc:	58 8d       	ldd	r21, Y+24	; 0x18
    29be:	60 81       	ld	r22, Z
    29c0:	71 81       	ldd	r23, Z+1	; 0x01
    29c2:	82 81       	ldd	r24, Z+2	; 0x02
    29c4:	93 81       	ldd	r25, Z+3	; 0x03
    29c6:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    29ca:	6b 01       	movw	r12, r22
    29cc:	7c 01       	movw	r14, r24
  float rt_axis1 = target[axis_1] - center_axis1;
    29ce:	eb a9       	ldd	r30, Y+51	; 0x33
    29d0:	fc a9       	ldd	r31, Y+52	; 0x34
    29d2:	ea 0d       	add	r30, r10
    29d4:	fb 1d       	adc	r31, r11
    29d6:	2b 8d       	ldd	r18, Y+27	; 0x1b
    29d8:	3c 8d       	ldd	r19, Y+28	; 0x1c
    29da:	4d 8d       	ldd	r20, Y+29	; 0x1d
    29dc:	5e 8d       	ldd	r21, Y+30	; 0x1e
    29de:	60 81       	ld	r22, Z
    29e0:	71 81       	ldd	r23, Z+1	; 0x01
    29e2:	82 81       	ldd	r24, Z+2	; 0x02
    29e4:	93 81       	ldd	r25, Z+3	; 0x03
    29e6:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    29ea:	4b 01       	movw	r8, r22
    29ec:	5c 01       	movw	r10, r24
  
  // CCW angle between position and target from circle center. Only one atan2() trig computation required.
  float angular_travel = atan2(r_axis0*rt_axis1-r_axis1*rt_axis0, r_axis0*rt_axis0+r_axis1*rt_axis1);
    29ee:	a7 01       	movw	r20, r14
    29f0:	96 01       	movw	r18, r12
    29f2:	69 81       	ldd	r22, Y+1	; 0x01
    29f4:	7a 81       	ldd	r23, Y+2	; 0x02
    29f6:	8b 81       	ldd	r24, Y+3	; 0x03
    29f8:	9c 81       	ldd	r25, Y+4	; 0x04
    29fa:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    29fe:	2b 01       	movw	r4, r22
    2a00:	3c 01       	movw	r6, r24
    2a02:	a5 01       	movw	r20, r10
    2a04:	94 01       	movw	r18, r8
    2a06:	69 85       	ldd	r22, Y+9	; 0x09
    2a08:	7a 85       	ldd	r23, Y+10	; 0x0a
    2a0a:	8b 85       	ldd	r24, Y+11	; 0x0b
    2a0c:	9c 85       	ldd	r25, Y+12	; 0x0c
    2a0e:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2a12:	9b 01       	movw	r18, r22
    2a14:	ac 01       	movw	r20, r24
    2a16:	c3 01       	movw	r24, r6
    2a18:	b2 01       	movw	r22, r4
    2a1a:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    2a1e:	2b 01       	movw	r4, r22
    2a20:	3c 01       	movw	r6, r24
    2a22:	a5 01       	movw	r20, r10
    2a24:	94 01       	movw	r18, r8
    2a26:	69 81       	ldd	r22, Y+1	; 0x01
    2a28:	7a 81       	ldd	r23, Y+2	; 0x02
    2a2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a2e:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2a32:	4b 01       	movw	r8, r22
    2a34:	5c 01       	movw	r10, r24
    2a36:	a7 01       	movw	r20, r14
    2a38:	96 01       	movw	r18, r12
    2a3a:	69 85       	ldd	r22, Y+9	; 0x09
    2a3c:	7a 85       	ldd	r23, Y+10	; 0x0a
    2a3e:	8b 85       	ldd	r24, Y+11	; 0x0b
    2a40:	9c 85       	ldd	r25, Y+12	; 0x0c
    2a42:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2a46:	9b 01       	movw	r18, r22
    2a48:	ac 01       	movw	r20, r24
    2a4a:	c5 01       	movw	r24, r10
    2a4c:	b4 01       	movw	r22, r8
    2a4e:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    2a52:	a3 01       	movw	r20, r6
    2a54:	92 01       	movw	r18, r4
    2a56:	0e 94 29 39 	call	0x7252	; 0x7252 <atan2>
    2a5a:	4b 01       	movw	r8, r22
    2a5c:	5c 01       	movw	r10, r24
  if (is_clockwise_arc) { // Correct atan2 output per direction
    2a5e:	2c 96       	adiw	r28, 0x0c	; 12
    2a60:	8f ad       	ldd	r24, Y+63	; 0x3f
    2a62:	2c 97       	sbiw	r28, 0x0c	; 12
    2a64:	88 23       	and	r24, r24
    2a66:	a9 f0       	breq	.+42     	; 0x2a92 <mc_arc+0x1da>
    if (angular_travel >= -ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel -= 2*M_PI; }
    2a68:	2d eb       	ldi	r18, 0xBD	; 189
    2a6a:	37 e3       	ldi	r19, 0x37	; 55
    2a6c:	46 e0       	ldi	r20, 0x06	; 6
    2a6e:	55 eb       	ldi	r21, 0xB5	; 181
    2a70:	c5 01       	movw	r24, r10
    2a72:	b4 01       	movw	r22, r8
    2a74:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    2a78:	88 23       	and	r24, r24
    2a7a:	fc f0       	brlt	.+62     	; 0x2aba <mc_arc+0x202>
    2a7c:	2b ed       	ldi	r18, 0xDB	; 219
    2a7e:	3f e0       	ldi	r19, 0x0F	; 15
    2a80:	49 ec       	ldi	r20, 0xC9	; 201
    2a82:	50 e4       	ldi	r21, 0x40	; 64
    2a84:	c5 01       	movw	r24, r10
    2a86:	b4 01       	movw	r22, r8
    2a88:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    2a8c:	4b 01       	movw	r8, r22
    2a8e:	5c 01       	movw	r10, r24
    2a90:	14 c0       	rjmp	.+40     	; 0x2aba <mc_arc+0x202>
  } else {
    if (angular_travel <= ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel += 2*M_PI; }
    2a92:	2d eb       	ldi	r18, 0xBD	; 189
    2a94:	37 e3       	ldi	r19, 0x37	; 55
    2a96:	46 e0       	ldi	r20, 0x06	; 6
    2a98:	55 e3       	ldi	r21, 0x35	; 53
    2a9a:	c5 01       	movw	r24, r10
    2a9c:	b4 01       	movw	r22, r8
    2a9e:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    2aa2:	18 16       	cp	r1, r24
    2aa4:	54 f0       	brlt	.+20     	; 0x2aba <mc_arc+0x202>
    2aa6:	2b ed       	ldi	r18, 0xDB	; 219
    2aa8:	3f e0       	ldi	r19, 0x0F	; 15
    2aaa:	49 ec       	ldi	r20, 0xC9	; 201
    2aac:	50 e4       	ldi	r21, 0x40	; 64
    2aae:	c5 01       	movw	r24, r10
    2ab0:	b4 01       	movw	r22, r8
    2ab2:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    2ab6:	4b 01       	movw	r8, r22
    2ab8:	5c 01       	movw	r10, r24
  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
    2aba:	c0 90 b8 06 	lds	r12, 0x06B8	; 0x8006b8 <settings+0x39>
    2abe:	d0 90 b9 06 	lds	r13, 0x06B9	; 0x8006b9 <settings+0x3a>
    2ac2:	e0 90 ba 06 	lds	r14, 0x06BA	; 0x8006ba <settings+0x3b>
    2ac6:	f0 90 bb 06 	lds	r15, 0x06BB	; 0x8006bb <settings+0x3c>
    2aca:	2d 81       	ldd	r18, Y+5	; 0x05
    2acc:	3e 81       	ldd	r19, Y+6	; 0x06
    2ace:	4f 81       	ldd	r20, Y+7	; 0x07
    2ad0:	58 85       	ldd	r21, Y+8	; 0x08
    2ad2:	ca 01       	movw	r24, r20
    2ad4:	b9 01       	movw	r22, r18
    2ad6:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    2ada:	2b 01       	movw	r4, r22
    2adc:	3c 01       	movw	r6, r24
    2ade:	a7 01       	movw	r20, r14
    2ae0:	96 01       	movw	r18, r12
    2ae2:	c3 01       	movw	r24, r6
    2ae4:	b2 01       	movw	r22, r4
    2ae6:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    2aea:	a7 01       	movw	r20, r14
    2aec:	96 01       	movw	r18, r12
    2aee:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2af2:	0e 94 a0 3c 	call	0x7940	; 0x7940 <sqrt>
    2af6:	6b 01       	movw	r12, r22
    2af8:	7c 01       	movw	r14, r24

  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
    2afa:	20 e0       	ldi	r18, 0x00	; 0
    2afc:	30 e0       	ldi	r19, 0x00	; 0
    2afe:	40 e0       	ldi	r20, 0x00	; 0
    2b00:	5f e3       	ldi	r21, 0x3F	; 63
    2b02:	c5 01       	movw	r24, r10
    2b04:	b4 01       	movw	r22, r8
    2b06:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2b0a:	2d 81       	ldd	r18, Y+5	; 0x05
    2b0c:	3e 81       	ldd	r19, Y+6	; 0x06
    2b0e:	4f 81       	ldd	r20, Y+7	; 0x07
    2b10:	58 85       	ldd	r21, Y+8	; 0x08
    2b12:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2b16:	9f 77       	andi	r25, 0x7F	; 127
    2b18:	a7 01       	movw	r20, r14
    2b1a:	96 01       	movw	r18, r12
    2b1c:	0e 94 a9 39 	call	0x7352	; 0x7352 <__divsf3>
    2b20:	0e 94 8e 3a 	call	0x751c	; 0x751c <floor>
    2b24:	0e 94 22 3a 	call	0x7444	; 0x7444 <__fixunssfsi>
    2b28:	6b 01       	movw	r12, r22
    2b2a:	7c 01       	movw	r14, r24
    2b2c:	3b 01       	movw	r6, r22
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
  
  if (segments) { 
    2b2e:	61 15       	cp	r22, r1
    2b30:	71 05       	cpc	r23, r1
    2b32:	09 f4       	brne	.+2      	; 0x2b36 <mc_arc+0x27e>
    2b34:	81 c1       	rjmp	.+770    	; 0x2e38 <mc_arc+0x580>
    // Multiply inverse feed_rate to compensate for the fact that this movement is approximated
    // by a number of discrete segments. The inverse feed_rate should be correct for the sum of 
    // all segments.
    if (invert_feed_rate) { feed_rate *= segments; }
    2b36:	00 23       	and	r16, r16
    2b38:	81 f0       	breq	.+32     	; 0x2b5a <mc_arc+0x2a2>
    2b3a:	80 e0       	ldi	r24, 0x00	; 0
    2b3c:	90 e0       	ldi	r25, 0x00	; 0
    2b3e:	0e 94 51 3a 	call	0x74a2	; 0x74a2 <__floatunsisf>
    2b42:	9b 01       	movw	r18, r22
    2b44:	ac 01       	movw	r20, r24
    2b46:	6f 85       	ldd	r22, Y+15	; 0x0f
    2b48:	78 89       	ldd	r23, Y+16	; 0x10
    2b4a:	89 89       	ldd	r24, Y+17	; 0x11
    2b4c:	9a 89       	ldd	r25, Y+18	; 0x12
    2b4e:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2b52:	6f 87       	std	Y+15, r22	; 0x0f
    2b54:	78 8b       	std	Y+16, r23	; 0x10
    2b56:	89 8b       	std	Y+17, r24	; 0x11
    2b58:	9a 8b       	std	Y+18, r25	; 0x12
   
    float theta_per_segment = angular_travel/segments;
    2b5a:	b6 01       	movw	r22, r12
    2b5c:	80 e0       	ldi	r24, 0x00	; 0
    2b5e:	90 e0       	ldi	r25, 0x00	; 0
    2b60:	0e 94 51 3a 	call	0x74a2	; 0x74a2 <__floatunsisf>
    2b64:	6b 01       	movw	r12, r22
    2b66:	7c 01       	movw	r14, r24
    2b68:	9b 01       	movw	r18, r22
    2b6a:	ac 01       	movw	r20, r24
    2b6c:	c5 01       	movw	r24, r10
    2b6e:	b4 01       	movw	r22, r8
    2b70:	0e 94 a9 39 	call	0x7352	; 0x7352 <__divsf3>
    2b74:	6b a7       	std	Y+43, r22	; 0x2b
    2b76:	7c a7       	std	Y+44, r23	; 0x2c
    2b78:	8d a7       	std	Y+45, r24	; 0x2d
    2b7a:	9e a7       	std	Y+46, r25	; 0x2e
    float linear_per_segment = (target[axis_linear] - position[axis_linear])/segments;
    2b7c:	2b 96       	adiw	r28, 0x0b	; 11
    2b7e:	8f ad       	ldd	r24, Y+63	; 0x3f
    2b80:	2b 97       	sbiw	r28, 0x0b	; 11
    2b82:	90 e0       	ldi	r25, 0x00	; 0
    2b84:	88 0f       	add	r24, r24
    2b86:	99 1f       	adc	r25, r25
    2b88:	88 0f       	add	r24, r24
    2b8a:	99 1f       	adc	r25, r25
    2b8c:	4d 84       	ldd	r4, Y+13	; 0x0d
    2b8e:	5e 84       	ldd	r5, Y+14	; 0x0e
    2b90:	48 0e       	add	r4, r24
    2b92:	59 1e       	adc	r5, r25
    2b94:	eb a9       	ldd	r30, Y+51	; 0x33
    2b96:	fc a9       	ldd	r31, Y+52	; 0x34
    2b98:	e8 0f       	add	r30, r24
    2b9a:	f9 1f       	adc	r31, r25
    2b9c:	d2 01       	movw	r26, r4
    2b9e:	2d 91       	ld	r18, X+
    2ba0:	3d 91       	ld	r19, X+
    2ba2:	4d 91       	ld	r20, X+
    2ba4:	5c 91       	ld	r21, X
    2ba6:	60 81       	ld	r22, Z
    2ba8:	71 81       	ldd	r23, Z+1	; 0x01
    2baa:	82 81       	ldd	r24, Z+2	; 0x02
    2bac:	93 81       	ldd	r25, Z+3	; 0x03
    2bae:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    2bb2:	a7 01       	movw	r20, r14
    2bb4:	96 01       	movw	r18, r12
    2bb6:	0e 94 a9 39 	call	0x7352	; 0x7352 <__divsf3>
    2bba:	6f 8f       	std	Y+31, r22	; 0x1f
    2bbc:	78 a3       	std	Y+32, r23	; 0x20
    2bbe:	89 a3       	std	Y+33, r24	; 0x21
    2bc0:	9a a3       	std	Y+34, r25	; 0x22
       without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
       a correction, the planner should have caught up to the lag caused by the initial mc_arc overhead. 
       This is important when there are successive arc motions. 
    */
    // Computes: cos_T = 1 - theta_per_segment^2/2, sin_T = theta_per_segment - theta_per_segment^3/6) in ~52usec
    float cos_T = 2.0 - theta_per_segment*theta_per_segment;
    2bc2:	2b a5       	ldd	r18, Y+43	; 0x2b
    2bc4:	3c a5       	ldd	r19, Y+44	; 0x2c
    2bc6:	4d a5       	ldd	r20, Y+45	; 0x2d
    2bc8:	5e a5       	ldd	r21, Y+46	; 0x2e
    2bca:	ca 01       	movw	r24, r20
    2bcc:	b9 01       	movw	r22, r18
    2bce:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2bd2:	9b 01       	movw	r18, r22
    2bd4:	ac 01       	movw	r20, r24
    2bd6:	60 e0       	ldi	r22, 0x00	; 0
    2bd8:	70 e0       	ldi	r23, 0x00	; 0
    2bda:	80 e0       	ldi	r24, 0x00	; 0
    2bdc:	90 e4       	ldi	r25, 0x40	; 64
    2bde:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    2be2:	6b 01       	movw	r12, r22
    2be4:	7c 01       	movw	r14, r24
    float sin_T = theta_per_segment*0.16666667*(cos_T + 4.0);
    2be6:	2b ea       	ldi	r18, 0xAB	; 171
    2be8:	3a ea       	ldi	r19, 0xAA	; 170
    2bea:	4a e2       	ldi	r20, 0x2A	; 42
    2bec:	5e e3       	ldi	r21, 0x3E	; 62
    2bee:	6b a5       	ldd	r22, Y+43	; 0x2b
    2bf0:	7c a5       	ldd	r23, Y+44	; 0x2c
    2bf2:	8d a5       	ldd	r24, Y+45	; 0x2d
    2bf4:	9e a5       	ldd	r25, Y+46	; 0x2e
    2bf6:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2bfa:	4b 01       	movw	r8, r22
    2bfc:	5c 01       	movw	r10, r24
    2bfe:	20 e0       	ldi	r18, 0x00	; 0
    2c00:	30 e0       	ldi	r19, 0x00	; 0
    2c02:	40 e8       	ldi	r20, 0x80	; 128
    2c04:	50 e4       	ldi	r21, 0x40	; 64
    2c06:	c7 01       	movw	r24, r14
    2c08:	b6 01       	movw	r22, r12
    2c0a:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    2c0e:	9b 01       	movw	r18, r22
    2c10:	ac 01       	movw	r20, r24
    2c12:	c5 01       	movw	r24, r10
    2c14:	b4 01       	movw	r22, r8
    2c16:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2c1a:	6b a3       	std	Y+35, r22	; 0x23
    2c1c:	7c a3       	std	Y+36, r23	; 0x24
    2c1e:	8d a3       	std	Y+37, r24	; 0x25
    2c20:	9e a3       	std	Y+38, r25	; 0x26
    cos_T *= 0.5;
    2c22:	20 e0       	ldi	r18, 0x00	; 0
    2c24:	30 e0       	ldi	r19, 0x00	; 0
    2c26:	40 e0       	ldi	r20, 0x00	; 0
    2c28:	5f e3       	ldi	r21, 0x3F	; 63
    2c2a:	c7 01       	movw	r24, r14
    2c2c:	b6 01       	movw	r22, r12
    2c2e:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2c32:	6f a3       	std	Y+39, r22	; 0x27
    2c34:	78 a7       	std	Y+40, r23	; 0x28
    2c36:	89 a7       	std	Y+41, r24	; 0x29
    2c38:	9a a7       	std	Y+42, r25	; 0x2a
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
    2c3a:	b2 e0       	ldi	r27, 0x02	; 2
    2c3c:	6b 16       	cp	r6, r27
    2c3e:	71 04       	cpc	r7, r1
    2c40:	08 f4       	brcc	.+2      	; 0x2c44 <mc_arc+0x38c>
    2c42:	fa c0       	rjmp	.+500    	; 0x2e38 <mc_arc+0x580>
    2c44:	10 e0       	ldi	r17, 0x00	; 0
    2c46:	22 24       	eor	r2, r2
    2c48:	23 94       	inc	r2
    2c4a:	31 2c       	mov	r3, r1
      #else
        mc_line(position, feed_rate, invert_feed_rate);
      #endif
      
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
    2c4c:	c9 84       	ldd	r12, Y+9	; 0x09
    2c4e:	da 84       	ldd	r13, Y+10	; 0x0a
    2c50:	eb 84       	ldd	r14, Y+11	; 0x0b
    2c52:	fc 84       	ldd	r15, Y+12	; 0x0c
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
      
      if (count < N_ARC_CORRECTION) {
    2c54:	1c 30       	cpi	r17, 0x0C	; 12
    2c56:	08 f0       	brcs	.+2      	; 0x2c5a <mc_arc+0x3a2>
    2c58:	44 c0       	rjmp	.+136    	; 0x2ce2 <mc_arc+0x42a>
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
    2c5a:	a7 01       	movw	r20, r14
    2c5c:	96 01       	movw	r18, r12
    2c5e:	6f a1       	ldd	r22, Y+39	; 0x27
    2c60:	78 a5       	ldd	r23, Y+40	; 0x28
    2c62:	89 a5       	ldd	r24, Y+41	; 0x29
    2c64:	9a a5       	ldd	r25, Y+42	; 0x2a
    2c66:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2c6a:	4b 01       	movw	r8, r22
    2c6c:	5c 01       	movw	r10, r24
    2c6e:	29 81       	ldd	r18, Y+1	; 0x01
    2c70:	3a 81       	ldd	r19, Y+2	; 0x02
    2c72:	4b 81       	ldd	r20, Y+3	; 0x03
    2c74:	5c 81       	ldd	r21, Y+4	; 0x04
    2c76:	6b a1       	ldd	r22, Y+35	; 0x23
    2c78:	7c a1       	ldd	r23, Y+36	; 0x24
    2c7a:	8d a1       	ldd	r24, Y+37	; 0x25
    2c7c:	9e a1       	ldd	r25, Y+38	; 0x26
    2c7e:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2c82:	a5 01       	movw	r20, r10
    2c84:	94 01       	movw	r18, r8
    2c86:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    2c8a:	86 2e       	mov	r8, r22
    2c8c:	97 2e       	mov	r9, r23
    2c8e:	a8 2e       	mov	r10, r24
    2c90:	b9 2e       	mov	r11, r25
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
    2c92:	29 81       	ldd	r18, Y+1	; 0x01
    2c94:	3a 81       	ldd	r19, Y+2	; 0x02
    2c96:	4b 81       	ldd	r20, Y+3	; 0x03
    2c98:	5c 81       	ldd	r21, Y+4	; 0x04
    2c9a:	6f a1       	ldd	r22, Y+39	; 0x27
    2c9c:	78 a5       	ldd	r23, Y+40	; 0x28
    2c9e:	89 a5       	ldd	r24, Y+41	; 0x29
    2ca0:	9a a5       	ldd	r25, Y+42	; 0x2a
    2ca2:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2ca6:	69 83       	std	Y+1, r22	; 0x01
    2ca8:	7a 83       	std	Y+2, r23	; 0x02
    2caa:	8b 83       	std	Y+3, r24	; 0x03
    2cac:	9c 83       	std	Y+4, r25	; 0x04
    2cae:	a7 01       	movw	r20, r14
    2cb0:	96 01       	movw	r18, r12
    2cb2:	6b a1       	ldd	r22, Y+35	; 0x23
    2cb4:	7c a1       	ldd	r23, Y+36	; 0x24
    2cb6:	8d a1       	ldd	r24, Y+37	; 0x25
    2cb8:	9e a1       	ldd	r25, Y+38	; 0x26
    2cba:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2cbe:	9b 01       	movw	r18, r22
    2cc0:	ac 01       	movw	r20, r24
    2cc2:	69 81       	ldd	r22, Y+1	; 0x01
    2cc4:	7a 81       	ldd	r23, Y+2	; 0x02
    2cc6:	8b 81       	ldd	r24, Y+3	; 0x03
    2cc8:	9c 81       	ldd	r25, Y+4	; 0x04
    2cca:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    2cce:	69 83       	std	Y+1, r22	; 0x01
    2cd0:	7a 83       	std	Y+2, r23	; 0x02
    2cd2:	8b 83       	std	Y+3, r24	; 0x03
    2cd4:	9c 83       	std	Y+4, r25	; 0x04
        r_axis1 = r_axisi;
        count++;
    2cd6:	1f 5f       	subi	r17, 0xFF	; 255
      
      if (count < N_ARC_CORRECTION) {
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
        r_axis1 = r_axisi;
    2cd8:	c8 2c       	mov	r12, r8
    2cda:	d9 2c       	mov	r13, r9
    2cdc:	ea 2c       	mov	r14, r10
    2cde:	fb 2c       	mov	r15, r11
    2ce0:	66 c0       	rjmp	.+204    	; 0x2dae <mc_arc+0x4f6>
        count++;
      } else {      
        // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments. ~375 usec
        // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
        cos_Ti = cos(i*theta_per_segment);
    2ce2:	b1 01       	movw	r22, r2
    2ce4:	80 e0       	ldi	r24, 0x00	; 0
    2ce6:	90 e0       	ldi	r25, 0x00	; 0
    2ce8:	0e 94 51 3a 	call	0x74a2	; 0x74a2 <__floatunsisf>
    2cec:	2b a5       	ldd	r18, Y+43	; 0x2b
    2cee:	3c a5       	ldd	r19, Y+44	; 0x2c
    2cf0:	4d a5       	ldd	r20, Y+45	; 0x2d
    2cf2:	5e a5       	ldd	r21, Y+46	; 0x2e
    2cf4:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2cf8:	6b 01       	movw	r12, r22
    2cfa:	7c 01       	movw	r14, r24
    2cfc:	0e 94 a4 39 	call	0x7348	; 0x7348 <cos>
    2d00:	6d 83       	std	Y+5, r22	; 0x05
    2d02:	7e 83       	std	Y+6, r23	; 0x06
    2d04:	8f 83       	std	Y+7, r24	; 0x07
    2d06:	98 87       	std	Y+8, r25	; 0x08
        sin_Ti = sin(i*theta_per_segment);
    2d08:	c7 01       	movw	r24, r14
    2d0a:	b6 01       	movw	r22, r12
    2d0c:	0e 94 92 3c 	call	0x7924	; 0x7924 <sin>
    2d10:	69 87       	std	Y+9, r22	; 0x09
    2d12:	7a 87       	std	Y+10, r23	; 0x0a
    2d14:	8b 87       	std	Y+11, r24	; 0x0b
    2d16:	9c 87       	std	Y+12, r25	; 0x0c
        r_axis0 = -offset[axis_0]*cos_Ti + offset[axis_1]*sin_Ti;
    2d18:	ef a5       	ldd	r30, Y+47	; 0x2f
    2d1a:	f8 a9       	ldd	r31, Y+48	; 0x30
    2d1c:	c0 80       	ld	r12, Z
    2d1e:	d1 80       	ldd	r13, Z+1	; 0x01
    2d20:	e2 80       	ldd	r14, Z+2	; 0x02
    2d22:	f3 80       	ldd	r15, Z+3	; 0x03
    2d24:	f7 fa       	bst	r15, 7
    2d26:	f0 94       	com	r15
    2d28:	f7 f8       	bld	r15, 7
    2d2a:	f0 94       	com	r15
    2d2c:	a9 a9       	ldd	r26, Y+49	; 0x31
    2d2e:	ba a9       	ldd	r27, Y+50	; 0x32
    2d30:	8d 90       	ld	r8, X+
    2d32:	9d 90       	ld	r9, X+
    2d34:	ad 90       	ld	r10, X+
    2d36:	bc 90       	ld	r11, X
    2d38:	a7 01       	movw	r20, r14
    2d3a:	96 01       	movw	r18, r12
    2d3c:	6d 81       	ldd	r22, Y+5	; 0x05
    2d3e:	7e 81       	ldd	r23, Y+6	; 0x06
    2d40:	8f 81       	ldd	r24, Y+7	; 0x07
    2d42:	98 85       	ldd	r25, Y+8	; 0x08
    2d44:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2d48:	69 83       	std	Y+1, r22	; 0x01
    2d4a:	7a 83       	std	Y+2, r23	; 0x02
    2d4c:	8b 83       	std	Y+3, r24	; 0x03
    2d4e:	9c 83       	std	Y+4, r25	; 0x04
    2d50:	a5 01       	movw	r20, r10
    2d52:	94 01       	movw	r18, r8
    2d54:	69 85       	ldd	r22, Y+9	; 0x09
    2d56:	7a 85       	ldd	r23, Y+10	; 0x0a
    2d58:	8b 85       	ldd	r24, Y+11	; 0x0b
    2d5a:	9c 85       	ldd	r25, Y+12	; 0x0c
    2d5c:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2d60:	9b 01       	movw	r18, r22
    2d62:	ac 01       	movw	r20, r24
    2d64:	69 81       	ldd	r22, Y+1	; 0x01
    2d66:	7a 81       	ldd	r23, Y+2	; 0x02
    2d68:	8b 81       	ldd	r24, Y+3	; 0x03
    2d6a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d6c:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    2d70:	69 83       	std	Y+1, r22	; 0x01
    2d72:	7a 83       	std	Y+2, r23	; 0x02
    2d74:	8b 83       	std	Y+3, r24	; 0x03
    2d76:	9c 83       	std	Y+4, r25	; 0x04
        r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;
    2d78:	a7 01       	movw	r20, r14
    2d7a:	96 01       	movw	r18, r12
    2d7c:	69 85       	ldd	r22, Y+9	; 0x09
    2d7e:	7a 85       	ldd	r23, Y+10	; 0x0a
    2d80:	8b 85       	ldd	r24, Y+11	; 0x0b
    2d82:	9c 85       	ldd	r25, Y+12	; 0x0c
    2d84:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2d88:	6b 01       	movw	r12, r22
    2d8a:	7c 01       	movw	r14, r24
    2d8c:	a5 01       	movw	r20, r10
    2d8e:	94 01       	movw	r18, r8
    2d90:	6d 81       	ldd	r22, Y+5	; 0x05
    2d92:	7e 81       	ldd	r23, Y+6	; 0x06
    2d94:	8f 81       	ldd	r24, Y+7	; 0x07
    2d96:	98 85       	ldd	r25, Y+8	; 0x08
    2d98:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2d9c:	9b 01       	movw	r18, r22
    2d9e:	ac 01       	movw	r20, r24
    2da0:	c7 01       	movw	r24, r14
    2da2:	b6 01       	movw	r22, r12
    2da4:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    2da8:	6b 01       	movw	r12, r22
    2daa:	7c 01       	movw	r14, r24
        count = 0;
    2dac:	10 e0       	ldi	r17, 0x00	; 0
      }
  
      // Update arc_target location
      position[axis_0] = center_axis0 + r_axis0;
    2dae:	2d 89       	ldd	r18, Y+21	; 0x15
    2db0:	3e 89       	ldd	r19, Y+22	; 0x16
    2db2:	4f 89       	ldd	r20, Y+23	; 0x17
    2db4:	58 8d       	ldd	r21, Y+24	; 0x18
    2db6:	69 81       	ldd	r22, Y+1	; 0x01
    2db8:	7a 81       	ldd	r23, Y+2	; 0x02
    2dba:	8b 81       	ldd	r24, Y+3	; 0x03
    2dbc:	9c 81       	ldd	r25, Y+4	; 0x04
    2dbe:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    2dc2:	eb 89       	ldd	r30, Y+19	; 0x13
    2dc4:	fc 89       	ldd	r31, Y+20	; 0x14
    2dc6:	60 83       	st	Z, r22
    2dc8:	71 83       	std	Z+1, r23	; 0x01
    2dca:	82 83       	std	Z+2, r24	; 0x02
    2dcc:	93 83       	std	Z+3, r25	; 0x03
      position[axis_1] = center_axis1 + r_axis1;
    2dce:	2b 8d       	ldd	r18, Y+27	; 0x1b
    2dd0:	3c 8d       	ldd	r19, Y+28	; 0x1c
    2dd2:	4d 8d       	ldd	r20, Y+29	; 0x1d
    2dd4:	5e 8d       	ldd	r21, Y+30	; 0x1e
    2dd6:	c7 01       	movw	r24, r14
    2dd8:	b6 01       	movw	r22, r12
    2dda:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    2dde:	a9 8d       	ldd	r26, Y+25	; 0x19
    2de0:	ba 8d       	ldd	r27, Y+26	; 0x1a
    2de2:	6d 93       	st	X+, r22
    2de4:	7d 93       	st	X+, r23
    2de6:	8d 93       	st	X+, r24
    2de8:	9c 93       	st	X, r25
    2dea:	13 97       	sbiw	r26, 0x03	; 3
      position[axis_linear] += linear_per_segment;
    2dec:	2f 8d       	ldd	r18, Y+31	; 0x1f
    2dee:	38 a1       	ldd	r19, Y+32	; 0x20
    2df0:	49 a1       	ldd	r20, Y+33	; 0x21
    2df2:	5a a1       	ldd	r21, Y+34	; 0x22
    2df4:	f2 01       	movw	r30, r4
    2df6:	60 81       	ld	r22, Z
    2df8:	71 81       	ldd	r23, Z+1	; 0x01
    2dfa:	82 81       	ldd	r24, Z+2	; 0x02
    2dfc:	93 81       	ldd	r25, Z+3	; 0x03
    2dfe:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    2e02:	d2 01       	movw	r26, r4
    2e04:	6d 93       	st	X+, r22
    2e06:	7d 93       	st	X+, r23
    2e08:	8d 93       	st	X+, r24
    2e0a:	9c 93       	st	X, r25
    2e0c:	13 97       	sbiw	r26, 0x03	; 3
      
      #ifdef USE_LINE_NUMBERS
        mc_line(position, feed_rate, invert_feed_rate, line_number);
      #else
        mc_line(position, feed_rate, invert_feed_rate);
    2e0e:	20 2f       	mov	r18, r16
    2e10:	4f 85       	ldd	r20, Y+15	; 0x0f
    2e12:	58 89       	ldd	r21, Y+16	; 0x10
    2e14:	69 89       	ldd	r22, Y+17	; 0x11
    2e16:	7a 89       	ldd	r23, Y+18	; 0x12
    2e18:	8d 85       	ldd	r24, Y+13	; 0x0d
    2e1a:	9e 85       	ldd	r25, Y+14	; 0x0e
    2e1c:	0e 94 26 14 	call	0x284c	; 0x284c <mc_line>
      #endif
      
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
    2e20:	e0 ea       	ldi	r30, 0xA0	; 160
    2e22:	f5 e0       	ldi	r31, 0x05	; 5
    2e24:	80 81       	ld	r24, Z
    2e26:	81 11       	cpse	r24, r1
    2e28:	10 c0       	rjmp	.+32     	; 0x2e4a <mc_arc+0x592>
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
    2e2a:	ff ef       	ldi	r31, 0xFF	; 255
    2e2c:	2f 1a       	sub	r2, r31
    2e2e:	3f 0a       	sbc	r3, r31
    2e30:	62 14       	cp	r6, r2
    2e32:	73 04       	cpc	r7, r3
    2e34:	09 f0       	breq	.+2      	; 0x2e38 <mc_arc+0x580>
    2e36:	0e cf       	rjmp	.-484    	; 0x2c54 <mc_arc+0x39c>
  }
  // Ensure last segment arrives at target location.
  #ifdef USE_LINE_NUMBERS
    mc_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    mc_line(target, feed_rate, invert_feed_rate);
    2e38:	20 2f       	mov	r18, r16
    2e3a:	4f 85       	ldd	r20, Y+15	; 0x0f
    2e3c:	58 89       	ldd	r21, Y+16	; 0x10
    2e3e:	69 89       	ldd	r22, Y+17	; 0x11
    2e40:	7a 89       	ldd	r23, Y+18	; 0x12
    2e42:	8b a9       	ldd	r24, Y+51	; 0x33
    2e44:	9c a9       	ldd	r25, Y+52	; 0x34
    2e46:	0e 94 26 14 	call	0x284c	; 0x284c <mc_line>
  #endif
}
    2e4a:	e4 96       	adiw	r28, 0x34	; 52
    2e4c:	0f b6       	in	r0, 0x3f	; 63
    2e4e:	f8 94       	cli
    2e50:	de bf       	out	0x3e, r29	; 62
    2e52:	0f be       	out	0x3f, r0	; 63
    2e54:	cd bf       	out	0x3d, r28	; 61
    2e56:	df 91       	pop	r29
    2e58:	cf 91       	pop	r28
    2e5a:	1f 91       	pop	r17
    2e5c:	0f 91       	pop	r16
    2e5e:	ff 90       	pop	r15
    2e60:	ef 90       	pop	r14
    2e62:	df 90       	pop	r13
    2e64:	cf 90       	pop	r12
    2e66:	bf 90       	pop	r11
    2e68:	af 90       	pop	r10
    2e6a:	9f 90       	pop	r9
    2e6c:	8f 90       	pop	r8
    2e6e:	7f 90       	pop	r7
    2e70:	6f 90       	pop	r6
    2e72:	5f 90       	pop	r5
    2e74:	4f 90       	pop	r4
    2e76:	3f 90       	pop	r3
    2e78:	2f 90       	pop	r2
    2e7a:	08 95       	ret

00002e7c <mc_dwell>:


// Execute dwell in seconds.
void mc_dwell(float seconds) 
{
    2e7c:	8f 92       	push	r8
    2e7e:	9f 92       	push	r9
    2e80:	af 92       	push	r10
    2e82:	bf 92       	push	r11
    2e84:	cf 92       	push	r12
    2e86:	df 92       	push	r13
    2e88:	ef 92       	push	r14
    2e8a:	ff 92       	push	r15
    2e8c:	cf 93       	push	r28
    2e8e:	df 93       	push	r29
   if (sys.state == STATE_CHECK_MODE) { return; }
    2e90:	20 91 a1 05 	lds	r18, 0x05A1	; 0x8005a1 <sys+0x1>
    2e94:	22 30       	cpi	r18, 0x02	; 2
    2e96:	09 f4       	brne	.+2      	; 0x2e9a <mc_dwell+0x1e>
    2e98:	48 c0       	rjmp	.+144    	; 0x2f2a <mc_dwell+0xae>
    2e9a:	4b 01       	movw	r8, r22
    2e9c:	5c 01       	movw	r10, r24
   
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
    2e9e:	20 e0       	ldi	r18, 0x00	; 0
    2ea0:	30 e0       	ldi	r19, 0x00	; 0
    2ea2:	40 ea       	ldi	r20, 0xA0	; 160
    2ea4:	51 e4       	ldi	r21, 0x41	; 65
    2ea6:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2eaa:	0e 94 8e 3a 	call	0x751c	; 0x751c <floor>
    2eae:	0e 94 22 3a 	call	0x7444	; 0x7444 <__fixunssfsi>
    2eb2:	6b 01       	movw	r12, r22
    2eb4:	7c 01       	movw	r14, r24
    2eb6:	eb 01       	movw	r28, r22
   protocol_buffer_synchronize();
    2eb8:	0e 94 2a 22 	call	0x4454	; 0x4454 <protocol_buffer_synchronize>
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
    2ebc:	20 e0       	ldi	r18, 0x00	; 0
    2ebe:	30 e0       	ldi	r19, 0x00	; 0
    2ec0:	4a e7       	ldi	r20, 0x7A	; 122
    2ec2:	54 e4       	ldi	r21, 0x44	; 68
    2ec4:	c5 01       	movw	r24, r10
    2ec6:	b4 01       	movw	r22, r8
    2ec8:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    2ecc:	4b 01       	movw	r8, r22
    2ece:	5c 01       	movw	r10, r24
    2ed0:	82 e3       	ldi	r24, 0x32	; 50
    2ed2:	8c 9d       	mul	r24, r12
    2ed4:	b0 01       	movw	r22, r0
    2ed6:	8d 9d       	mul	r24, r13
    2ed8:	70 0d       	add	r23, r0
    2eda:	11 24       	eor	r1, r1
    2edc:	80 e0       	ldi	r24, 0x00	; 0
    2ede:	90 e0       	ldi	r25, 0x00	; 0
    2ee0:	0e 94 51 3a 	call	0x74a2	; 0x74a2 <__floatunsisf>
    2ee4:	9b 01       	movw	r18, r22
    2ee6:	ac 01       	movw	r20, r24
    2ee8:	c5 01       	movw	r24, r10
    2eea:	b4 01       	movw	r22, r8
    2eec:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    2ef0:	0e 94 8e 3a 	call	0x751c	; 0x751c <floor>
    2ef4:	0e 94 22 3a 	call	0x7444	; 0x7444 <__fixunssfsi>
    2ef8:	cb 01       	movw	r24, r22
    2efa:	0e 94 2b 19 	call	0x3256	; 0x3256 <delay_ms>
   while (i-- > 0) {
    2efe:	cd 2b       	or	r28, r29
    2f00:	a1 f0       	breq	.+40     	; 0x2f2a <mc_dwell+0xae>
     // NOTE: Check and execute realtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_realtime();
     if (sys.abort) { return; }
    2f02:	c0 ea       	ldi	r28, 0xA0	; 160
    2f04:	d5 e0       	ldi	r29, 0x05	; 5
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
   protocol_buffer_synchronize();
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
   while (i-- > 0) {
     // NOTE: Check and execute realtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_realtime();
    2f06:	0e 94 46 20 	call	0x408c	; 0x408c <protocol_execute_realtime>
     if (sys.abort) { return; }
    2f0a:	88 81       	ld	r24, Y
    2f0c:	81 11       	cpse	r24, r1
    2f0e:	0d c0       	rjmp	.+26     	; 0x2f2a <mc_dwell+0xae>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2f10:	2f ef       	ldi	r18, 0xFF	; 255
    2f12:	80 e7       	ldi	r24, 0x70	; 112
    2f14:	92 e0       	ldi	r25, 0x02	; 2
    2f16:	21 50       	subi	r18, 0x01	; 1
    2f18:	80 40       	sbci	r24, 0x00	; 0
    2f1a:	90 40       	sbci	r25, 0x00	; 0
    2f1c:	e1 f7       	brne	.-8      	; 0x2f16 <mc_dwell+0x9a>
    2f1e:	00 c0       	rjmp	.+0      	; 0x2f20 <mc_dwell+0xa4>
    2f20:	00 00       	nop
    2f22:	21 e0       	ldi	r18, 0x01	; 1
    2f24:	c2 1a       	sub	r12, r18
    2f26:	d1 08       	sbc	r13, r1
   if (sys.state == STATE_CHECK_MODE) { return; }
   
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
   protocol_buffer_synchronize();
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
   while (i-- > 0) {
    2f28:	71 f7       	brne	.-36     	; 0x2f06 <mc_dwell+0x8a>
     // NOTE: Check and execute realtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_realtime();
     if (sys.abort) { return; }
     _delay_ms(DWELL_TIME_STEP); // Delay DWELL_TIME_STEP increment
   }
}
    2f2a:	df 91       	pop	r29
    2f2c:	cf 91       	pop	r28
    2f2e:	ff 90       	pop	r15
    2f30:	ef 90       	pop	r14
    2f32:	df 90       	pop	r13
    2f34:	cf 90       	pop	r12
    2f36:	bf 90       	pop	r11
    2f38:	af 90       	pop	r10
    2f3a:	9f 90       	pop	r9
    2f3c:	8f 90       	pop	r8
    2f3e:	08 95       	ret

00002f40 <mc_homing_cycle>:
      bit_true_atomic(sys_rt_exec_alarm, (EXEC_ALARM_HARD_LIMIT|EXEC_CRITICAL_EVENT));
      return;
    }
  #endif
   
  limits_disable(); // Disable hard limits pin change register for cycle duration
    2f40:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <limits_disable>
    
  // -------------------------------------------------------------------------------------
  // Perform homing routine. NOTE: Special motion case. Only system reset works.
  
  // Search to engage all axes limit switches at faster homing seek rate.
  limits_go_home(HOMING_CYCLE_0);  // Homing cycle 0
    2f44:	84 e0       	ldi	r24, 0x04	; 4
    2f46:	0e 94 84 11 	call	0x2308	; 0x2308 <limits_go_home>
  #ifdef HOMING_CYCLE_1
    limits_go_home(HOMING_CYCLE_1);  // Homing cycle 1
    2f4a:	83 e0       	ldi	r24, 0x03	; 3
    2f4c:	0e 94 84 11 	call	0x2308	; 0x2308 <limits_go_home>
  #endif
  #ifdef HOMING_CYCLE_2
    limits_go_home(HOMING_CYCLE_2);  // Homing cycle 2
  #endif
    
  protocol_execute_realtime(); // Check for reset and set system abort.
    2f50:	0e 94 46 20 	call	0x408c	; 0x408c <protocol_execute_realtime>
  if (sys.abort) { return; } // Did not complete. Alarm state set by mc_alarm.
    2f54:	80 91 a0 05 	lds	r24, 0x05A0	; 0x8005a0 <sys>
    2f58:	81 11       	cpse	r24, r1
    2f5a:	04 c0       	rjmp	.+8      	; 0x2f64 <mc_homing_cycle+0x24>

  // Homing cycle complete! Setup system for normal operation.
  // -------------------------------------------------------------------------------------

  // Gcode parser position was circumvented by the limits_go_home() routine, so sync position now.
  gc_sync_position();
    2f5c:	0e 94 04 06 	call	0xc08	; 0xc08 <gc_sync_position>

  // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
  limits_init();
    2f60:	0e 94 06 11 	call	0x220c	; 0x220c <limits_init>
    2f64:	08 95       	ret

00002f66 <mc_probe_cycle>:
    uint8_t is_no_error, int32_t line_number)
#else
  void mc_probe_cycle(float *target, float feed_rate, uint8_t invert_feed_rate, uint8_t is_probe_away,
    uint8_t is_no_error)
#endif
{ 
    2f66:	8f 92       	push	r8
    2f68:	9f 92       	push	r9
    2f6a:	af 92       	push	r10
    2f6c:	bf 92       	push	r11
    2f6e:	cf 92       	push	r12
    2f70:	df 92       	push	r13
    2f72:	ef 92       	push	r14
    2f74:	0f 93       	push	r16
    2f76:	cf 93       	push	r28
    2f78:	df 93       	push	r29
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return; }
    2f7a:	30 91 a1 05 	lds	r19, 0x05A1	; 0x8005a1 <sys+0x1>
    2f7e:	32 30       	cpi	r19, 0x02	; 2
    2f80:	09 f4       	brne	.+2      	; 0x2f84 <mc_probe_cycle+0x1e>
    2f82:	69 c0       	rjmp	.+210    	; 0x3056 <mc_probe_cycle+0xf0>
    2f84:	c2 2f       	mov	r28, r18
    2f86:	4a 01       	movw	r8, r20
    2f88:	5b 01       	movw	r10, r22
    2f8a:	6c 01       	movw	r12, r24

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
    2f8c:	0e 94 2a 22 	call	0x4454	; 0x4454 <protocol_buffer_synchronize>

  // Initialize probing control variables
  sys.probe_succeeded = false; // Re-initialize probe history before beginning cycle.  
    2f90:	10 92 bc 05 	sts	0x05BC, r1	; 0x8005bc <sys+0x1c>
  probe_configure_invert_mask(is_probe_away);
    2f94:	80 2f       	mov	r24, r16
    2f96:	0e 94 15 20 	call	0x402a	; 0x402a <probe_configure_invert_mask>
  
  // After syncing, check if probe is already triggered. If so, halt and issue alarm.
  // NOTE: This probe initialization error applies to all probing cycles.
  if ( probe_get_state() ) { // Check probe pin state.
    2f9a:	0e 94 27 20 	call	0x404e	; 0x404e <probe_get_state>
    2f9e:	88 23       	and	r24, r24
    2fa0:	51 f0       	breq	.+20     	; 0x2fb6 <mc_probe_cycle+0x50>
    bit_true_atomic(sys_rt_exec_alarm, EXEC_ALARM_PROBE_FAIL);
    2fa2:	9f b7       	in	r25, 0x3f	; 63
    2fa4:	f8 94       	cli
    2fa6:	80 91 27 05 	lds	r24, 0x0527	; 0x800527 <sys_rt_exec_alarm>
    2faa:	80 61       	ori	r24, 0x10	; 16
    2fac:	80 93 27 05 	sts	0x0527, r24	; 0x800527 <sys_rt_exec_alarm>
    2fb0:	9f bf       	out	0x3f, r25	; 63
    protocol_execute_realtime();
    2fb2:	0e 94 46 20 	call	0x408c	; 0x408c <protocol_execute_realtime>
  }
  if (sys.abort) { return; } // Return if system reset has been issued.
    2fb6:	80 91 a0 05 	lds	r24, 0x05A0	; 0x8005a0 <sys>
    2fba:	81 11       	cpse	r24, r1
    2fbc:	4c c0       	rjmp	.+152    	; 0x3056 <mc_probe_cycle+0xf0>

  // Setup and queue probing motion. Auto cycle-start should not start the cycle.
  #ifdef USE_LINE_NUMBERS
    mc_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    mc_line(target, feed_rate, invert_feed_rate);
    2fbe:	2c 2f       	mov	r18, r28
    2fc0:	b5 01       	movw	r22, r10
    2fc2:	a4 01       	movw	r20, r8
    2fc4:	c6 01       	movw	r24, r12
    2fc6:	0e 94 26 14 	call	0x284c	; 0x284c <mc_line>
  #endif
  
  // Activate the probing state monitor in the stepper module.
  sys_probe_state = PROBE_ACTIVE;
    2fca:	81 e0       	ldi	r24, 0x01	; 1
    2fcc:	80 93 26 05 	sts	0x0526, r24	; 0x800526 <sys_probe_state>

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
    2fd0:	9f b7       	in	r25, 0x3f	; 63
    2fd2:	f8 94       	cli
    2fd4:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    2fd8:	82 60       	ori	r24, 0x02	; 2
    2fda:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <sys_rt_exec_state>
    2fde:	9f bf       	out	0x3f, r25	; 63
  do {
    protocol_execute_realtime(); 
    if (sys.abort) { return; } // Check for system abort
    2fe0:	c0 ea       	ldi	r28, 0xA0	; 160
    2fe2:	d5 e0       	ldi	r29, 0x05	; 5
  sys_probe_state = PROBE_ACTIVE;

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
  do {
    protocol_execute_realtime(); 
    2fe4:	0e 94 46 20 	call	0x408c	; 0x408c <protocol_execute_realtime>
    if (sys.abort) { return; } // Check for system abort
    2fe8:	98 81       	ld	r25, Y
    2fea:	91 11       	cpse	r25, r1
    2fec:	34 c0       	rjmp	.+104    	; 0x3056 <mc_probe_cycle+0xf0>
  } while (sys.state != STATE_IDLE);
    2fee:	99 81       	ldd	r25, Y+1	; 0x01
    2ff0:	91 11       	cpse	r25, r1
    2ff2:	f8 cf       	rjmp	.-16     	; 0x2fe4 <mc_probe_cycle+0x7e>
  
  // Probing cycle complete!
  
  // Set state variables and error out, if the probe failed and cycle with error is enabled.
  if (sys_probe_state == PROBE_ACTIVE) {
    2ff4:	80 91 26 05 	lds	r24, 0x0526	; 0x800526 <sys_probe_state>
    2ff8:	81 30       	cpi	r24, 0x01	; 1
    2ffa:	a9 f4       	brne	.+42     	; 0x3026 <mc_probe_cycle+0xc0>
    if (is_no_error) { memcpy(sys.probe_position, sys.position, sizeof(float)*N_AXIS); }
    2ffc:	ee 20       	and	r14, r14
    2ffe:	51 f0       	breq	.+20     	; 0x3014 <mc_probe_cycle+0xae>
    3000:	8c e0       	ldi	r24, 0x0C	; 12
    3002:	e4 ea       	ldi	r30, 0xA4	; 164
    3004:	f5 e0       	ldi	r31, 0x05	; 5
    3006:	a0 eb       	ldi	r26, 0xB0	; 176
    3008:	b5 e0       	ldi	r27, 0x05	; 5
    300a:	01 90       	ld	r0, Z+
    300c:	0d 92       	st	X+, r0
    300e:	8a 95       	dec	r24
    3010:	e1 f7       	brne	.-8      	; 0x300a <mc_probe_cycle+0xa4>
    3012:	0c c0       	rjmp	.+24     	; 0x302c <mc_probe_cycle+0xc6>
    else { bit_true_atomic(sys_rt_exec_alarm, EXEC_ALARM_PROBE_FAIL); }
    3014:	9f b7       	in	r25, 0x3f	; 63
    3016:	f8 94       	cli
    3018:	80 91 27 05 	lds	r24, 0x0527	; 0x800527 <sys_rt_exec_alarm>
    301c:	80 61       	ori	r24, 0x10	; 16
    301e:	80 93 27 05 	sts	0x0527, r24	; 0x800527 <sys_rt_exec_alarm>
    3022:	9f bf       	out	0x3f, r25	; 63
    3024:	03 c0       	rjmp	.+6      	; 0x302c <mc_probe_cycle+0xc6>
  } else { 
    sys.probe_succeeded = true; // Indicate to system the probing cycle completed successfully.
    3026:	81 e0       	ldi	r24, 0x01	; 1
    3028:	80 93 bc 05 	sts	0x05BC, r24	; 0x8005bc <sys+0x1c>
  }
  sys_probe_state = PROBE_OFF; // Ensure probe state monitor is disabled.
    302c:	10 92 26 05 	sts	0x0526, r1	; 0x800526 <sys_probe_state>
  protocol_execute_realtime();   // Check and execute run-time commands
    3030:	0e 94 46 20 	call	0x408c	; 0x408c <protocol_execute_realtime>
  if (sys.abort) { return; } // Check for system abort
    3034:	80 91 a0 05 	lds	r24, 0x05A0	; 0x8005a0 <sys>
    3038:	81 11       	cpse	r24, r1
    303a:	0d c0       	rjmp	.+26     	; 0x3056 <mc_probe_cycle+0xf0>

  // Reset the stepper and planner buffers to remove the remainder of the probe motion.
  st_reset(); // Reest step segment buffer.
    303c:	0e 94 bd 2e 	call	0x5d7a	; 0x5d7a <st_reset>
  plan_reset(); // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
    3040:	0e 94 cf 1a 	call	0x359e	; 0x359e <plan_reset>
  plan_sync_position(); // Sync planner position to current machine position.
    3044:	0e 94 96 1e 	call	0x3d2c	; 0x3d2c <plan_sync_position>

  // TODO: Update the g-code parser code to not require this target calculation but uses a gc_sync_position() call.
  // NOTE: The target[] variable updated here will be sent back and synced with the g-code parser.
  system_convert_array_steps_to_mpos(target, sys.position);
    3048:	64 ea       	ldi	r22, 0xA4	; 164
    304a:	75 e0       	ldi	r23, 0x05	; 5
    304c:	c6 01       	movw	r24, r12
    304e:	0e 94 8e 38 	call	0x711c	; 0x711c <system_convert_array_steps_to_mpos>

  #ifdef MESSAGE_PROBE_COORDINATES
    // All done! Output the probe position as message.
    report_probe_parameters();
    3052:	0e 94 43 25 	call	0x4a86	; 0x4a86 <report_probe_parameters>
  #endif
}
    3056:	df 91       	pop	r29
    3058:	cf 91       	pop	r28
    305a:	0f 91       	pop	r16
    305c:	ef 90       	pop	r14
    305e:	df 90       	pop	r13
    3060:	cf 90       	pop	r12
    3062:	bf 90       	pop	r11
    3064:	af 90       	pop	r10
    3066:	9f 90       	pop	r9
    3068:	8f 90       	pop	r8
    306a:	08 95       	ret

0000306c <mc_reset>:
// lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
// realtime abort command and hard limits. So, keep to a minimum.
void mc_reset()
{
  // Only this function can set the system reset. Helps prevent multiple kill calls.
  if (bit_isfalse(sys_rt_exec_state, EXEC_RESET)) {
    306c:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    3070:	84 fd       	sbrc	r24, 4
    3072:	2a c0       	rjmp	.+84     	; 0x30c8 <mc_reset+0x5c>
    bit_true_atomic(sys_rt_exec_state, EXEC_RESET);
    3074:	9f b7       	in	r25, 0x3f	; 63
    3076:	f8 94       	cli
    3078:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    307c:	80 61       	ori	r24, 0x10	; 16
    307e:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <sys_rt_exec_state>
    3082:	9f bf       	out	0x3f, r25	; 63

    // Kill spindle and coolant.   
    spindle_stop();
    3084:	0e 94 bb 2b 	call	0x5776	; 0x5776 <spindle_stop>
    coolant_stop();
    3088:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <coolant_stop>

    // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
    // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
    // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
    // violated, by which, all bets are off.
    if ((sys.state & (STATE_CYCLE | STATE_HOMING)) || (sys.suspend == SUSPEND_ENABLE_HOLD)) {
    308c:	80 91 a1 05 	lds	r24, 0x05A1	; 0x8005a1 <sys+0x1>
    3090:	98 2f       	mov	r25, r24
    3092:	9c 70       	andi	r25, 0x0C	; 12
    3094:	21 f4       	brne	.+8      	; 0x309e <mc_reset+0x32>
    3096:	90 91 a2 05 	lds	r25, 0x05A2	; 0x8005a2 <sys+0x2>
    309a:	91 30       	cpi	r25, 0x01	; 1
    309c:	a9 f4       	brne	.+42     	; 0x30c8 <mc_reset+0x5c>
      if (sys.state == STATE_HOMING) { bit_true_atomic(sys_rt_exec_alarm, EXEC_ALARM_HOMING_FAIL); }
    309e:	84 30       	cpi	r24, 0x04	; 4
    30a0:	49 f4       	brne	.+18     	; 0x30b4 <mc_reset+0x48>
    30a2:	9f b7       	in	r25, 0x3f	; 63
    30a4:	f8 94       	cli
    30a6:	80 91 27 05 	lds	r24, 0x0527	; 0x800527 <sys_rt_exec_alarm>
    30aa:	80 62       	ori	r24, 0x20	; 32
    30ac:	80 93 27 05 	sts	0x0527, r24	; 0x800527 <sys_rt_exec_alarm>
    30b0:	9f bf       	out	0x3f, r25	; 63
    30b2:	08 c0       	rjmp	.+16     	; 0x30c4 <mc_reset+0x58>
      else { bit_true_atomic(sys_rt_exec_alarm, EXEC_ALARM_ABORT_CYCLE); }
    30b4:	9f b7       	in	r25, 0x3f	; 63
    30b6:	f8 94       	cli
    30b8:	80 91 27 05 	lds	r24, 0x0527	; 0x800527 <sys_rt_exec_alarm>
    30bc:	88 60       	ori	r24, 0x08	; 8
    30be:	80 93 27 05 	sts	0x0527, r24	; 0x800527 <sys_rt_exec_alarm>
    30c2:	9f bf       	out	0x3f, r25	; 63
      st_go_idle(); // Force kill steppers. Position has likely been lost.
    30c4:	0e 94 5b 2c 	call	0x58b6	; 0x58b6 <st_go_idle>
    30c8:	08 95       	ret

000030ca <read_float>:
// Delays variable defined microseconds. Compiler compatibility fix for _delay_us(),
// which only accepts constants in future compiler releases. Written to perform more 
// efficiently with larger delays, as the counter adds parasitic time in each iteration.
void delay_us(uint32_t us) 
{
  while (us) {
    30ca:	4f 92       	push	r4
    30cc:	5f 92       	push	r5
    30ce:	6f 92       	push	r6
    30d0:	7f 92       	push	r7
    30d2:	8f 92       	push	r8
    30d4:	9f 92       	push	r9
    30d6:	af 92       	push	r10
    30d8:	bf 92       	push	r11
    30da:	cf 92       	push	r12
    30dc:	df 92       	push	r13
    30de:	ef 92       	push	r14
    30e0:	ff 92       	push	r15
    30e2:	0f 93       	push	r16
    30e4:	1f 93       	push	r17
    30e6:	cf 93       	push	r28
    30e8:	df 93       	push	r29
    30ea:	dc 01       	movw	r26, r24
    30ec:	fb 01       	movw	r30, r22
    30ee:	c0 81       	ld	r28, Z
    30f0:	d0 e0       	ldi	r29, 0x00	; 0
    30f2:	fc 01       	movw	r30, r24
    30f4:	ec 0f       	add	r30, r28
    30f6:	fd 1f       	adc	r31, r29
    30f8:	90 81       	ld	r25, Z
    30fa:	9d 32       	cpi	r25, 0x2D	; 45
    30fc:	29 f4       	brne	.+10     	; 0x3108 <read_float+0x3e>
    30fe:	ef 01       	movw	r28, r30
    3100:	22 96       	adiw	r28, 0x02	; 2
    3102:	91 81       	ldd	r25, Z+1	; 0x01
    3104:	01 e0       	ldi	r16, 0x01	; 1
    3106:	0b c0       	rjmp	.+22     	; 0x311e <read_float+0x54>
    3108:	9b 32       	cpi	r25, 0x2B	; 43
    310a:	29 f0       	breq	.+10     	; 0x3116 <read_float+0x4c>
    310c:	21 96       	adiw	r28, 0x01	; 1
    310e:	ca 0f       	add	r28, r26
    3110:	db 1f       	adc	r29, r27
    3112:	00 e0       	ldi	r16, 0x00	; 0
    3114:	04 c0       	rjmp	.+8      	; 0x311e <read_float+0x54>
    3116:	ef 01       	movw	r28, r30
    3118:	22 96       	adiw	r28, 0x02	; 2
    311a:	91 81       	ldd	r25, Z+1	; 0x01
    311c:	00 e0       	ldi	r16, 0x00	; 0
    311e:	80 e0       	ldi	r24, 0x00	; 0
    3120:	20 e0       	ldi	r18, 0x00	; 0
    3122:	10 e0       	ldi	r17, 0x00	; 0
    3124:	41 2c       	mov	r4, r1
    3126:	51 2c       	mov	r5, r1
    3128:	32 01       	movw	r6, r4
    312a:	31 e0       	ldi	r19, 0x01	; 1
    312c:	fe 01       	movw	r30, r28
    312e:	90 53       	subi	r25, 0x30	; 48
    3130:	9a 30       	cpi	r25, 0x0A	; 10
    3132:	10 f5       	brcc	.+68     	; 0x3178 <read_float+0xae>
    3134:	2f 5f       	subi	r18, 0xFF	; 255
    3136:	29 30       	cpi	r18, 0x09	; 9
    3138:	d8 f4       	brcc	.+54     	; 0x3170 <read_float+0xa6>
    313a:	81 11       	cpse	r24, r1
    313c:	11 50       	subi	r17, 0x01	; 1
    313e:	53 01       	movw	r10, r6
    3140:	42 01       	movw	r8, r4
    3142:	88 0c       	add	r8, r8
    3144:	99 1c       	adc	r9, r9
    3146:	aa 1c       	adc	r10, r10
    3148:	bb 1c       	adc	r11, r11
    314a:	88 0c       	add	r8, r8
    314c:	99 1c       	adc	r9, r9
    314e:	aa 1c       	adc	r10, r10
    3150:	bb 1c       	adc	r11, r11
    3152:	84 0c       	add	r8, r4
    3154:	95 1c       	adc	r9, r5
    3156:	a6 1c       	adc	r10, r6
    3158:	b7 1c       	adc	r11, r7
    315a:	88 0c       	add	r8, r8
    315c:	99 1c       	adc	r9, r9
    315e:	aa 1c       	adc	r10, r10
    3160:	bb 1c       	adc	r11, r11
    3162:	24 01       	movw	r4, r8
    3164:	35 01       	movw	r6, r10
    3166:	49 0e       	add	r4, r25
    3168:	51 1c       	adc	r5, r1
    316a:	61 1c       	adc	r6, r1
    316c:	71 1c       	adc	r7, r1
    316e:	09 c0       	rjmp	.+18     	; 0x3182 <read_float+0xb8>
    3170:	81 11       	cpse	r24, r1
    3172:	07 c0       	rjmp	.+14     	; 0x3182 <read_float+0xb8>
    3174:	1f 5f       	subi	r17, 0xFF	; 255
    3176:	05 c0       	rjmp	.+10     	; 0x3182 <read_float+0xb8>
    3178:	9e 3f       	cpi	r25, 0xFE	; 254
    317a:	31 f4       	brne	.+12     	; 0x3188 <read_float+0xbe>
    317c:	81 11       	cpse	r24, r1
    317e:	04 c0       	rjmp	.+8      	; 0x3188 <read_float+0xbe>
    3180:	83 2f       	mov	r24, r19
    3182:	90 81       	ld	r25, Z
    3184:	21 96       	adiw	r28, 0x01	; 1
    3186:	d2 cf       	rjmp	.-92     	; 0x312c <read_float+0x62>
    3188:	22 23       	and	r18, r18
    318a:	09 f4       	brne	.+2      	; 0x318e <read_float+0xc4>
    318c:	52 c0       	rjmp	.+164    	; 0x3232 <read_float+0x168>
    318e:	6a 01       	movw	r12, r20
    3190:	7b 01       	movw	r14, r22
    3192:	5d 01       	movw	r10, r26
    3194:	c3 01       	movw	r24, r6
    3196:	b2 01       	movw	r22, r4
    3198:	0e 94 51 3a 	call	0x74a2	; 0x74a2 <__floatunsisf>
    319c:	2b 01       	movw	r4, r22
    319e:	3c 01       	movw	r6, r24
    31a0:	20 e0       	ldi	r18, 0x00	; 0
    31a2:	30 e0       	ldi	r19, 0x00	; 0
    31a4:	a9 01       	movw	r20, r18
    31a6:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    31aa:	88 23       	and	r24, r24
    31ac:	51 f1       	breq	.+84     	; 0x3202 <read_float+0x138>
    31ae:	1f 3f       	cpi	r17, 0xFF	; 255
    31b0:	6c f4       	brge	.+26     	; 0x31cc <read_float+0x102>
    31b2:	2a e0       	ldi	r18, 0x0A	; 10
    31b4:	37 ed       	ldi	r19, 0xD7	; 215
    31b6:	43 e2       	ldi	r20, 0x23	; 35
    31b8:	5c e3       	ldi	r21, 0x3C	; 60
    31ba:	c3 01       	movw	r24, r6
    31bc:	b2 01       	movw	r22, r4
    31be:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    31c2:	2b 01       	movw	r4, r22
    31c4:	3c 01       	movw	r6, r24
    31c6:	1e 5f       	subi	r17, 0xFE	; 254
    31c8:	1f 3f       	cpi	r17, 0xFF	; 255
    31ca:	9c f3       	brlt	.-26     	; 0x31b2 <read_float+0xe8>
    31cc:	11 23       	and	r17, r17
    31ce:	5c f4       	brge	.+22     	; 0x31e6 <read_float+0x11c>
    31d0:	2d ec       	ldi	r18, 0xCD	; 205
    31d2:	3c ec       	ldi	r19, 0xCC	; 204
    31d4:	4c ec       	ldi	r20, 0xCC	; 204
    31d6:	5d e3       	ldi	r21, 0x3D	; 61
    31d8:	c3 01       	movw	r24, r6
    31da:	b2 01       	movw	r22, r4
    31dc:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    31e0:	2b 01       	movw	r4, r22
    31e2:	3c 01       	movw	r6, r24
    31e4:	0e c0       	rjmp	.+28     	; 0x3202 <read_float+0x138>
    31e6:	11 16       	cp	r1, r17
    31e8:	64 f4       	brge	.+24     	; 0x3202 <read_float+0x138>
    31ea:	20 e0       	ldi	r18, 0x00	; 0
    31ec:	30 e0       	ldi	r19, 0x00	; 0
    31ee:	40 e2       	ldi	r20, 0x20	; 32
    31f0:	51 e4       	ldi	r21, 0x41	; 65
    31f2:	c3 01       	movw	r24, r6
    31f4:	b2 01       	movw	r22, r4
    31f6:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    31fa:	2b 01       	movw	r4, r22
    31fc:	3c 01       	movw	r6, r24
    31fe:	11 50       	subi	r17, 0x01	; 1
    3200:	a1 f7       	brne	.-24     	; 0x31ea <read_float+0x120>
    3202:	00 23       	and	r16, r16
    3204:	51 f0       	breq	.+20     	; 0x321a <read_float+0x150>
    3206:	77 fa       	bst	r7, 7
    3208:	70 94       	com	r7
    320a:	77 f8       	bld	r7, 7
    320c:	70 94       	com	r7
    320e:	f6 01       	movw	r30, r12
    3210:	40 82       	st	Z, r4
    3212:	51 82       	std	Z+1, r5	; 0x01
    3214:	62 82       	std	Z+2, r6	; 0x02
    3216:	73 82       	std	Z+3, r7	; 0x03
    3218:	05 c0       	rjmp	.+10     	; 0x3224 <read_float+0x15a>
    321a:	f6 01       	movw	r30, r12
    321c:	40 82       	st	Z, r4
    321e:	51 82       	std	Z+1, r5	; 0x01
    3220:	62 82       	std	Z+2, r6	; 0x02
    3222:	73 82       	std	Z+3, r7	; 0x03
    3224:	ca 19       	sub	r28, r10
    3226:	db 09       	sbc	r29, r11
    3228:	c1 50       	subi	r28, 0x01	; 1
    322a:	f7 01       	movw	r30, r14
    322c:	c0 83       	st	Z, r28
    322e:	81 e0       	ldi	r24, 0x01	; 1
    3230:	01 c0       	rjmp	.+2      	; 0x3234 <read_float+0x16a>
    3232:	80 e0       	ldi	r24, 0x00	; 0
    3234:	df 91       	pop	r29
    3236:	cf 91       	pop	r28
    3238:	1f 91       	pop	r17
    323a:	0f 91       	pop	r16
    323c:	ff 90       	pop	r15
    323e:	ef 90       	pop	r14
    3240:	df 90       	pop	r13
    3242:	cf 90       	pop	r12
    3244:	bf 90       	pop	r11
    3246:	af 90       	pop	r10
    3248:	9f 90       	pop	r9
    324a:	8f 90       	pop	r8
    324c:	7f 90       	pop	r7
    324e:	6f 90       	pop	r6
    3250:	5f 90       	pop	r5
    3252:	4f 90       	pop	r4
    3254:	08 95       	ret

00003256 <delay_ms>:
    3256:	00 97       	sbiw	r24, 0x00	; 0
    3258:	41 f0       	breq	.+16     	; 0x326a <delay_ms+0x14>
    325a:	ef e9       	ldi	r30, 0x9F	; 159
    325c:	ff e0       	ldi	r31, 0x0F	; 15
    325e:	31 97       	sbiw	r30, 0x01	; 1
    3260:	f1 f7       	brne	.-4      	; 0x325e <delay_ms+0x8>
    3262:	00 c0       	rjmp	.+0      	; 0x3264 <delay_ms+0xe>
    3264:	00 00       	nop
    3266:	01 97       	sbiw	r24, 0x01	; 1
    3268:	c1 f7       	brne	.-16     	; 0x325a <delay_ms+0x4>
    326a:	08 95       	ret

0000326c <hypot_f>:
  }
}


// Simple hypotenuse computation function.
float hypot_f(float x, float y) { return(sqrt(x*x + y*y)); }
    326c:	4f 92       	push	r4
    326e:	5f 92       	push	r5
    3270:	6f 92       	push	r6
    3272:	7f 92       	push	r7
    3274:	8f 92       	push	r8
    3276:	9f 92       	push	r9
    3278:	af 92       	push	r10
    327a:	bf 92       	push	r11
    327c:	cf 92       	push	r12
    327e:	df 92       	push	r13
    3280:	ef 92       	push	r14
    3282:	ff 92       	push	r15
    3284:	4b 01       	movw	r8, r22
    3286:	5c 01       	movw	r10, r24
    3288:	69 01       	movw	r12, r18
    328a:	7a 01       	movw	r14, r20
    328c:	a5 01       	movw	r20, r10
    328e:	94 01       	movw	r18, r8
    3290:	c5 01       	movw	r24, r10
    3292:	b4 01       	movw	r22, r8
    3294:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    3298:	4b 01       	movw	r8, r22
    329a:	5c 01       	movw	r10, r24
    329c:	a7 01       	movw	r20, r14
    329e:	96 01       	movw	r18, r12
    32a0:	c7 01       	movw	r24, r14
    32a2:	b6 01       	movw	r22, r12
    32a4:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    32a8:	9b 01       	movw	r18, r22
    32aa:	ac 01       	movw	r20, r24
    32ac:	c5 01       	movw	r24, r10
    32ae:	b4 01       	movw	r22, r8
    32b0:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    32b4:	0e 94 a0 3c 	call	0x7940	; 0x7940 <sqrt>
    32b8:	ff 90       	pop	r15
    32ba:	ef 90       	pop	r14
    32bc:	df 90       	pop	r13
    32be:	cf 90       	pop	r12
    32c0:	bf 90       	pop	r11
    32c2:	af 90       	pop	r10
    32c4:	9f 90       	pop	r9
    32c6:	8f 90       	pop	r8
    32c8:	7f 90       	pop	r7
    32ca:	6f 90       	pop	r6
    32cc:	5f 90       	pop	r5
    32ce:	4f 90       	pop	r4
    32d0:	08 95       	ret

000032d2 <planner_recalculate>:
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
  return(block_index);
}
    32d2:	2f 92       	push	r2
    32d4:	3f 92       	push	r3
    32d6:	4f 92       	push	r4
    32d8:	5f 92       	push	r5
    32da:	6f 92       	push	r6
    32dc:	7f 92       	push	r7
    32de:	8f 92       	push	r8
    32e0:	9f 92       	push	r9
    32e2:	af 92       	push	r10
    32e4:	bf 92       	push	r11
    32e6:	cf 92       	push	r12
    32e8:	df 92       	push	r13
    32ea:	ef 92       	push	r14
    32ec:	ff 92       	push	r15
    32ee:	0f 93       	push	r16
    32f0:	1f 93       	push	r17
    32f2:	cf 93       	push	r28
    32f4:	df 93       	push	r29
    32f6:	c0 91 1e 01 	lds	r28, 0x011E	; 0x80011e <block_buffer_head>
    32fa:	c1 11       	cpse	r28, r1
    32fc:	01 c0       	rjmp	.+2      	; 0x3300 <planner_recalculate+0x2e>
    32fe:	c2 e1       	ldi	r28, 0x12	; 18
    3300:	c1 50       	subi	r28, 0x01	; 1
    3302:	d0 91 1c 01 	lds	r29, 0x011C	; 0x80011c <block_buffer_planned>
    3306:	dc 17       	cp	r29, r28
    3308:	09 f4       	brne	.+2      	; 0x330c <planner_recalculate+0x3a>
    330a:	36 c1       	rjmp	.+620    	; 0x3578 <planner_recalculate+0x2a6>
    330c:	0c 2f       	mov	r16, r28
    330e:	10 e0       	ldi	r17, 0x00	; 0
    3310:	29 e2       	ldi	r18, 0x29	; 41
    3312:	c2 9f       	mul	r28, r18
    3314:	c0 01       	movw	r24, r0
    3316:	11 24       	eor	r1, r1
    3318:	fc 01       	movw	r30, r24
    331a:	e0 5e       	subi	r30, 0xE0	; 224
    331c:	fe 4f       	sbci	r31, 0xFE	; 254
    331e:	6f 01       	movw	r12, r30
    3320:	e5 88       	ldd	r14, Z+21	; 0x15
    3322:	f6 88       	ldd	r15, Z+22	; 0x16
    3324:	97 88       	ldd	r9, Z+23	; 0x17
    3326:	80 8c       	ldd	r8, Z+24	; 0x18
    3328:	61 a1       	ldd	r22, Z+33	; 0x21
    332a:	72 a1       	ldd	r23, Z+34	; 0x22
    332c:	83 a1       	ldd	r24, Z+35	; 0x23
    332e:	94 a1       	ldd	r25, Z+36	; 0x24
    3330:	9b 01       	movw	r18, r22
    3332:	ac 01       	movw	r20, r24
    3334:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    3338:	f6 01       	movw	r30, r12
    333a:	25 a1       	ldd	r18, Z+37	; 0x25
    333c:	36 a1       	ldd	r19, Z+38	; 0x26
    333e:	47 a1       	ldd	r20, Z+39	; 0x27
    3340:	50 a5       	ldd	r21, Z+40	; 0x28
    3342:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    3346:	a6 2e       	mov	r10, r22
    3348:	b7 2e       	mov	r11, r23
    334a:	c8 2e       	mov	r12, r24
    334c:	d9 2e       	mov	r13, r25
    334e:	26 2f       	mov	r18, r22
    3350:	37 2f       	mov	r19, r23
    3352:	48 2f       	mov	r20, r24
    3354:	59 2f       	mov	r21, r25
    3356:	6e 2d       	mov	r22, r14
    3358:	7f 2d       	mov	r23, r15
    335a:	89 2d       	mov	r24, r9
    335c:	98 2d       	mov	r25, r8
    335e:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    3362:	88 23       	and	r24, r24
    3364:	24 f0       	brlt	.+8      	; 0x336e <planner_recalculate+0x9c>
    3366:	ea 2c       	mov	r14, r10
    3368:	fb 2c       	mov	r15, r11
    336a:	9c 2c       	mov	r9, r12
    336c:	8d 2c       	mov	r8, r13
    336e:	89 e2       	ldi	r24, 0x29	; 41
    3370:	80 9f       	mul	r24, r16
    3372:	f0 01       	movw	r30, r0
    3374:	81 9f       	mul	r24, r17
    3376:	f0 0d       	add	r31, r0
    3378:	11 24       	eor	r1, r1
    337a:	e0 5e       	subi	r30, 0xE0	; 224
    337c:	fe 4f       	sbci	r31, 0xFE	; 254
    337e:	8e 2d       	mov	r24, r14
    3380:	9f 2d       	mov	r25, r15
    3382:	a9 2d       	mov	r26, r9
    3384:	b8 2d       	mov	r27, r8
    3386:	81 8b       	std	Z+17, r24	; 0x11
    3388:	92 8b       	std	Z+18, r25	; 0x12
    338a:	a3 8b       	std	Z+19, r26	; 0x13
    338c:	b4 8b       	std	Z+20, r27	; 0x14
    338e:	c1 11       	cpse	r28, r1
    3390:	01 c0       	rjmp	.+2      	; 0x3394 <planner_recalculate+0xc2>
    3392:	c2 e1       	ldi	r28, 0x12	; 18
    3394:	c1 50       	subi	r28, 0x01	; 1
    3396:	dc 13       	cpse	r29, r28
    3398:	07 c0       	rjmp	.+14     	; 0x33a8 <planner_recalculate+0xd6>
    339a:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <block_buffer_tail>
    339e:	d8 13       	cpse	r29, r24
    33a0:	7c c0       	rjmp	.+248    	; 0x349a <planner_recalculate+0x1c8>
    33a2:	0e 94 0b 2f 	call	0x5e16	; 0x5e16 <st_update_plan_block_parameters>
    33a6:	79 c0       	rjmp	.+242    	; 0x349a <planner_recalculate+0x1c8>
    33a8:	29 e2       	ldi	r18, 0x29	; 41
    33aa:	20 9f       	mul	r18, r16
    33ac:	c0 01       	movw	r24, r0
    33ae:	21 9f       	mul	r18, r17
    33b0:	90 0d       	add	r25, r0
    33b2:	11 24       	eor	r1, r1
    33b4:	9c 01       	movw	r18, r24
    33b6:	20 5e       	subi	r18, 0xE0	; 224
    33b8:	3e 4f       	sbci	r19, 0xFE	; 254
    33ba:	69 01       	movw	r12, r18
    33bc:	d9 e2       	ldi	r29, 0x29	; 41
    33be:	ec 2e       	mov	r14, r28
    33c0:	f1 2c       	mov	r15, r1
    33c2:	de 9d       	mul	r29, r14
    33c4:	80 01       	movw	r16, r0
    33c6:	df 9d       	mul	r29, r15
    33c8:	10 0d       	add	r17, r0
    33ca:	11 24       	eor	r1, r1
    33cc:	00 5e       	subi	r16, 0xE0	; 224
    33ce:	1e 4f       	sbci	r17, 0xFE	; 254
    33d0:	c1 11       	cpse	r28, r1
    33d2:	01 c0       	rjmp	.+2      	; 0x33d6 <planner_recalculate+0x104>
    33d4:	c2 e1       	ldi	r28, 0x12	; 18
    33d6:	c1 50       	subi	r28, 0x01	; 1
    33d8:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <block_buffer_tail>
    33dc:	8c 13       	cpse	r24, r28
    33de:	02 c0       	rjmp	.+4      	; 0x33e4 <planner_recalculate+0x112>
    33e0:	0e 94 0b 2f 	call	0x5e16	; 0x5e16 <st_update_plan_block_parameters>
    33e4:	de 9d       	mul	r29, r14
    33e6:	f0 01       	movw	r30, r0
    33e8:	df 9d       	mul	r29, r15
    33ea:	f0 0d       	add	r31, r0
    33ec:	11 24       	eor	r1, r1
    33ee:	e0 5e       	subi	r30, 0xE0	; 224
    33f0:	fe 4f       	sbci	r31, 0xFE	; 254
    33f2:	45 88       	ldd	r4, Z+21	; 0x15
    33f4:	56 88       	ldd	r5, Z+22	; 0x16
    33f6:	67 88       	ldd	r6, Z+23	; 0x17
    33f8:	70 8c       	ldd	r7, Z+24	; 0x18
    33fa:	a3 01       	movw	r20, r6
    33fc:	92 01       	movw	r18, r4
    33fe:	61 89       	ldd	r22, Z+17	; 0x11
    3400:	72 89       	ldd	r23, Z+18	; 0x12
    3402:	83 89       	ldd	r24, Z+19	; 0x13
    3404:	94 89       	ldd	r25, Z+20	; 0x14
    3406:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    340a:	88 23       	and	r24, r24
    340c:	09 f4       	brne	.+2      	; 0x3410 <planner_recalculate+0x13e>
    340e:	40 c0       	rjmp	.+128    	; 0x3490 <planner_recalculate+0x1be>
    3410:	de 9d       	mul	r29, r14
    3412:	c0 01       	movw	r24, r0
    3414:	df 9d       	mul	r29, r15
    3416:	90 0d       	add	r25, r0
    3418:	11 24       	eor	r1, r1
    341a:	fc 01       	movw	r30, r24
    341c:	e0 5e       	subi	r30, 0xE0	; 224
    341e:	fe 4f       	sbci	r31, 0xFE	; 254
    3420:	5f 01       	movw	r10, r30
    3422:	61 a1       	ldd	r22, Z+33	; 0x21
    3424:	72 a1       	ldd	r23, Z+34	; 0x22
    3426:	83 a1       	ldd	r24, Z+35	; 0x23
    3428:	94 a1       	ldd	r25, Z+36	; 0x24
    342a:	9b 01       	movw	r18, r22
    342c:	ac 01       	movw	r20, r24
    342e:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    3432:	f5 01       	movw	r30, r10
    3434:	25 a1       	ldd	r18, Z+37	; 0x25
    3436:	36 a1       	ldd	r19, Z+38	; 0x26
    3438:	47 a1       	ldd	r20, Z+39	; 0x27
    343a:	50 a5       	ldd	r21, Z+40	; 0x28
    343c:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    3440:	f6 01       	movw	r30, r12
    3442:	21 89       	ldd	r18, Z+17	; 0x11
    3444:	32 89       	ldd	r19, Z+18	; 0x12
    3446:	43 89       	ldd	r20, Z+19	; 0x13
    3448:	54 89       	ldd	r21, Z+20	; 0x14
    344a:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    344e:	4b 01       	movw	r8, r22
    3450:	5c 01       	movw	r10, r24
    3452:	9b 01       	movw	r18, r22
    3454:	ac 01       	movw	r20, r24
    3456:	c3 01       	movw	r24, r6
    3458:	b2 01       	movw	r22, r4
    345a:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    345e:	18 16       	cp	r1, r24
    3460:	64 f4       	brge	.+24     	; 0x347a <planner_recalculate+0x1a8>
    3462:	de 9d       	mul	r29, r14
    3464:	f0 01       	movw	r30, r0
    3466:	df 9d       	mul	r29, r15
    3468:	f0 0d       	add	r31, r0
    346a:	11 24       	eor	r1, r1
    346c:	e0 5e       	subi	r30, 0xE0	; 224
    346e:	fe 4f       	sbci	r31, 0xFE	; 254
    3470:	81 8a       	std	Z+17, r8	; 0x11
    3472:	92 8a       	std	Z+18, r9	; 0x12
    3474:	a3 8a       	std	Z+19, r10	; 0x13
    3476:	b4 8a       	std	Z+20, r11	; 0x14
    3478:	0b c0       	rjmp	.+22     	; 0x3490 <planner_recalculate+0x1be>
    347a:	de 9d       	mul	r29, r14
    347c:	f0 01       	movw	r30, r0
    347e:	df 9d       	mul	r29, r15
    3480:	f0 0d       	add	r31, r0
    3482:	11 24       	eor	r1, r1
    3484:	e0 5e       	subi	r30, 0xE0	; 224
    3486:	fe 4f       	sbci	r31, 0xFE	; 254
    3488:	41 8a       	std	Z+17, r4	; 0x11
    348a:	52 8a       	std	Z+18, r5	; 0x12
    348c:	63 8a       	std	Z+19, r6	; 0x13
    348e:	74 8a       	std	Z+20, r7	; 0x14
    3490:	68 01       	movw	r12, r16
    3492:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <block_buffer_planned>
    3496:	8c 13       	cpse	r24, r28
    3498:	92 cf       	rjmp	.-220    	; 0x33be <planner_recalculate+0xec>
    349a:	20 90 1c 01 	lds	r2, 0x011C	; 0x80011c <block_buffer_planned>
    349e:	f9 e2       	ldi	r31, 0x29	; 41
    34a0:	2f 9e       	mul	r2, r31
    34a2:	c0 01       	movw	r24, r0
    34a4:	11 24       	eor	r1, r1
    34a6:	9c 01       	movw	r18, r24
    34a8:	20 5e       	subi	r18, 0xE0	; 224
    34aa:	3e 4f       	sbci	r19, 0xFE	; 254
    34ac:	79 01       	movw	r14, r18
    34ae:	c1 e0       	ldi	r28, 0x01	; 1
    34b0:	c2 0d       	add	r28, r2
    34b2:	c2 31       	cpi	r28, 0x12	; 18
    34b4:	09 f4       	brne	.+2      	; 0x34b8 <planner_recalculate+0x1e6>
    34b6:	c0 e0       	ldi	r28, 0x00	; 0
    34b8:	30 90 1e 01 	lds	r3, 0x011E	; 0x80011e <block_buffer_head>
    34bc:	d9 e2       	ldi	r29, 0x29	; 41
    34be:	58 c0       	rjmp	.+176    	; 0x3570 <planner_recalculate+0x29e>
    34c0:	cc 2e       	mov	r12, r28
    34c2:	d1 2c       	mov	r13, r1
    34c4:	dc 9d       	mul	r29, r12
    34c6:	80 01       	movw	r16, r0
    34c8:	dd 9d       	mul	r29, r13
    34ca:	10 0d       	add	r17, r0
    34cc:	11 24       	eor	r1, r1
    34ce:	00 5e       	subi	r16, 0xE0	; 224
    34d0:	1e 4f       	sbci	r17, 0xFE	; 254
    34d2:	f7 01       	movw	r30, r14
    34d4:	41 88       	ldd	r4, Z+17	; 0x11
    34d6:	52 88       	ldd	r5, Z+18	; 0x12
    34d8:	63 88       	ldd	r6, Z+19	; 0x13
    34da:	74 88       	ldd	r7, Z+20	; 0x14
    34dc:	f8 01       	movw	r30, r16
    34de:	81 88       	ldd	r8, Z+17	; 0x11
    34e0:	92 88       	ldd	r9, Z+18	; 0x12
    34e2:	a3 88       	ldd	r10, Z+19	; 0x13
    34e4:	b4 88       	ldd	r11, Z+20	; 0x14
    34e6:	a5 01       	movw	r20, r10
    34e8:	94 01       	movw	r18, r8
    34ea:	c3 01       	movw	r24, r6
    34ec:	b2 01       	movw	r22, r4
    34ee:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    34f2:	88 23       	and	r24, r24
    34f4:	24 f5       	brge	.+72     	; 0x353e <planner_recalculate+0x26c>
    34f6:	f7 01       	movw	r30, r14
    34f8:	61 a1       	ldd	r22, Z+33	; 0x21
    34fa:	72 a1       	ldd	r23, Z+34	; 0x22
    34fc:	83 a1       	ldd	r24, Z+35	; 0x23
    34fe:	94 a1       	ldd	r25, Z+36	; 0x24
    3500:	9b 01       	movw	r18, r22
    3502:	ac 01       	movw	r20, r24
    3504:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    3508:	f7 01       	movw	r30, r14
    350a:	25 a1       	ldd	r18, Z+37	; 0x25
    350c:	36 a1       	ldd	r19, Z+38	; 0x26
    350e:	47 a1       	ldd	r20, Z+39	; 0x27
    3510:	50 a5       	ldd	r21, Z+40	; 0x28
    3512:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    3516:	a3 01       	movw	r20, r6
    3518:	92 01       	movw	r18, r4
    351a:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    351e:	2b 01       	movw	r4, r22
    3520:	3c 01       	movw	r6, r24
    3522:	9b 01       	movw	r18, r22
    3524:	ac 01       	movw	r20, r24
    3526:	c5 01       	movw	r24, r10
    3528:	b4 01       	movw	r22, r8
    352a:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    352e:	18 16       	cp	r1, r24
    3530:	34 f4       	brge	.+12     	; 0x353e <planner_recalculate+0x26c>
    3532:	f8 01       	movw	r30, r16
    3534:	41 8a       	std	Z+17, r4	; 0x11
    3536:	52 8a       	std	Z+18, r5	; 0x12
    3538:	63 8a       	std	Z+19, r6	; 0x13
    353a:	74 8a       	std	Z+20, r7	; 0x14
    353c:	2c 2e       	mov	r2, r28
    353e:	dc 9d       	mul	r29, r12
    3540:	f0 01       	movw	r30, r0
    3542:	dd 9d       	mul	r29, r13
    3544:	f0 0d       	add	r31, r0
    3546:	11 24       	eor	r1, r1
    3548:	e0 5e       	subi	r30, 0xE0	; 224
    354a:	fe 4f       	sbci	r31, 0xFE	; 254
    354c:	25 89       	ldd	r18, Z+21	; 0x15
    354e:	36 89       	ldd	r19, Z+22	; 0x16
    3550:	47 89       	ldd	r20, Z+23	; 0x17
    3552:	50 8d       	ldd	r21, Z+24	; 0x18
    3554:	61 89       	ldd	r22, Z+17	; 0x11
    3556:	72 89       	ldd	r23, Z+18	; 0x12
    3558:	83 89       	ldd	r24, Z+19	; 0x13
    355a:	94 89       	ldd	r25, Z+20	; 0x14
    355c:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    3560:	81 11       	cpse	r24, r1
    3562:	01 c0       	rjmp	.+2      	; 0x3566 <planner_recalculate+0x294>
    3564:	2c 2e       	mov	r2, r28
    3566:	cf 5f       	subi	r28, 0xFF	; 255
    3568:	c2 31       	cpi	r28, 0x12	; 18
    356a:	09 f4       	brne	.+2      	; 0x356e <planner_recalculate+0x29c>
    356c:	c0 e0       	ldi	r28, 0x00	; 0
    356e:	78 01       	movw	r14, r16
    3570:	c3 11       	cpse	r28, r3
    3572:	a6 cf       	rjmp	.-180    	; 0x34c0 <planner_recalculate+0x1ee>
    3574:	20 92 1c 01 	sts	0x011C, r2	; 0x80011c <block_buffer_planned>
    3578:	df 91       	pop	r29
    357a:	cf 91       	pop	r28
    357c:	1f 91       	pop	r17
    357e:	0f 91       	pop	r16
    3580:	ff 90       	pop	r15
    3582:	ef 90       	pop	r14
    3584:	df 90       	pop	r13
    3586:	cf 90       	pop	r12
    3588:	bf 90       	pop	r11
    358a:	af 90       	pop	r10
    358c:	9f 90       	pop	r9
    358e:	8f 90       	pop	r8
    3590:	7f 90       	pop	r7
    3592:	6f 90       	pop	r6
    3594:	5f 90       	pop	r5
    3596:	4f 90       	pop	r4
    3598:	3f 90       	pop	r3
    359a:	2f 90       	pop	r2
    359c:	08 95       	ret

0000359e <plan_reset>:
}


void plan_reset() 
{
  memset(&pl, 0, sizeof(planner_t)); // Clear planner struct
    359e:	8c e1       	ldi	r24, 0x1C	; 28
    35a0:	e0 e0       	ldi	r30, 0x00	; 0
    35a2:	f1 e0       	ldi	r31, 0x01	; 1
    35a4:	df 01       	movw	r26, r30
    35a6:	1d 92       	st	X+, r1
    35a8:	8a 95       	dec	r24
    35aa:	e9 f7       	brne	.-6      	; 0x35a6 <plan_reset+0x8>
  block_buffer_tail = 0;
    35ac:	10 92 1f 01 	sts	0x011F, r1	; 0x80011f <block_buffer_tail>
  block_buffer_head = 0; // Empty = tail
    35b0:	10 92 1e 01 	sts	0x011E, r1	; 0x80011e <block_buffer_head>
  next_buffer_head = 1; // plan_next_block_index(block_buffer_head)
    35b4:	81 e0       	ldi	r24, 0x01	; 1
    35b6:	80 93 1d 01 	sts	0x011D, r24	; 0x80011d <next_buffer_head>
  block_buffer_planned = 0; // = block_buffer_tail;
    35ba:	10 92 1c 01 	sts	0x011C, r1	; 0x80011c <block_buffer_planned>
    35be:	08 95       	ret

000035c0 <plan_discard_current_block>:
}


void plan_discard_current_block() 
{
  if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
    35c0:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <block_buffer_tail>
    35c4:	90 91 1e 01 	lds	r25, 0x011E	; 0x80011e <block_buffer_head>
    35c8:	98 17       	cp	r25, r24
    35ca:	69 f0       	breq	.+26     	; 0x35e6 <plan_discard_current_block+0x26>


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    35cc:	91 e0       	ldi	r25, 0x01	; 1
    35ce:	98 0f       	add	r25, r24
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    35d0:	92 31       	cpi	r25, 0x12	; 18
    35d2:	09 f4       	brne	.+2      	; 0x35d6 <plan_discard_current_block+0x16>
    35d4:	90 e0       	ldi	r25, 0x00	; 0
void plan_discard_current_block() 
{
  if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
    uint8_t block_index = plan_next_block_index( block_buffer_tail );
    // Push block_buffer_planned pointer, if encountered.
    if (block_buffer_tail == block_buffer_planned) { block_buffer_planned = block_index; }
    35d6:	20 91 1c 01 	lds	r18, 0x011C	; 0x80011c <block_buffer_planned>
    35da:	82 13       	cpse	r24, r18
    35dc:	02 c0       	rjmp	.+4      	; 0x35e2 <plan_discard_current_block+0x22>
    35de:	90 93 1c 01 	sts	0x011C, r25	; 0x80011c <block_buffer_planned>
    block_buffer_tail = block_index;
    35e2:	90 93 1f 01 	sts	0x011F, r25	; 0x80011f <block_buffer_tail>
    35e6:	08 95       	ret

000035e8 <plan_get_current_block>:
}


plan_block_t *plan_get_current_block() 
{
  if (block_buffer_head == block_buffer_tail) { return(NULL); } // Buffer empty  
    35e8:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <block_buffer_tail>
    35ec:	90 91 1e 01 	lds	r25, 0x011E	; 0x80011e <block_buffer_head>
    35f0:	98 17       	cp	r25, r24
    35f2:	39 f0       	breq	.+14     	; 0x3602 <plan_get_current_block+0x1a>
  return(&block_buffer[block_buffer_tail]);
    35f4:	29 e2       	ldi	r18, 0x29	; 41
    35f6:	82 9f       	mul	r24, r18
    35f8:	c0 01       	movw	r24, r0
    35fa:	11 24       	eor	r1, r1
    35fc:	80 5e       	subi	r24, 0xE0	; 224
    35fe:	9e 4f       	sbci	r25, 0xFE	; 254
    3600:	08 95       	ret
}


plan_block_t *plan_get_current_block() 
{
  if (block_buffer_head == block_buffer_tail) { return(NULL); } // Buffer empty  
    3602:	80 e0       	ldi	r24, 0x00	; 0
    3604:	90 e0       	ldi	r25, 0x00	; 0
  return(&block_buffer[block_buffer_tail]);
}
    3606:	08 95       	ret

00003608 <plan_get_exec_block_exit_speed>:


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    3608:	e0 91 1f 01 	lds	r30, 0x011F	; 0x80011f <block_buffer_tail>
    360c:	ef 5f       	subi	r30, 0xFF	; 255
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    360e:	e2 31       	cpi	r30, 0x12	; 18
    3610:	09 f4       	brne	.+2      	; 0x3614 <plan_get_exec_block_exit_speed+0xc>
    3612:	e0 e0       	ldi	r30, 0x00	; 0


float plan_get_exec_block_exit_speed()
{
  uint8_t block_index = plan_next_block_index(block_buffer_tail);
  if (block_index == block_buffer_head) { return( 0.0 ); }
    3614:	80 91 1e 01 	lds	r24, 0x011E	; 0x80011e <block_buffer_head>
    3618:	8e 17       	cp	r24, r30
    361a:	69 f0       	breq	.+26     	; 0x3636 <plan_get_exec_block_exit_speed+0x2e>
  return( sqrt( block_buffer[block_index].entry_speed_sqr ) ); 
    361c:	89 e2       	ldi	r24, 0x29	; 41
    361e:	e8 9f       	mul	r30, r24
    3620:	f0 01       	movw	r30, r0
    3622:	11 24       	eor	r1, r1
    3624:	e0 5e       	subi	r30, 0xE0	; 224
    3626:	fe 4f       	sbci	r31, 0xFE	; 254
    3628:	61 89       	ldd	r22, Z+17	; 0x11
    362a:	72 89       	ldd	r23, Z+18	; 0x12
    362c:	83 89       	ldd	r24, Z+19	; 0x13
    362e:	94 89       	ldd	r25, Z+20	; 0x14
    3630:	0e 94 a0 3c 	call	0x7940	; 0x7940 <sqrt>
    3634:	08 95       	ret


float plan_get_exec_block_exit_speed()
{
  uint8_t block_index = plan_next_block_index(block_buffer_tail);
  if (block_index == block_buffer_head) { return( 0.0 ); }
    3636:	60 e0       	ldi	r22, 0x00	; 0
    3638:	70 e0       	ldi	r23, 0x00	; 0
    363a:	cb 01       	movw	r24, r22
  return( sqrt( block_buffer[block_index].entry_speed_sqr ) ); 
}
    363c:	08 95       	ret

0000363e <plan_check_full_buffer>:


// Returns the availability status of the block ring buffer. True, if full.
uint8_t plan_check_full_buffer()
{
    363e:	81 e0       	ldi	r24, 0x01	; 1
    3640:	20 91 1f 01 	lds	r18, 0x011F	; 0x80011f <block_buffer_tail>
    3644:	90 91 1d 01 	lds	r25, 0x011D	; 0x80011d <next_buffer_head>
    3648:	29 13       	cpse	r18, r25
    364a:	80 e0       	ldi	r24, 0x00	; 0
  if (block_buffer_tail == next_buffer_head) { return(true); }
  return(false);
}
    364c:	08 95       	ret

0000364e <plan_buffer_line>:
#ifdef USE_LINE_NUMBERS   
  void plan_buffer_line(float *target, float feed_rate, uint8_t invert_feed_rate, int32_t line_number) 
#else
  void plan_buffer_line(float *target, float feed_rate, uint8_t invert_feed_rate) 
#endif
{
    364e:	2f 92       	push	r2
    3650:	3f 92       	push	r3
    3652:	4f 92       	push	r4
    3654:	5f 92       	push	r5
    3656:	6f 92       	push	r6
    3658:	7f 92       	push	r7
    365a:	8f 92       	push	r8
    365c:	9f 92       	push	r9
    365e:	af 92       	push	r10
    3660:	bf 92       	push	r11
    3662:	cf 92       	push	r12
    3664:	df 92       	push	r13
    3666:	ef 92       	push	r14
    3668:	ff 92       	push	r15
    366a:	0f 93       	push	r16
    366c:	1f 93       	push	r17
    366e:	cf 93       	push	r28
    3670:	df 93       	push	r29
    3672:	cd b7       	in	r28, 0x3d	; 61
    3674:	de b7       	in	r29, 0x3e	; 62
    3676:	e8 97       	sbiw	r28, 0x38	; 56
    3678:	0f b6       	in	r0, 0x3f	; 63
    367a:	f8 94       	cli
    367c:	de bf       	out	0x3e, r29	; 62
    367e:	0f be       	out	0x3f, r0	; 63
    3680:	cd bf       	out	0x3d, r28	; 61
    3682:	4b a7       	std	Y+43, r20	; 0x2b
    3684:	5c a7       	std	Y+44, r21	; 0x2c
    3686:	6d a7       	std	Y+45, r22	; 0x2d
    3688:	7e a7       	std	Y+46, r23	; 0x2e
    368a:	02 2f       	mov	r16, r18
  // Prepare and initialize new block
  plan_block_t *block = &block_buffer[block_buffer_head];
    368c:	20 91 1e 01 	lds	r18, 0x011E	; 0x80011e <block_buffer_head>
  block->step_event_count = 0;
    3690:	39 e2       	ldi	r19, 0x29	; 41
    3692:	23 9f       	mul	r18, r19
    3694:	a0 01       	movw	r20, r0
    3696:	11 24       	eor	r1, r1
    3698:	fa 01       	movw	r30, r20
    369a:	e0 5e       	subi	r30, 0xE0	; 224
    369c:	fe 4f       	sbci	r31, 0xFE	; 254
    369e:	15 86       	std	Z+13, r1	; 0x0d
    36a0:	16 86       	std	Z+14, r1	; 0x0e
    36a2:	17 86       	std	Z+15, r1	; 0x0f
    36a4:	10 8a       	std	Z+16, r1	; 0x10
  block->millimeters = 0;
    36a6:	15 a2       	std	Z+37, r1	; 0x25
    36a8:	16 a2       	std	Z+38, r1	; 0x26
    36aa:	17 a2       	std	Z+39, r1	; 0x27
    36ac:	10 a6       	std	Z+40, r1	; 0x28
  block->direction_bits = 0;
    36ae:	10 82       	st	Z, r1
  block->acceleration = SOME_LARGE_VALUE; // Scaled down to maximum acceleration later
    36b0:	0f 2e       	mov	r0, r31
    36b2:	f9 e9       	ldi	r31, 0x99	; 153
    36b4:	cf 2e       	mov	r12, r31
    36b6:	f6 e7       	ldi	r31, 0x76	; 118
    36b8:	df 2e       	mov	r13, r31
    36ba:	f6 e9       	ldi	r31, 0x96	; 150
    36bc:	ef 2e       	mov	r14, r31
    36be:	fe e7       	ldi	r31, 0x7E	; 126
    36c0:	ff 2e       	mov	r15, r31
    36c2:	f0 2d       	mov	r31, r0
    36c4:	c1 a2       	std	Z+33, r12	; 0x21
    36c6:	d2 a2       	std	Z+34, r13	; 0x22
    36c8:	e3 a2       	std	Z+35, r14	; 0x23
    36ca:	f4 a2       	std	Z+36, r15	; 0x24
    36cc:	9a 8f       	std	Y+26, r25	; 0x1a
    36ce:	89 8f       	std	Y+25, r24	; 0x19
    36d0:	8f e7       	ldi	r24, 0x7F	; 127
    36d2:	96 e0       	ldi	r25, 0x06	; 6
    36d4:	9a ab       	std	Y+50, r25	; 0x32
    36d6:	89 ab       	std	Y+49, r24	; 0x31
    36d8:	de 01       	movw	r26, r28
    36da:	11 96       	adiw	r26, 0x01	; 1
    36dc:	bc 8f       	std	Y+28, r27	; 0x1c
    36de:	ab 8f       	std	Y+27, r26	; 0x1b
    36e0:	e0 e0       	ldi	r30, 0x00	; 0
    36e2:	f1 e0       	ldi	r31, 0x01	; 1
    36e4:	fc ab       	std	Y+52, r31	; 0x34
    36e6:	eb ab       	std	Y+51, r30	; 0x33
    36e8:	ca 01       	movw	r24, r20
    36ea:	8f 5d       	subi	r24, 0xDF	; 223
    36ec:	9e 4f       	sbci	r25, 0xFE	; 254
    36ee:	9e 8f       	std	Y+30, r25	; 0x1e
    36f0:	8d 8f       	std	Y+29, r24	; 0x1d
    36f2:	4e 01       	movw	r8, r28
    36f4:	9d e0       	ldi	r25, 0x0D	; 13
    36f6:	89 0e       	add	r8, r25
    36f8:	91 1c       	adc	r9, r1
    36fa:	9a a2       	std	Y+34, r9	; 0x22
    36fc:	89 a2       	std	Y+33, r8	; 0x21
    36fe:	5f 01       	movw	r10, r30
    3700:	af e7       	ldi	r26, 0x7F	; 127
    3702:	b6 e0       	ldi	r27, 0x06	; 6
    3704:	bc a3       	std	Y+36, r27	; 0x24
    3706:	ab a3       	std	Y+35, r26	; 0x23
    target_steps[B_MOTOR] = lround(target[B_MOTOR]*settings.steps_per_mm[B_MOTOR]);
    block->steps[A_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) + (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
    block->steps[B_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) - (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
  #endif

  for (idx=0; idx<N_AXIS; idx++) {
    3708:	10 e0       	ldi	r17, 0x00	; 0
        delta_mm = (target_steps[idx] - pl.position[idx])/settings.steps_per_mm[idx];
      }
    #else
      target_steps[idx] = lround(target[idx]*settings.steps_per_mm[idx]);
      block->steps[idx] = labs(target_steps[idx]-pl.position[idx]);
      block->step_event_count = max(block->step_event_count, block->steps[idx]);
    370a:	e2 2f       	mov	r30, r18
    370c:	f0 e0       	ldi	r31, 0x00	; 0
    370e:	f8 ab       	std	Y+48, r31	; 0x30
    3710:	ef a7       	std	Y+47, r30	; 0x2f
    3712:	9a 01       	movw	r18, r20
    3714:	20 5e       	subi	r18, 0xE0	; 224
    3716:	3e 4f       	sbci	r19, 0xFE	; 254
    3718:	3a a7       	std	Y+42, r19	; 0x2a
    371a:	29 a7       	std	Y+41, r18	; 0x29
    371c:	23 5f       	subi	r18, 0xF3	; 243
    371e:	3f 4f       	sbci	r19, 0xFF	; 255
    3720:	38 a7       	std	Y+40, r19	; 0x28
    3722:	2f a3       	std	Y+39, r18	; 0x27
        
    // Set direction bits. Bit enabled always means direction is negative.
    if (delta_mm < 0 ) { block->direction_bits |= get_direction_pin_mask(idx); }
    
    // Incrementally compute total move distance by Euclidean norm. First add square of each term.
    block->millimeters += delta_mm*delta_mm;
    3724:	29 a4       	ldd	r2, Y+41	; 0x29
    3726:	3a a4       	ldd	r3, Y+42	; 0x2a
    3728:	35 e2       	ldi	r19, 0x25	; 37
    372a:	23 0e       	add	r2, r19
    372c:	31 1c       	adc	r3, r1
        delta_mm = (target_steps[X_AXIS]-pl.position[X_AXIS] - target_steps[Y_AXIS]+pl.position[Y_AXIS])/settings.steps_per_mm[idx];
      } else {
        delta_mm = (target_steps[idx] - pl.position[idx])/settings.steps_per_mm[idx];
      }
    #else
      target_steps[idx] = lround(target[idx]*settings.steps_per_mm[idx]);
    372e:	a9 8d       	ldd	r26, Y+25	; 0x19
    3730:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3732:	6d 91       	ld	r22, X+
    3734:	7d 91       	ld	r23, X+
    3736:	8d 91       	ld	r24, X+
    3738:	9d 91       	ld	r25, X+
    373a:	ba 8f       	std	Y+26, r27	; 0x1a
    373c:	a9 8f       	std	Y+25, r26	; 0x19
    373e:	eb a1       	ldd	r30, Y+35	; 0x23
    3740:	fc a1       	ldd	r31, Y+36	; 0x24
    3742:	41 90       	ld	r4, Z+
    3744:	51 90       	ld	r5, Z+
    3746:	61 90       	ld	r6, Z+
    3748:	71 90       	ld	r7, Z+
    374a:	fc a3       	std	Y+36, r31	; 0x24
    374c:	eb a3       	std	Y+35, r30	; 0x23
    374e:	a3 01       	movw	r20, r6
    3750:	92 01       	movw	r18, r4
    3752:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    3756:	0e 94 ce 3b 	call	0x779c	; 0x779c <lround>
    375a:	ab 8d       	ldd	r26, Y+27	; 0x1b
    375c:	bc 8d       	ldd	r27, Y+28	; 0x1c
    375e:	6d 93       	st	X+, r22
    3760:	7d 93       	st	X+, r23
    3762:	8d 93       	st	X+, r24
    3764:	9d 93       	st	X+, r25
    3766:	bc 8f       	std	Y+28, r27	; 0x1c
    3768:	ab 8f       	std	Y+27, r26	; 0x1b
      block->steps[idx] = labs(target_steps[idx]-pl.position[idx]);
    376a:	f5 01       	movw	r30, r10
    376c:	c1 90       	ld	r12, Z+
    376e:	d1 90       	ld	r13, Z+
    3770:	e1 90       	ld	r14, Z+
    3772:	f1 90       	ld	r15, Z+
    3774:	5f 01       	movw	r10, r30
    3776:	6c 19       	sub	r22, r12
    3778:	7d 09       	sbc	r23, r13
    377a:	8e 09       	sbc	r24, r14
    377c:	9f 09       	sbc	r25, r15
    377e:	9b 01       	movw	r18, r22
    3780:	ac 01       	movw	r20, r24
    3782:	3a f4       	brpl	.+14     	; 0x3792 <plan_buffer_line+0x144>
    3784:	22 27       	eor	r18, r18
    3786:	33 27       	eor	r19, r19
    3788:	a9 01       	movw	r20, r18
    378a:	26 1b       	sub	r18, r22
    378c:	37 0b       	sbc	r19, r23
    378e:	48 0b       	sbc	r20, r24
    3790:	59 0b       	sbc	r21, r25
    3792:	ad 8d       	ldd	r26, Y+29	; 0x1d
    3794:	be 8d       	ldd	r27, Y+30	; 0x1e
    3796:	2d 93       	st	X+, r18
    3798:	3d 93       	st	X+, r19
    379a:	4d 93       	st	X+, r20
    379c:	5d 93       	st	X+, r21
    379e:	be 8f       	std	Y+30, r27	; 0x1e
    37a0:	ad 8f       	std	Y+29, r26	; 0x1d
      block->step_event_count = max(block->step_event_count, block->steps[idx]);
    37a2:	ef a1       	ldd	r30, Y+39	; 0x27
    37a4:	f8 a5       	ldd	r31, Y+40	; 0x28
    37a6:	c0 80       	ld	r12, Z
    37a8:	d1 80       	ldd	r13, Z+1	; 0x01
    37aa:	e2 80       	ldd	r14, Z+2	; 0x02
    37ac:	f3 80       	ldd	r15, Z+3	; 0x03
    37ae:	c2 16       	cp	r12, r18
    37b0:	d3 06       	cpc	r13, r19
    37b2:	e4 06       	cpc	r14, r20
    37b4:	f5 06       	cpc	r15, r21
    37b6:	10 f4       	brcc	.+4      	; 0x37bc <plan_buffer_line+0x16e>
    37b8:	69 01       	movw	r12, r18
    37ba:	7a 01       	movw	r14, r20
    37bc:	af a1       	ldd	r26, Y+39	; 0x27
    37be:	b8 a5       	ldd	r27, Y+40	; 0x28
    37c0:	cd 92       	st	X+, r12
    37c2:	dd 92       	st	X+, r13
    37c4:	ed 92       	st	X+, r14
    37c6:	fc 92       	st	X, r15
    37c8:	13 97       	sbiw	r26, 0x03	; 3
      delta_mm = (target_steps[idx] - pl.position[idx])/settings.steps_per_mm[idx];
    37ca:	0e 94 53 3a 	call	0x74a6	; 0x74a6 <__floatsisf>
    37ce:	a3 01       	movw	r20, r6
    37d0:	92 01       	movw	r18, r4
    37d2:	0e 94 a9 39 	call	0x7352	; 0x7352 <__divsf3>
    37d6:	2b 01       	movw	r4, r22
    37d8:	3c 01       	movw	r6, r24
    #endif
    unit_vec[idx] = delta_mm; // Store unit vector numerator. Denominator computed later.
    37da:	e9 a1       	ldd	r30, Y+33	; 0x21
    37dc:	fa a1       	ldd	r31, Y+34	; 0x22
    37de:	61 93       	st	Z+, r22
    37e0:	71 93       	st	Z+, r23
    37e2:	81 93       	st	Z+, r24
    37e4:	91 93       	st	Z+, r25
    37e6:	fa a3       	std	Y+34, r31	; 0x22
    37e8:	e9 a3       	std	Y+33, r30	; 0x21
        
    // Set direction bits. Bit enabled always means direction is negative.
    if (delta_mm < 0 ) { block->direction_bits |= get_direction_pin_mask(idx); }
    37ea:	20 e0       	ldi	r18, 0x00	; 0
    37ec:	30 e0       	ldi	r19, 0x00	; 0
    37ee:	a9 01       	movw	r20, r18
    37f0:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    37f4:	88 23       	and	r24, r24
    37f6:	44 f4       	brge	.+16     	; 0x3808 <plan_buffer_line+0x1ba>
    37f8:	81 2f       	mov	r24, r17
    37fa:	0e 94 a7 2b 	call	0x574e	; 0x574e <get_direction_pin_mask>
    37fe:	a9 a5       	ldd	r26, Y+41	; 0x29
    3800:	ba a5       	ldd	r27, Y+42	; 0x2a
    3802:	9c 91       	ld	r25, X
    3804:	89 2b       	or	r24, r25
    3806:	8c 93       	st	X, r24
    
    // Incrementally compute total move distance by Euclidean norm. First add square of each term.
    block->millimeters += delta_mm*delta_mm;
    3808:	a3 01       	movw	r20, r6
    380a:	92 01       	movw	r18, r4
    380c:	c3 01       	movw	r24, r6
    380e:	b2 01       	movw	r22, r4
    3810:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    3814:	f1 01       	movw	r30, r2
    3816:	20 81       	ld	r18, Z
    3818:	31 81       	ldd	r19, Z+1	; 0x01
    381a:	42 81       	ldd	r20, Z+2	; 0x02
    381c:	53 81       	ldd	r21, Z+3	; 0x03
    381e:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    3822:	d1 01       	movw	r26, r2
    3824:	6d 93       	st	X+, r22
    3826:	7d 93       	st	X+, r23
    3828:	8d 93       	st	X+, r24
    382a:	9c 93       	st	X, r25
    382c:	13 97       	sbiw	r26, 0x03	; 3
    target_steps[B_MOTOR] = lround(target[B_MOTOR]*settings.steps_per_mm[B_MOTOR]);
    block->steps[A_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) + (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
    block->steps[B_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) - (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
  #endif

  for (idx=0; idx<N_AXIS; idx++) {
    382e:	1f 5f       	subi	r17, 0xFF	; 255
    3830:	13 30       	cpi	r17, 0x03	; 3
    3832:	09 f0       	breq	.+2      	; 0x3836 <plan_buffer_line+0x1e8>
    3834:	7c cf       	rjmp	.-264    	; 0x372e <plan_buffer_line+0xe0>
    if (delta_mm < 0 ) { block->direction_bits |= get_direction_pin_mask(idx); }
    
    // Incrementally compute total move distance by Euclidean norm. First add square of each term.
    block->millimeters += delta_mm*delta_mm;
  }
  block->millimeters = sqrt(block->millimeters); // Complete millimeters calculation with sqrt()
    3836:	0e 94 a0 3c 	call	0x7940	; 0x7940 <sqrt>
    383a:	6b 01       	movw	r12, r22
    383c:	7c 01       	movw	r14, r24
    383e:	89 e2       	ldi	r24, 0x29	; 41
    3840:	2f a5       	ldd	r18, Y+47	; 0x2f
    3842:	38 a9       	ldd	r19, Y+48	; 0x30
    3844:	82 9f       	mul	r24, r18
    3846:	f0 01       	movw	r30, r0
    3848:	83 9f       	mul	r24, r19
    384a:	f0 0d       	add	r31, r0
    384c:	11 24       	eor	r1, r1
    384e:	e0 5e       	subi	r30, 0xE0	; 224
    3850:	fe 4f       	sbci	r31, 0xFE	; 254
    3852:	c5 a2       	std	Z+37, r12	; 0x25
    3854:	d6 a2       	std	Z+38, r13	; 0x26
    3856:	e7 a2       	std	Z+39, r14	; 0x27
    3858:	f0 a6       	std	Z+40, r15	; 0x28
  
  // Bail if this is a zero-length block. Highly unlikely to occur.
  if (block->step_event_count == 0) { return; } 
    385a:	85 85       	ldd	r24, Z+13	; 0x0d
    385c:	96 85       	ldd	r25, Z+14	; 0x0e
    385e:	a7 85       	ldd	r26, Z+15	; 0x0f
    3860:	b0 89       	ldd	r27, Z+16	; 0x10
    3862:	89 2b       	or	r24, r25
    3864:	8a 2b       	or	r24, r26
    3866:	8b 2b       	or	r24, r27
    3868:	09 f4       	brne	.+2      	; 0x386c <plan_buffer_line+0x21e>
    386a:	47 c2       	rjmp	.+1166   	; 0x3cfa <plan_buffer_line+0x6ac>
  
  // Adjust feed_rate value to mm/min depending on type of rate input (normal, inverse time, or rapids)
  // TODO: Need to distinguish a rapids vs feed move for overrides. Some flag of some sort.
  if (feed_rate < 0) { feed_rate = SOME_LARGE_VALUE; } // Scaled down to absolute max/rapids rate later
    386c:	20 e0       	ldi	r18, 0x00	; 0
    386e:	30 e0       	ldi	r19, 0x00	; 0
    3870:	a9 01       	movw	r20, r18
    3872:	6b a5       	ldd	r22, Y+43	; 0x2b
    3874:	7c a5       	ldd	r23, Y+44	; 0x2c
    3876:	8d a5       	ldd	r24, Y+45	; 0x2d
    3878:	9e a5       	ldd	r25, Y+46	; 0x2e
    387a:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    387e:	88 23       	and	r24, r24
    3880:	0c f1       	brlt	.+66     	; 0x38c4 <plan_buffer_line+0x276>
  else if (invert_feed_rate) { feed_rate *= block->millimeters; }
    3882:	00 23       	and	r16, r16
    3884:	61 f0       	breq	.+24     	; 0x389e <plan_buffer_line+0x250>
    3886:	a7 01       	movw	r20, r14
    3888:	96 01       	movw	r18, r12
    388a:	6b a5       	ldd	r22, Y+43	; 0x2b
    388c:	7c a5       	ldd	r23, Y+44	; 0x2c
    388e:	8d a5       	ldd	r24, Y+45	; 0x2d
    3890:	9e a5       	ldd	r25, Y+46	; 0x2e
    3892:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    3896:	6b a7       	std	Y+43, r22	; 0x2b
    3898:	7c a7       	std	Y+44, r23	; 0x2c
    389a:	8d a7       	std	Y+45, r24	; 0x2d
    389c:	9e a7       	std	Y+46, r25	; 0x2e
  if (feed_rate < MINIMUM_FEED_RATE) { feed_rate = MINIMUM_FEED_RATE; } // Prevents step generation round-off condition.
    389e:	20 e0       	ldi	r18, 0x00	; 0
    38a0:	30 e0       	ldi	r19, 0x00	; 0
    38a2:	40 e8       	ldi	r20, 0x80	; 128
    38a4:	5f e3       	ldi	r21, 0x3F	; 63
    38a6:	6b a5       	ldd	r22, Y+43	; 0x2b
    38a8:	7c a5       	ldd	r23, Y+44	; 0x2c
    38aa:	8d a5       	ldd	r24, Y+45	; 0x2d
    38ac:	9e a5       	ldd	r25, Y+46	; 0x2e
    38ae:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    38b2:	88 23       	and	r24, r24
    38b4:	7c f4       	brge	.+30     	; 0x38d4 <plan_buffer_line+0x286>
    38b6:	1b a6       	std	Y+43, r1	; 0x2b
    38b8:	1c a6       	std	Y+44, r1	; 0x2c
    38ba:	30 e8       	ldi	r19, 0x80	; 128
    38bc:	3d a7       	std	Y+45, r19	; 0x2d
    38be:	4f e3       	ldi	r20, 0x3F	; 63
    38c0:	4e a7       	std	Y+46, r20	; 0x2e
    38c2:	08 c0       	rjmp	.+16     	; 0x38d4 <plan_buffer_line+0x286>
  // Bail if this is a zero-length block. Highly unlikely to occur.
  if (block->step_event_count == 0) { return; } 
  
  // Adjust feed_rate value to mm/min depending on type of rate input (normal, inverse time, or rapids)
  // TODO: Need to distinguish a rapids vs feed move for overrides. Some flag of some sort.
  if (feed_rate < 0) { feed_rate = SOME_LARGE_VALUE; } // Scaled down to absolute max/rapids rate later
    38c4:	59 e9       	ldi	r21, 0x99	; 153
    38c6:	5b a7       	std	Y+43, r21	; 0x2b
    38c8:	86 e7       	ldi	r24, 0x76	; 118
    38ca:	8c a7       	std	Y+44, r24	; 0x2c
    38cc:	96 e9       	ldi	r25, 0x96	; 150
    38ce:	9d a7       	std	Y+45, r25	; 0x2d
    38d0:	ae e7       	ldi	r26, 0x7E	; 126
    38d2:	ae a7       	std	Y+46, r26	; 0x2e
  // Calculate the unit vector of the line move and the block maximum feed rate and acceleration scaled 
  // down such that no individual axes maximum values are exceeded with respect to the line direction. 
  // NOTE: This calculation assumes all axes are orthogonal (Cartesian) and works with ABC-axes,
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  float inverse_unit_vec_value;
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple float divides	
    38d4:	a7 01       	movw	r20, r14
    38d6:	96 01       	movw	r18, r12
    38d8:	60 e0       	ldi	r22, 0x00	; 0
    38da:	70 e0       	ldi	r23, 0x00	; 0
    38dc:	80 e8       	ldi	r24, 0x80	; 128
    38de:	9f e3       	ldi	r25, 0x3F	; 63
    38e0:	0e 94 a9 39 	call	0x7352	; 0x7352 <__divsf3>
    38e4:	6d ab       	std	Y+53, r22	; 0x35
    38e6:	7e ab       	std	Y+54, r23	; 0x36
    38e8:	8f ab       	std	Y+55, r24	; 0x37
    38ea:	98 af       	std	Y+56, r25	; 0x38
    38ec:	2e 01       	movw	r4, r28
    38ee:	b9 e1       	ldi	r27, 0x19	; 25
    38f0:	4b 0e       	add	r4, r27
    38f2:	51 1c       	adc	r5, r1
  float junction_cos_theta = 0;
    38f4:	1b a2       	std	Y+35, r1	; 0x23
    38f6:	1c a2       	std	Y+36, r1	; 0x24
    38f8:	1d a2       	std	Y+37, r1	; 0x25
    38fa:	1e a2       	std	Y+38, r1	; 0x26
      unit_vec[idx] *= inverse_millimeters;  // Complete unit vector calculation
      inverse_unit_vec_value = fabs(1.0/unit_vec[idx]); // Inverse to remove multiple float divides.

      // Check and limit feed rate against max individual axis velocities and accelerations
      feed_rate = min(feed_rate,settings.max_rate[idx]*inverse_unit_vec_value);
      block->acceleration = min(block->acceleration,settings.acceleration[idx]*inverse_unit_vec_value);
    38fc:	29 e2       	ldi	r18, 0x29	; 41
    38fe:	ef a5       	ldd	r30, Y+47	; 0x2f
    3900:	f8 a9       	ldd	r31, Y+48	; 0x30
    3902:	2e 9f       	mul	r18, r30
    3904:	c0 01       	movw	r24, r0
    3906:	2f 9f       	mul	r18, r31
    3908:	90 0d       	add	r25, r0
    390a:	11 24       	eor	r1, r1
    390c:	9c 01       	movw	r18, r24
    390e:	2f 5b       	subi	r18, 0xBF	; 191
    3910:	3e 4f       	sbci	r19, 0xFE	; 254
    3912:	19 01       	movw	r2, r18
    3914:	69 a8       	ldd	r6, Y+49	; 0x31
    3916:	7a a8       	ldd	r7, Y+50	; 0x32
    3918:	0b a9       	ldd	r16, Y+51	; 0x33
    391a:	1c a9       	ldd	r17, Y+52	; 0x34
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  float inverse_unit_vec_value;
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple float divides	
  float junction_cos_theta = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
    391c:	d4 01       	movw	r26, r8
    391e:	cd 90       	ld	r12, X+
    3920:	dd 90       	ld	r13, X+
    3922:	ed 90       	ld	r14, X+
    3924:	fc 90       	ld	r15, X
    3926:	20 e0       	ldi	r18, 0x00	; 0
    3928:	30 e0       	ldi	r19, 0x00	; 0
    392a:	a9 01       	movw	r20, r18
    392c:	c7 01       	movw	r24, r14
    392e:	b6 01       	movw	r22, r12
    3930:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    3934:	88 23       	and	r24, r24
    3936:	09 f4       	brne	.+2      	; 0x393a <plan_buffer_line+0x2ec>
    3938:	8d c0       	rjmp	.+282    	; 0x3a54 <plan_buffer_line+0x406>
      unit_vec[idx] *= inverse_millimeters;  // Complete unit vector calculation
    393a:	a7 01       	movw	r20, r14
    393c:	96 01       	movw	r18, r12
    393e:	6d a9       	ldd	r22, Y+53	; 0x35
    3940:	7e a9       	ldd	r23, Y+54	; 0x36
    3942:	8f a9       	ldd	r24, Y+55	; 0x37
    3944:	98 ad       	ldd	r25, Y+56	; 0x38
    3946:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    394a:	6b 01       	movw	r12, r22
    394c:	7c 01       	movw	r14, r24
    394e:	f4 01       	movw	r30, r8
    3950:	60 83       	st	Z, r22
    3952:	71 83       	std	Z+1, r23	; 0x01
    3954:	82 83       	std	Z+2, r24	; 0x02
    3956:	93 83       	std	Z+3, r25	; 0x03
      inverse_unit_vec_value = fabs(1.0/unit_vec[idx]); // Inverse to remove multiple float divides.
    3958:	9b 01       	movw	r18, r22
    395a:	ac 01       	movw	r20, r24
    395c:	60 e0       	ldi	r22, 0x00	; 0
    395e:	70 e0       	ldi	r23, 0x00	; 0
    3960:	80 e8       	ldi	r24, 0x80	; 128
    3962:	9f e3       	ldi	r25, 0x3F	; 63
    3964:	0e 94 a9 39 	call	0x7352	; 0x7352 <__divsf3>
    3968:	9b 01       	movw	r18, r22
    396a:	ac 01       	movw	r20, r24
    396c:	5f 77       	andi	r21, 0x7F	; 127
    396e:	2d 8f       	std	Y+29, r18	; 0x1d
    3970:	3e 8f       	std	Y+30, r19	; 0x1e
    3972:	4f 8f       	std	Y+31, r20	; 0x1f
    3974:	58 a3       	std	Y+32, r21	; 0x20
    3976:	7a a2       	std	Y+34, r7	; 0x22
    3978:	69 a2       	std	Y+33, r6	; 0x21

      // Check and limit feed rate against max individual axis velocities and accelerations
      feed_rate = min(feed_rate,settings.max_rate[idx]*inverse_unit_vec_value);
    397a:	d3 01       	movw	r26, r6
    397c:	1c 96       	adiw	r26, 0x0c	; 12
    397e:	2d 91       	ld	r18, X+
    3980:	3d 91       	ld	r19, X+
    3982:	4d 91       	ld	r20, X+
    3984:	5c 91       	ld	r21, X
    3986:	1f 97       	sbiw	r26, 0x0f	; 15
    3988:	6d 8d       	ldd	r22, Y+29	; 0x1d
    398a:	7e 8d       	ldd	r23, Y+30	; 0x1e
    398c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    398e:	98 a1       	ldd	r25, Y+32	; 0x20
    3990:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    3994:	69 8f       	std	Y+25, r22	; 0x19
    3996:	7b 8f       	std	Y+27, r23	; 0x1b
    3998:	b8 2e       	mov	r11, r24
    399a:	a9 2e       	mov	r10, r25
    399c:	2b a5       	ldd	r18, Y+43	; 0x2b
    399e:	3c a5       	ldd	r19, Y+44	; 0x2c
    39a0:	4d a5       	ldd	r20, Y+45	; 0x2d
    39a2:	5e a5       	ldd	r21, Y+46	; 0x2e
    39a4:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    39a8:	18 16       	cp	r1, r24
    39aa:	34 f0       	brlt	.+12     	; 0x39b8 <plan_buffer_line+0x36a>
    39ac:	b9 8d       	ldd	r27, Y+25	; 0x19
    39ae:	bb a7       	std	Y+43, r27	; 0x2b
    39b0:	eb 8d       	ldd	r30, Y+27	; 0x1b
    39b2:	ec a7       	std	Y+44, r30	; 0x2c
    39b4:	bd a6       	std	Y+45, r11	; 0x2d
    39b6:	ae a6       	std	Y+46, r10	; 0x2e
      block->acceleration = min(block->acceleration,settings.acceleration[idx]*inverse_unit_vec_value);
    39b8:	d1 01       	movw	r26, r2
    39ba:	bc 91       	ld	r27, X
    39bc:	b9 8f       	std	Y+25, r27	; 0x19
    39be:	f1 01       	movw	r30, r2
    39c0:	f1 81       	ldd	r31, Z+1	; 0x01
    39c2:	fb 8f       	std	Y+27, r31	; 0x1b
    39c4:	d1 01       	movw	r26, r2
    39c6:	12 96       	adiw	r26, 0x02	; 2
    39c8:	ac 90       	ld	r10, X
    39ca:	12 97       	sbiw	r26, 0x02	; 2
    39cc:	13 96       	adiw	r26, 0x03	; 3
    39ce:	bc 90       	ld	r11, X
    39d0:	e9 a1       	ldd	r30, Y+33	; 0x21
    39d2:	fa a1       	ldd	r31, Y+34	; 0x22
    39d4:	20 8d       	ldd	r18, Z+24	; 0x18
    39d6:	31 8d       	ldd	r19, Z+25	; 0x19
    39d8:	42 8d       	ldd	r20, Z+26	; 0x1a
    39da:	53 8d       	ldd	r21, Z+27	; 0x1b
    39dc:	6d 8d       	ldd	r22, Y+29	; 0x1d
    39de:	7e 8d       	ldd	r23, Y+30	; 0x1e
    39e0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    39e2:	98 a1       	ldd	r25, Y+32	; 0x20
    39e4:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    39e8:	6d 8f       	std	Y+29, r22	; 0x1d
    39ea:	79 a3       	std	Y+33, r23	; 0x21
    39ec:	8f a3       	std	Y+39, r24	; 0x27
    39ee:	99 a7       	std	Y+41, r25	; 0x29
    39f0:	26 2f       	mov	r18, r22
    39f2:	37 2f       	mov	r19, r23
    39f4:	48 2f       	mov	r20, r24
    39f6:	59 2f       	mov	r21, r25
    39f8:	69 8d       	ldd	r22, Y+25	; 0x19
    39fa:	7b 8d       	ldd	r23, Y+27	; 0x1b
    39fc:	8a 2d       	mov	r24, r10
    39fe:	9b 2d       	mov	r25, r11
    3a00:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    3a04:	88 23       	and	r24, r24
    3a06:	34 f0       	brlt	.+12     	; 0x3a14 <plan_buffer_line+0x3c6>
    3a08:	fd 8d       	ldd	r31, Y+29	; 0x1d
    3a0a:	f9 8f       	std	Y+25, r31	; 0x19
    3a0c:	29 a1       	ldd	r18, Y+33	; 0x21
    3a0e:	2b 8f       	std	Y+27, r18	; 0x1b
    3a10:	af a0       	ldd	r10, Y+39	; 0x27
    3a12:	b9 a4       	ldd	r11, Y+41	; 0x29
    3a14:	89 8d       	ldd	r24, Y+25	; 0x19
    3a16:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3a18:	aa 2d       	mov	r26, r10
    3a1a:	bb 2d       	mov	r27, r11
    3a1c:	f1 01       	movw	r30, r2
    3a1e:	80 83       	st	Z, r24
    3a20:	91 83       	std	Z+1, r25	; 0x01
    3a22:	a2 83       	std	Z+2, r26	; 0x02
    3a24:	b3 83       	std	Z+3, r27	; 0x03

      // Incrementally compute cosine of angle between previous and current path. Cos(theta) of the junction
      // between the current move and the previous move is simply the dot product of the two unit vectors, 
      // where prev_unit_vec is negative. Used later to compute maximum junction speed.
      junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
    3a26:	d8 01       	movw	r26, r16
    3a28:	1c 96       	adiw	r26, 0x0c	; 12
    3a2a:	2d 91       	ld	r18, X+
    3a2c:	3d 91       	ld	r19, X+
    3a2e:	4d 91       	ld	r20, X+
    3a30:	5c 91       	ld	r21, X
    3a32:	1f 97       	sbiw	r26, 0x0f	; 15
    3a34:	c7 01       	movw	r24, r14
    3a36:	b6 01       	movw	r22, r12
    3a38:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    3a3c:	9b 01       	movw	r18, r22
    3a3e:	ac 01       	movw	r20, r24
    3a40:	6b a1       	ldd	r22, Y+35	; 0x23
    3a42:	7c a1       	ldd	r23, Y+36	; 0x24
    3a44:	8d a1       	ldd	r24, Y+37	; 0x25
    3a46:	9e a1       	ldd	r25, Y+38	; 0x26
    3a48:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    3a4c:	6b a3       	std	Y+35, r22	; 0x23
    3a4e:	7c a3       	std	Y+36, r23	; 0x24
    3a50:	8d a3       	std	Y+37, r24	; 0x25
    3a52:	9e a3       	std	Y+38, r25	; 0x26
    3a54:	b4 e0       	ldi	r27, 0x04	; 4
    3a56:	8b 0e       	add	r8, r27
    3a58:	91 1c       	adc	r9, r1
    3a5a:	0c 5f       	subi	r16, 0xFC	; 252
    3a5c:	1f 4f       	sbci	r17, 0xFF	; 255
    3a5e:	e4 e0       	ldi	r30, 0x04	; 4
    3a60:	6e 0e       	add	r6, r30
    3a62:	71 1c       	adc	r7, r1
  // NOTE: This calculation assumes all axes are orthogonal (Cartesian) and works with ABC-axes,
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  float inverse_unit_vec_value;
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple float divides	
  float junction_cos_theta = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    3a64:	84 14       	cp	r8, r4
    3a66:	95 04       	cpc	r9, r5
    3a68:	09 f0       	breq	.+2      	; 0x3a6c <plan_buffer_line+0x41e>
    3a6a:	58 cf       	rjmp	.-336    	; 0x391c <plan_buffer_line+0x2ce>
      junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
    }
  }
  
  // TODO: Need to check this method handling zero junction speeds when starting from rest.
  if (block_buffer_head == block_buffer_tail) {
    3a6c:	90 91 1e 01 	lds	r25, 0x011E	; 0x80011e <block_buffer_head>
    3a70:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <block_buffer_tail>
    3a74:	98 13       	cpse	r25, r24
    3a76:	13 c0       	rjmp	.+38     	; 0x3a9e <plan_buffer_line+0x450>
  
    // Initialize block entry speed as zero. Assume it will be starting from rest. Planner will correct this later.
    block->entry_speed_sqr = 0.0;
    3a78:	89 e2       	ldi	r24, 0x29	; 41
    3a7a:	2f a5       	ldd	r18, Y+47	; 0x2f
    3a7c:	38 a9       	ldd	r19, Y+48	; 0x30
    3a7e:	82 9f       	mul	r24, r18
    3a80:	f0 01       	movw	r30, r0
    3a82:	83 9f       	mul	r24, r19
    3a84:	f0 0d       	add	r31, r0
    3a86:	11 24       	eor	r1, r1
    3a88:	e0 5e       	subi	r30, 0xE0	; 224
    3a8a:	fe 4f       	sbci	r31, 0xFE	; 254
    3a8c:	11 8a       	std	Z+17, r1	; 0x11
    3a8e:	12 8a       	std	Z+18, r1	; 0x12
    3a90:	13 8a       	std	Z+19, r1	; 0x13
    3a92:	14 8a       	std	Z+20, r1	; 0x14
    block->max_junction_speed_sqr = 0.0; // Starting from rest. Enforce start from zero velocity.
    3a94:	11 8e       	std	Z+25, r1	; 0x19
    3a96:	12 8e       	std	Z+26, r1	; 0x1a
    3a98:	13 8e       	std	Z+27, r1	; 0x1b
    3a9a:	14 8e       	std	Z+28, r1	; 0x1c
    3a9c:	90 c0       	rjmp	.+288    	; 0x3bbe <plan_buffer_line+0x570>
       changed dynamically during operation nor can the line move geometry. This must be kept in
       memory in the event of a feedrate override changing the nominal speeds of blocks, which can 
       change the overall maximum entry speed conditions of all blocks.
    */
    // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
    if (junction_cos_theta > 0.999999) {
    3a9e:	2f ee       	ldi	r18, 0xEF	; 239
    3aa0:	3f ef       	ldi	r19, 0xFF	; 255
    3aa2:	4f e7       	ldi	r20, 0x7F	; 127
    3aa4:	5f e3       	ldi	r21, 0x3F	; 63
    3aa6:	6b a1       	ldd	r22, Y+35	; 0x23
    3aa8:	7c a1       	ldd	r23, Y+36	; 0x24
    3aaa:	8d a1       	ldd	r24, Y+37	; 0x25
    3aac:	9e a1       	ldd	r25, Y+38	; 0x26
    3aae:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    3ab2:	18 16       	cp	r1, r24
    3ab4:	7c f4       	brge	.+30     	; 0x3ad4 <plan_buffer_line+0x486>
      //  For a 0 degree acute junction, just set minimum junction speed. 
      block->max_junction_speed_sqr = MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED;
    3ab6:	89 e2       	ldi	r24, 0x29	; 41
    3ab8:	4f a5       	ldd	r20, Y+47	; 0x2f
    3aba:	58 a9       	ldd	r21, Y+48	; 0x30
    3abc:	84 9f       	mul	r24, r20
    3abe:	f0 01       	movw	r30, r0
    3ac0:	85 9f       	mul	r24, r21
    3ac2:	f0 0d       	add	r31, r0
    3ac4:	11 24       	eor	r1, r1
    3ac6:	e0 5e       	subi	r30, 0xE0	; 224
    3ac8:	fe 4f       	sbci	r31, 0xFE	; 254
    3aca:	11 8e       	std	Z+25, r1	; 0x19
    3acc:	12 8e       	std	Z+26, r1	; 0x1a
    3ace:	13 8e       	std	Z+27, r1	; 0x1b
    3ad0:	14 8e       	std	Z+28, r1	; 0x1c
    3ad2:	75 c0       	rjmp	.+234    	; 0x3bbe <plan_buffer_line+0x570>
    } else {
      junction_cos_theta = max(junction_cos_theta,-0.999999); // Check for numerical round-off to avoid divide by zero.
    3ad4:	2f ee       	ldi	r18, 0xEF	; 239
    3ad6:	3f ef       	ldi	r19, 0xFF	; 255
    3ad8:	4f e7       	ldi	r20, 0x7F	; 127
    3ada:	5f eb       	ldi	r21, 0xBF	; 191
    3adc:	6b a1       	ldd	r22, Y+35	; 0x23
    3ade:	7c a1       	ldd	r23, Y+36	; 0x24
    3ae0:	8d a1       	ldd	r24, Y+37	; 0x25
    3ae2:	9e a1       	ldd	r25, Y+38	; 0x26
    3ae4:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    3ae8:	18 16       	cp	r1, r24
    3aea:	44 f0       	brlt	.+16     	; 0x3afc <plan_buffer_line+0x4ae>
    3aec:	8f ee       	ldi	r24, 0xEF	; 239
    3aee:	9f ef       	ldi	r25, 0xFF	; 255
    3af0:	af e7       	ldi	r26, 0x7F	; 127
    3af2:	bf eb       	ldi	r27, 0xBF	; 191
    3af4:	8b a3       	std	Y+35, r24	; 0x23
    3af6:	9c a3       	std	Y+36, r25	; 0x24
    3af8:	ad a3       	std	Y+37, r26	; 0x25
    3afa:	be a3       	std	Y+38, r27	; 0x26
      float sin_theta_d2 = sqrt(0.5*(1.0-junction_cos_theta)); // Trig half angle identity. Always positive.
    3afc:	2b a1       	ldd	r18, Y+35	; 0x23
    3afe:	3c a1       	ldd	r19, Y+36	; 0x24
    3b00:	4d a1       	ldd	r20, Y+37	; 0x25
    3b02:	5e a1       	ldd	r21, Y+38	; 0x26
    3b04:	60 e0       	ldi	r22, 0x00	; 0
    3b06:	70 e0       	ldi	r23, 0x00	; 0
    3b08:	80 e8       	ldi	r24, 0x80	; 128
    3b0a:	9f e3       	ldi	r25, 0x3F	; 63
    3b0c:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    3b10:	20 e0       	ldi	r18, 0x00	; 0
    3b12:	30 e0       	ldi	r19, 0x00	; 0
    3b14:	40 e0       	ldi	r20, 0x00	; 0
    3b16:	5f e3       	ldi	r21, 0x3F	; 63
    3b18:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    3b1c:	0e 94 a0 3c 	call	0x7940	; 0x7940 <sqrt>
    3b20:	6b 01       	movw	r12, r22
    3b22:	7c 01       	movw	r14, r24

      // TODO: Technically, the acceleration used in calculation needs to be limited by the minimum of the
      // two junctions. However, this shouldn't be a significant problem except in extreme circumstances.
      block->max_junction_speed_sqr = max( MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED,
    3b24:	89 e2       	ldi	r24, 0x29	; 41
    3b26:	af a5       	ldd	r26, Y+47	; 0x2f
    3b28:	b8 a9       	ldd	r27, Y+48	; 0x30
    3b2a:	8a 9f       	mul	r24, r26
    3b2c:	f0 01       	movw	r30, r0
    3b2e:	8b 9f       	mul	r24, r27
    3b30:	f0 0d       	add	r31, r0
    3b32:	11 24       	eor	r1, r1
    3b34:	e0 5e       	subi	r30, 0xE0	; 224
    3b36:	fe 4f       	sbci	r31, 0xFE	; 254
    3b38:	20 91 b4 06 	lds	r18, 0x06B4	; 0x8006b4 <settings+0x35>
    3b3c:	30 91 b5 06 	lds	r19, 0x06B5	; 0x8006b5 <settings+0x36>
    3b40:	40 91 b6 06 	lds	r20, 0x06B6	; 0x8006b6 <settings+0x37>
    3b44:	50 91 b7 06 	lds	r21, 0x06B7	; 0x8006b7 <settings+0x38>
    3b48:	61 a1       	ldd	r22, Z+33	; 0x21
    3b4a:	72 a1       	ldd	r23, Z+34	; 0x22
    3b4c:	83 a1       	ldd	r24, Z+35	; 0x23
    3b4e:	94 a1       	ldd	r25, Z+36	; 0x24
    3b50:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    3b54:	a7 01       	movw	r20, r14
    3b56:	96 01       	movw	r18, r12
    3b58:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    3b5c:	4b 01       	movw	r8, r22
    3b5e:	5c 01       	movw	r10, r24
    3b60:	a7 01       	movw	r20, r14
    3b62:	96 01       	movw	r18, r12
    3b64:	60 e0       	ldi	r22, 0x00	; 0
    3b66:	70 e0       	ldi	r23, 0x00	; 0
    3b68:	80 e8       	ldi	r24, 0x80	; 128
    3b6a:	9f e3       	ldi	r25, 0x3F	; 63
    3b6c:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    3b70:	9b 01       	movw	r18, r22
    3b72:	ac 01       	movw	r20, r24
    3b74:	c5 01       	movw	r24, r10
    3b76:	b4 01       	movw	r22, r8
    3b78:	0e 94 a9 39 	call	0x7352	; 0x7352 <__divsf3>
    3b7c:	e6 2e       	mov	r14, r22
    3b7e:	f7 2e       	mov	r15, r23
    3b80:	08 2f       	mov	r16, r24
    3b82:	19 2f       	mov	r17, r25
    3b84:	20 e0       	ldi	r18, 0x00	; 0
    3b86:	30 e0       	ldi	r19, 0x00	; 0
    3b88:	a9 01       	movw	r20, r18
    3b8a:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    3b8e:	88 23       	and	r24, r24
    3b90:	24 f4       	brge	.+8      	; 0x3b9a <plan_buffer_line+0x54c>
    3b92:	e1 2c       	mov	r14, r1
    3b94:	f1 2c       	mov	r15, r1
    3b96:	00 e0       	ldi	r16, 0x00	; 0
    3b98:	10 e0       	ldi	r17, 0x00	; 0
    3b9a:	89 e2       	ldi	r24, 0x29	; 41
    3b9c:	2f a5       	ldd	r18, Y+47	; 0x2f
    3b9e:	38 a9       	ldd	r19, Y+48	; 0x30
    3ba0:	82 9f       	mul	r24, r18
    3ba2:	f0 01       	movw	r30, r0
    3ba4:	83 9f       	mul	r24, r19
    3ba6:	f0 0d       	add	r31, r0
    3ba8:	11 24       	eor	r1, r1
    3baa:	e0 5e       	subi	r30, 0xE0	; 224
    3bac:	fe 4f       	sbci	r31, 0xFE	; 254
    3bae:	4e 2d       	mov	r20, r14
    3bb0:	5f 2d       	mov	r21, r15
    3bb2:	60 2f       	mov	r22, r16
    3bb4:	71 2f       	mov	r23, r17
    3bb6:	41 8f       	std	Z+25, r20	; 0x19
    3bb8:	52 8f       	std	Z+26, r21	; 0x1a
    3bba:	63 8f       	std	Z+27, r22	; 0x1b
    3bbc:	74 8f       	std	Z+28, r23	; 0x1c

    }
  }

  // Store block nominal speed
  block->nominal_speed_sqr = feed_rate*feed_rate; // (mm/min). Always > 0
    3bbe:	2b a5       	ldd	r18, Y+43	; 0x2b
    3bc0:	3c a5       	ldd	r19, Y+44	; 0x2c
    3bc2:	4d a5       	ldd	r20, Y+45	; 0x2d
    3bc4:	5e a5       	ldd	r21, Y+46	; 0x2e
    3bc6:	6b a5       	ldd	r22, Y+43	; 0x2b
    3bc8:	7c a5       	ldd	r23, Y+44	; 0x2c
    3bca:	8d a5       	ldd	r24, Y+45	; 0x2d
    3bcc:	9e a5       	ldd	r25, Y+46	; 0x2e
    3bce:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    3bd2:	f6 2e       	mov	r15, r22
    3bd4:	07 2f       	mov	r16, r23
    3bd6:	18 2f       	mov	r17, r24
    3bd8:	e9 2e       	mov	r14, r25
    3bda:	89 e2       	ldi	r24, 0x29	; 41
    3bdc:	4f a5       	ldd	r20, Y+47	; 0x2f
    3bde:	58 a9       	ldd	r21, Y+48	; 0x30
    3be0:	84 9f       	mul	r24, r20
    3be2:	f0 01       	movw	r30, r0
    3be4:	85 9f       	mul	r24, r21
    3be6:	f0 0d       	add	r31, r0
    3be8:	11 24       	eor	r1, r1
    3bea:	e0 5e       	subi	r30, 0xE0	; 224
    3bec:	fe 4f       	sbci	r31, 0xFE	; 254
    3bee:	8f 2d       	mov	r24, r15
    3bf0:	90 2f       	mov	r25, r16
    3bf2:	a1 2f       	mov	r26, r17
    3bf4:	be 2d       	mov	r27, r14
    3bf6:	85 8f       	std	Z+29, r24	; 0x1d
    3bf8:	96 8f       	std	Z+30, r25	; 0x1e
    3bfa:	a7 8f       	std	Z+31, r26	; 0x1f
    3bfc:	b0 a3       	std	Z+32, r27	; 0x20
  
  // Compute the junction maximum entry based on the minimum of the junction speed and neighboring nominal speeds.
  block->max_entry_speed_sqr = min(block->max_junction_speed_sqr, 
    3bfe:	d1 8c       	ldd	r13, Z+25	; 0x19
    3c00:	c2 8c       	ldd	r12, Z+26	; 0x1a
    3c02:	b3 8c       	ldd	r11, Z+27	; 0x1b
    3c04:	a4 8c       	ldd	r10, Z+28	; 0x1c
    3c06:	90 90 18 01 	lds	r9, 0x0118	; 0x800118 <_edata+0x18>
    3c0a:	80 90 19 01 	lds	r8, 0x0119	; 0x800119 <_edata+0x19>
    3c0e:	70 90 1a 01 	lds	r7, 0x011A	; 0x80011a <_edata+0x1a>
    3c12:	60 90 1b 01 	lds	r6, 0x011B	; 0x80011b <_edata+0x1b>
    3c16:	29 2d       	mov	r18, r9
    3c18:	38 2d       	mov	r19, r8
    3c1a:	47 2d       	mov	r20, r7
    3c1c:	56 2d       	mov	r21, r6
    3c1e:	6f 2d       	mov	r22, r15
    3c20:	70 2f       	mov	r23, r16
    3c22:	81 2f       	mov	r24, r17
    3c24:	9e 2d       	mov	r25, r14
    3c26:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    3c2a:	88 23       	and	r24, r24
    3c2c:	2c f0       	brlt	.+10     	; 0x3c38 <plan_buffer_line+0x5ea>
    3c2e:	b9 2d       	mov	r27, r9
    3c30:	a8 2d       	mov	r26, r8
    3c32:	f7 2d       	mov	r31, r7
    3c34:	e6 2d       	mov	r30, r6
    3c36:	04 c0       	rjmp	.+8      	; 0x3c40 <plan_buffer_line+0x5f2>
    3c38:	bf 2d       	mov	r27, r15
    3c3a:	a0 2f       	mov	r26, r16
    3c3c:	f1 2f       	mov	r31, r17
    3c3e:	ee 2d       	mov	r30, r14
    3c40:	2d 2d       	mov	r18, r13
    3c42:	3c 2d       	mov	r19, r12
    3c44:	4b 2d       	mov	r20, r11
    3c46:	5a 2d       	mov	r21, r10
    3c48:	6b 2f       	mov	r22, r27
    3c4a:	7a 2f       	mov	r23, r26
    3c4c:	8f 2f       	mov	r24, r31
    3c4e:	9e 2f       	mov	r25, r30
    3c50:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    3c54:	18 16       	cp	r1, r24
    3c56:	ac f0       	brlt	.+42     	; 0x3c82 <plan_buffer_line+0x634>
    3c58:	29 2d       	mov	r18, r9
    3c5a:	38 2d       	mov	r19, r8
    3c5c:	47 2d       	mov	r20, r7
    3c5e:	56 2d       	mov	r21, r6
    3c60:	6f 2d       	mov	r22, r15
    3c62:	70 2f       	mov	r23, r16
    3c64:	81 2f       	mov	r24, r17
    3c66:	9e 2d       	mov	r25, r14
    3c68:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    3c6c:	88 23       	and	r24, r24
    3c6e:	2c f0       	brlt	.+10     	; 0x3c7a <plan_buffer_line+0x62c>
    3c70:	d9 2c       	mov	r13, r9
    3c72:	c8 2c       	mov	r12, r8
    3c74:	b7 2c       	mov	r11, r7
    3c76:	a6 2c       	mov	r10, r6
    3c78:	04 c0       	rjmp	.+8      	; 0x3c82 <plan_buffer_line+0x634>
    3c7a:	df 2c       	mov	r13, r15
    3c7c:	c0 2e       	mov	r12, r16
    3c7e:	b1 2e       	mov	r11, r17
    3c80:	ae 2c       	mov	r10, r14
    3c82:	89 e2       	ldi	r24, 0x29	; 41
    3c84:	af a5       	ldd	r26, Y+47	; 0x2f
    3c86:	b8 a9       	ldd	r27, Y+48	; 0x30
    3c88:	8a 9f       	mul	r24, r26
    3c8a:	f0 01       	movw	r30, r0
    3c8c:	8b 9f       	mul	r24, r27
    3c8e:	f0 0d       	add	r31, r0
    3c90:	11 24       	eor	r1, r1
    3c92:	e0 5e       	subi	r30, 0xE0	; 224
    3c94:	fe 4f       	sbci	r31, 0xFE	; 254
    3c96:	8d 2d       	mov	r24, r13
    3c98:	9c 2d       	mov	r25, r12
    3c9a:	ab 2d       	mov	r26, r11
    3c9c:	ba 2d       	mov	r27, r10
    3c9e:	85 8b       	std	Z+21, r24	; 0x15
    3ca0:	96 8b       	std	Z+22, r25	; 0x16
    3ca2:	a7 8b       	std	Z+23, r26	; 0x17
    3ca4:	b0 8f       	std	Z+24, r27	; 0x18
                                   min(block->nominal_speed_sqr,pl.previous_nominal_speed_sqr));
  
  // Update previous path unit_vector and nominal speed (squared)
  memcpy(pl.previous_unit_vec, unit_vec, sizeof(unit_vec)); // pl.previous_unit_vec[] = unit_vec[]
    3ca6:	8c e0       	ldi	r24, 0x0C	; 12
    3ca8:	fe 01       	movw	r30, r28
    3caa:	3d 96       	adiw	r30, 0x0d	; 13
    3cac:	ac e0       	ldi	r26, 0x0C	; 12
    3cae:	b1 e0       	ldi	r27, 0x01	; 1
    3cb0:	01 90       	ld	r0, Z+
    3cb2:	0d 92       	st	X+, r0
    3cb4:	8a 95       	dec	r24
    3cb6:	e1 f7       	brne	.-8      	; 0x3cb0 <plan_buffer_line+0x662>
  pl.previous_nominal_speed_sqr = block->nominal_speed_sqr;
    3cb8:	8f 2d       	mov	r24, r15
    3cba:	90 2f       	mov	r25, r16
    3cbc:	a1 2f       	mov	r26, r17
    3cbe:	be 2d       	mov	r27, r14
    3cc0:	80 93 18 01 	sts	0x0118, r24	; 0x800118 <_edata+0x18>
    3cc4:	90 93 19 01 	sts	0x0119, r25	; 0x800119 <_edata+0x19>
    3cc8:	a0 93 1a 01 	sts	0x011A, r26	; 0x80011a <_edata+0x1a>
    3ccc:	b0 93 1b 01 	sts	0x011B, r27	; 0x80011b <_edata+0x1b>
    
  // Update planner position
  memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]
    3cd0:	8c e0       	ldi	r24, 0x0C	; 12
    3cd2:	fe 01       	movw	r30, r28
    3cd4:	31 96       	adiw	r30, 0x01	; 1
    3cd6:	a0 e0       	ldi	r26, 0x00	; 0
    3cd8:	b1 e0       	ldi	r27, 0x01	; 1
    3cda:	01 90       	ld	r0, Z+
    3cdc:	0d 92       	st	X+, r0
    3cde:	8a 95       	dec	r24
    3ce0:	e1 f7       	brne	.-8      	; 0x3cda <plan_buffer_line+0x68c>

  // New block is all set. Update buffer head and next buffer head indices.
  block_buffer_head = next_buffer_head;  
    3ce2:	80 91 1d 01 	lds	r24, 0x011D	; 0x80011d <next_buffer_head>
    3ce6:	80 93 1e 01 	sts	0x011E, r24	; 0x80011e <block_buffer_head>


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    3cea:	8f 5f       	subi	r24, 0xFF	; 255
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    3cec:	82 31       	cpi	r24, 0x12	; 18
    3cee:	09 f4       	brne	.+2      	; 0x3cf2 <plan_buffer_line+0x6a4>
    3cf0:	80 e0       	ldi	r24, 0x00	; 0
  // Update planner position
  memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]

  // New block is all set. Update buffer head and next buffer head indices.
  block_buffer_head = next_buffer_head;  
  next_buffer_head = plan_next_block_index(block_buffer_head);
    3cf2:	80 93 1d 01 	sts	0x011D, r24	; 0x80011d <next_buffer_head>
  
  // Finish up by recalculating the plan with the new block.
  planner_recalculate();
    3cf6:	0e 94 69 19 	call	0x32d2	; 0x32d2 <planner_recalculate>
}
    3cfa:	e8 96       	adiw	r28, 0x38	; 56
    3cfc:	0f b6       	in	r0, 0x3f	; 63
    3cfe:	f8 94       	cli
    3d00:	de bf       	out	0x3e, r29	; 62
    3d02:	0f be       	out	0x3f, r0	; 63
    3d04:	cd bf       	out	0x3d, r28	; 61
    3d06:	df 91       	pop	r29
    3d08:	cf 91       	pop	r28
    3d0a:	1f 91       	pop	r17
    3d0c:	0f 91       	pop	r16
    3d0e:	ff 90       	pop	r15
    3d10:	ef 90       	pop	r14
    3d12:	df 90       	pop	r13
    3d14:	cf 90       	pop	r12
    3d16:	bf 90       	pop	r11
    3d18:	af 90       	pop	r10
    3d1a:	9f 90       	pop	r9
    3d1c:	8f 90       	pop	r8
    3d1e:	7f 90       	pop	r7
    3d20:	6f 90       	pop	r6
    3d22:	5f 90       	pop	r5
    3d24:	4f 90       	pop	r4
    3d26:	3f 90       	pop	r3
    3d28:	2f 90       	pop	r2
    3d2a:	08 95       	ret

00003d2c <plan_sync_position>:


// Reset the planner position vectors. Called by the system abort/initialization routine.
void plan_sync_position()
{
    3d2c:	a4 ea       	ldi	r26, 0xA4	; 164
    3d2e:	b5 e0       	ldi	r27, 0x05	; 5
    3d30:	e0 e0       	ldi	r30, 0x00	; 0
    3d32:	f1 e0       	ldi	r31, 0x01	; 1
    3d34:	8c e0       	ldi	r24, 0x0C	; 12
    3d36:	91 e0       	ldi	r25, 0x01	; 1
        pl.position[Y_AXIS] = system_convert_corexy_to_y_axis_steps(sys.position);
      } else {
        pl.position[idx] = sys.position[idx];
      }
    #else
      pl.position[idx] = sys.position[idx];
    3d38:	4d 91       	ld	r20, X+
    3d3a:	5d 91       	ld	r21, X+
    3d3c:	6d 91       	ld	r22, X+
    3d3e:	7d 91       	ld	r23, X+
    3d40:	41 93       	st	Z+, r20
    3d42:	51 93       	st	Z+, r21
    3d44:	61 93       	st	Z+, r22
    3d46:	71 93       	st	Z+, r23
void plan_sync_position()
{
  // TODO: For motor configurations not in the same coordinate frame as the machine position,
  // this function needs to be updated to accomodate the difference. 
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    3d48:	e8 17       	cp	r30, r24
    3d4a:	f9 07       	cpc	r31, r25
    3d4c:	a9 f7       	brne	.-22     	; 0x3d38 <plan_sync_position+0xc>
      }
    #else
      pl.position[idx] = sys.position[idx];
    #endif
  }
}
    3d4e:	08 95       	ret

00003d50 <plan_get_block_buffer_count>:


// Returns the number of active blocks are in the planner buffer.
uint8_t plan_get_block_buffer_count()
{
  if (block_buffer_head >= block_buffer_tail) { return(block_buffer_head-block_buffer_tail); }
    3d50:	80 91 1e 01 	lds	r24, 0x011E	; 0x80011e <block_buffer_head>
    3d54:	90 91 1f 01 	lds	r25, 0x011F	; 0x80011f <block_buffer_tail>
    3d58:	89 17       	cp	r24, r25
    3d5a:	10 f0       	brcs	.+4      	; 0x3d60 <plan_get_block_buffer_count+0x10>
    3d5c:	89 1b       	sub	r24, r25
    3d5e:	08 95       	ret
  return(BLOCK_BUFFER_SIZE - (block_buffer_tail-block_buffer_head));
    3d60:	8e 5e       	subi	r24, 0xEE	; 238
    3d62:	89 1b       	sub	r24, r25
}
    3d64:	08 95       	ret

00003d66 <plan_cycle_reinitialize>:
// Re-initialize buffer plan with a partially completed block, assumed to exist at the buffer tail.
// Called after a steppers have come to a complete stop for a feed hold and the cycle is stopped.
void plan_cycle_reinitialize()
{
  // Re-plan from a complete stop. Reset planner entry speeds and buffer planned pointer.
  st_update_plan_block_parameters();
    3d66:	0e 94 0b 2f 	call	0x5e16	; 0x5e16 <st_update_plan_block_parameters>
  block_buffer_planned = block_buffer_tail;
    3d6a:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <block_buffer_tail>
    3d6e:	80 93 1c 01 	sts	0x011C, r24	; 0x80011c <block_buffer_planned>
  planner_recalculate();  
    3d72:	0e 94 69 19 	call	0x32d2	; 0x32d2 <planner_recalculate>
    3d76:	08 95       	ret

00003d78 <printString>:
    serial_write('-');
    print_uint32_base10(-n);
  } else {
    print_uint32_base10(n);
  }
}
    3d78:	cf 93       	push	r28
    3d7a:	df 93       	push	r29
    3d7c:	ec 01       	movw	r28, r24
    3d7e:	88 81       	ld	r24, Y
    3d80:	88 23       	and	r24, r24
    3d82:	31 f0       	breq	.+12     	; 0x3d90 <printString+0x18>
    3d84:	21 96       	adiw	r28, 0x01	; 1
    3d86:	0e 94 22 28 	call	0x5044	; 0x5044 <serial_write>
    3d8a:	89 91       	ld	r24, Y+
    3d8c:	81 11       	cpse	r24, r1
    3d8e:	fb cf       	rjmp	.-10     	; 0x3d86 <printString+0xe>
    3d90:	df 91       	pop	r29
    3d92:	cf 91       	pop	r28
    3d94:	08 95       	ret

00003d96 <printPgmString>:
    3d96:	cf 93       	push	r28
    3d98:	df 93       	push	r29
    3d9a:	ec 01       	movw	r28, r24
    3d9c:	21 96       	adiw	r28, 0x01	; 1
    3d9e:	fc 01       	movw	r30, r24
    3da0:	84 91       	lpm	r24, Z
    3da2:	88 23       	and	r24, r24
    3da4:	39 f0       	breq	.+14     	; 0x3db4 <printPgmString+0x1e>
    3da6:	0e 94 22 28 	call	0x5044	; 0x5044 <serial_write>
    3daa:	fe 01       	movw	r30, r28
    3dac:	84 91       	lpm	r24, Z
    3dae:	21 96       	adiw	r28, 0x01	; 1
    3db0:	81 11       	cpse	r24, r1
    3db2:	f9 cf       	rjmp	.-14     	; 0x3da6 <printPgmString+0x10>
    3db4:	df 91       	pop	r29
    3db6:	cf 91       	pop	r28
    3db8:	08 95       	ret

00003dba <print_unsigned_int8>:
    3dba:	cf 92       	push	r12
    3dbc:	df 92       	push	r13
    3dbe:	ef 92       	push	r14
    3dc0:	ff 92       	push	r15
    3dc2:	1f 93       	push	r17
    3dc4:	cf 93       	push	r28
    3dc6:	df 93       	push	r29
    3dc8:	cd b7       	in	r28, 0x3d	; 61
    3dca:	de b7       	in	r29, 0x3e	; 62
    3dcc:	56 2f       	mov	r21, r22
    3dce:	14 2f       	mov	r17, r20
    3dd0:	cd b6       	in	r12, 0x3d	; 61
    3dd2:	de b6       	in	r13, 0x3e	; 62
    3dd4:	2d b7       	in	r18, 0x3d	; 61
    3dd6:	3e b7       	in	r19, 0x3e	; 62
    3dd8:	24 1b       	sub	r18, r20
    3dda:	31 09       	sbc	r19, r1
    3ddc:	0f b6       	in	r0, 0x3f	; 63
    3dde:	f8 94       	cli
    3de0:	3e bf       	out	0x3e, r19	; 62
    3de2:	0f be       	out	0x3f, r0	; 63
    3de4:	2d bf       	out	0x3d, r18	; 61
    3de6:	6d b7       	in	r22, 0x3d	; 61
    3de8:	7e b7       	in	r23, 0x3e	; 62
    3dea:	6f 5f       	subi	r22, 0xFF	; 255
    3dec:	7f 4f       	sbci	r23, 0xFF	; 255
    3dee:	7b 01       	movw	r14, r22
    3df0:	44 23       	and	r20, r20
    3df2:	d1 f0       	breq	.+52     	; 0x3e28 <print_unsigned_int8+0x6e>
    3df4:	fb 01       	movw	r30, r22
    3df6:	9f ef       	ldi	r25, 0xFF	; 255
    3df8:	94 0f       	add	r25, r20
    3dfa:	29 2f       	mov	r18, r25
    3dfc:	30 e0       	ldi	r19, 0x00	; 0
    3dfe:	2f 5f       	subi	r18, 0xFF	; 255
    3e00:	3f 4f       	sbci	r19, 0xFF	; 255
    3e02:	26 0f       	add	r18, r22
    3e04:	37 1f       	adc	r19, r23
    3e06:	65 2f       	mov	r22, r21
    3e08:	0e 94 0a 3d 	call	0x7a14	; 0x7a14 <__udivmodqi4>
    3e0c:	91 93       	st	Z+, r25
    3e0e:	2e 17       	cp	r18, r30
    3e10:	3f 07       	cpc	r19, r31
    3e12:	c9 f7       	brne	.-14     	; 0x3e06 <print_unsigned_int8+0x4c>
    3e14:	f7 01       	movw	r30, r14
    3e16:	e1 0f       	add	r30, r17
    3e18:	f1 1d       	adc	r31, r1
    3e1a:	31 97       	sbiw	r30, 0x01	; 1
    3e1c:	80 81       	ld	r24, Z
    3e1e:	80 5d       	subi	r24, 0xD0	; 208
    3e20:	0e 94 22 28 	call	0x5044	; 0x5044 <serial_write>
    3e24:	11 50       	subi	r17, 0x01	; 1
    3e26:	b1 f7       	brne	.-20     	; 0x3e14 <print_unsigned_int8+0x5a>
    3e28:	0f b6       	in	r0, 0x3f	; 63
    3e2a:	f8 94       	cli
    3e2c:	de be       	out	0x3e, r13	; 62
    3e2e:	0f be       	out	0x3f, r0	; 63
    3e30:	cd be       	out	0x3d, r12	; 61
    3e32:	df 91       	pop	r29
    3e34:	cf 91       	pop	r28
    3e36:	1f 91       	pop	r17
    3e38:	ff 90       	pop	r15
    3e3a:	ef 90       	pop	r14
    3e3c:	df 90       	pop	r13
    3e3e:	cf 90       	pop	r12
    3e40:	08 95       	ret

00003e42 <print_uint8_base2>:
    3e42:	48 e0       	ldi	r20, 0x08	; 8
    3e44:	62 e0       	ldi	r22, 0x02	; 2
    3e46:	0e 94 dd 1e 	call	0x3dba	; 0x3dba <print_unsigned_int8>
    3e4a:	08 95       	ret

00003e4c <print_uint8_base10>:
    3e4c:	8a 30       	cpi	r24, 0x0A	; 10
    3e4e:	20 f0       	brcs	.+8      	; 0x3e58 <print_uint8_base10+0xc>
    3e50:	84 36       	cpi	r24, 0x64	; 100
    3e52:	20 f0       	brcs	.+8      	; 0x3e5c <print_uint8_base10+0x10>
    3e54:	43 e0       	ldi	r20, 0x03	; 3
    3e56:	03 c0       	rjmp	.+6      	; 0x3e5e <print_uint8_base10+0x12>
    3e58:	41 e0       	ldi	r20, 0x01	; 1
    3e5a:	01 c0       	rjmp	.+2      	; 0x3e5e <print_uint8_base10+0x12>
    3e5c:	42 e0       	ldi	r20, 0x02	; 2
    3e5e:	6a e0       	ldi	r22, 0x0A	; 10
    3e60:	0e 94 dd 1e 	call	0x3dba	; 0x3dba <print_unsigned_int8>
    3e64:	08 95       	ret

00003e66 <printFloat>:
// more digits than a float. Number of decimal places, which are tracked by a counter,
// may be set by the user. The integer is then efficiently converted to a string.
// NOTE: AVR '%' and '/' integer operations are very efficient. Bitshifting speed-up 
// techniques are actually just slightly slower. Found this out the hard way.
void printFloat(float n, uint8_t decimal_places)
{
    3e66:	8f 92       	push	r8
    3e68:	9f 92       	push	r9
    3e6a:	af 92       	push	r10
    3e6c:	bf 92       	push	r11
    3e6e:	cf 92       	push	r12
    3e70:	df 92       	push	r13
    3e72:	ef 92       	push	r14
    3e74:	ff 92       	push	r15
    3e76:	0f 93       	push	r16
    3e78:	1f 93       	push	r17
    3e7a:	cf 93       	push	r28
    3e7c:	df 93       	push	r29
    3e7e:	cd b7       	in	r28, 0x3d	; 61
    3e80:	de b7       	in	r29, 0x3e	; 62
    3e82:	2a 97       	sbiw	r28, 0x0a	; 10
    3e84:	0f b6       	in	r0, 0x3f	; 63
    3e86:	f8 94       	cli
    3e88:	de bf       	out	0x3e, r29	; 62
    3e8a:	0f be       	out	0x3f, r0	; 63
    3e8c:	cd bf       	out	0x3d, r28	; 61
    3e8e:	6b 01       	movw	r12, r22
    3e90:	7c 01       	movw	r14, r24
    3e92:	04 2f       	mov	r16, r20
  if (n < 0) {
    3e94:	20 e0       	ldi	r18, 0x00	; 0
    3e96:	30 e0       	ldi	r19, 0x00	; 0
    3e98:	a9 01       	movw	r20, r18
    3e9a:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    3e9e:	88 23       	and	r24, r24
    3ea0:	3c f4       	brge	.+14     	; 0x3eb0 <printFloat+0x4a>
    serial_write('-');
    3ea2:	8d e2       	ldi	r24, 0x2D	; 45
    3ea4:	0e 94 22 28 	call	0x5044	; 0x5044 <serial_write>
    n = -n;
    3ea8:	f7 fa       	bst	r15, 7
    3eaa:	f0 94       	com	r15
    3eac:	f7 f8       	bld	r15, 7
    3eae:	f0 94       	com	r15
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    3eb0:	02 30       	cpi	r16, 0x02	; 2
    3eb2:	88 f0       	brcs	.+34     	; 0x3ed6 <printFloat+0x70>
    3eb4:	10 2f       	mov	r17, r16
    n *= 100;
    3eb6:	20 e0       	ldi	r18, 0x00	; 0
    3eb8:	30 e0       	ldi	r19, 0x00	; 0
    3eba:	48 ec       	ldi	r20, 0xC8	; 200
    3ebc:	52 e4       	ldi	r21, 0x42	; 66
    3ebe:	c7 01       	movw	r24, r14
    3ec0:	b6 01       	movw	r22, r12
    3ec2:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    3ec6:	6b 01       	movw	r12, r22
    3ec8:	7c 01       	movw	r14, r24
    decimals -= 2;
    3eca:	12 50       	subi	r17, 0x02	; 2
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    3ecc:	12 30       	cpi	r17, 0x02	; 2
    3ece:	98 f7       	brcc	.-26     	; 0x3eb6 <printFloat+0x50>
    3ed0:	80 2f       	mov	r24, r16
    3ed2:	81 70       	andi	r24, 0x01	; 1
    3ed4:	01 c0       	rjmp	.+2      	; 0x3ed8 <printFloat+0x72>
  if (n < 0) {
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
    3ed6:	80 2f       	mov	r24, r16
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    n *= 100;
    decimals -= 2;
  }
  if (decimals) { n *= 10; }
    3ed8:	88 23       	and	r24, r24
    3eda:	51 f0       	breq	.+20     	; 0x3ef0 <printFloat+0x8a>
    3edc:	20 e0       	ldi	r18, 0x00	; 0
    3ede:	30 e0       	ldi	r19, 0x00	; 0
    3ee0:	40 e2       	ldi	r20, 0x20	; 32
    3ee2:	51 e4       	ldi	r21, 0x41	; 65
    3ee4:	c7 01       	movw	r24, r14
    3ee6:	b6 01       	movw	r22, r12
    3ee8:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    3eec:	6b 01       	movw	r12, r22
    3eee:	7c 01       	movw	r14, r24
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
    
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
    3ef0:	20 e0       	ldi	r18, 0x00	; 0
    3ef2:	30 e0       	ldi	r19, 0x00	; 0
    3ef4:	40 e0       	ldi	r20, 0x00	; 0
    3ef6:	5f e3       	ldi	r21, 0x3F	; 63
    3ef8:	c7 01       	movw	r24, r14
    3efa:	b6 01       	movw	r22, r12
    3efc:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    3f00:	0e 94 1b 3a 	call	0x7436	; 0x7436 <__fixsfsi>
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
    3f04:	2e e2       	ldi	r18, 0x2E	; 46
    3f06:	fe 01       	movw	r30, r28
    3f08:	e0 0f       	add	r30, r16
    3f0a:	f1 1d       	adc	r31, r1
    3f0c:	21 83       	std	Z+1, r18	; 0x01
  while(a > 0) {
    3f0e:	61 15       	cp	r22, r1
    3f10:	71 05       	cpc	r23, r1
    3f12:	81 05       	cpc	r24, r1
    3f14:	91 05       	cpc	r25, r1
    3f16:	41 f1       	breq	.+80     	; 0x3f68 <printFloat+0x102>
    3f18:	10 e0       	ldi	r17, 0x00	; 0
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    3f1a:	0f 2e       	mov	r0, r31
    3f1c:	fa e0       	ldi	r31, 0x0A	; 10
    3f1e:	8f 2e       	mov	r8, r31
    3f20:	91 2c       	mov	r9, r1
    3f22:	a1 2c       	mov	r10, r1
    3f24:	b1 2c       	mov	r11, r1
    3f26:	f0 2d       	mov	r31, r0
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    3f28:	01 13       	cpse	r16, r17
    3f2a:	03 c0       	rjmp	.+6      	; 0x3f32 <printFloat+0xcc>
    3f2c:	21 e0       	ldi	r18, 0x01	; 1
    3f2e:	21 0f       	add	r18, r17
    3f30:	01 c0       	rjmp	.+2      	; 0x3f34 <printFloat+0xce>
    3f32:	21 2f       	mov	r18, r17
    buf[i++] = (a % 10) + '0'; // Get digit
    3f34:	11 e0       	ldi	r17, 0x01	; 1
    3f36:	12 0f       	add	r17, r18
    3f38:	ee 24       	eor	r14, r14
    3f3a:	e3 94       	inc	r14
    3f3c:	f1 2c       	mov	r15, r1
    3f3e:	ec 0e       	add	r14, r28
    3f40:	fd 1e       	adc	r15, r29
    3f42:	e2 0e       	add	r14, r18
    3f44:	f1 1c       	adc	r15, r1
    3f46:	a5 01       	movw	r20, r10
    3f48:	94 01       	movw	r18, r8
    3f4a:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <__udivmodsi4>
    3f4e:	60 5d       	subi	r22, 0xD0	; 208
    3f50:	f7 01       	movw	r30, r14
    3f52:	60 83       	st	Z, r22
    a /= 10;
    3f54:	62 2f       	mov	r22, r18
    3f56:	73 2f       	mov	r23, r19
    3f58:	84 2f       	mov	r24, r20
    3f5a:	95 2f       	mov	r25, r21
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
  while(a > 0) {
    3f5c:	61 15       	cp	r22, r1
    3f5e:	71 05       	cpc	r23, r1
    3f60:	81 05       	cpc	r24, r1
    3f62:	91 05       	cpc	r25, r1
    3f64:	09 f7       	brne	.-62     	; 0x3f28 <printFloat+0xc2>
    3f66:	01 c0       	rjmp	.+2      	; 0x3f6a <printFloat+0x104>
  if (decimals) { n *= 10; }
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
    
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
    3f68:	10 e0       	ldi	r17, 0x00	; 0
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) { 
    3f6a:	10 17       	cp	r17, r16
    3f6c:	60 f4       	brcc	.+24     	; 0x3f86 <printFloat+0x120>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
    3f6e:	80 e3       	ldi	r24, 0x30	; 48
    3f70:	e1 e0       	ldi	r30, 0x01	; 1
    3f72:	f0 e0       	ldi	r31, 0x00	; 0
    3f74:	ec 0f       	add	r30, r28
    3f76:	fd 1f       	adc	r31, r29
    3f78:	e1 0f       	add	r30, r17
    3f7a:	f1 1d       	adc	r31, r1
    3f7c:	80 83       	st	Z, r24
    3f7e:	1f 5f       	subi	r17, 0xFF	; 255
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) { 
    3f80:	01 13       	cpse	r16, r17
    3f82:	f6 cf       	rjmp	.-20     	; 0x3f70 <printFloat+0x10a>
    3f84:	02 c0       	rjmp	.+4      	; 0x3f8a <printFloat+0x124>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
  }
  if (i == decimal_places) { // Fill in leading zero, if needed.
    3f86:	01 13       	cpse	r16, r17
    3f88:	08 c0       	rjmp	.+16     	; 0x3f9a <printFloat+0x134>
    i++;
    buf[i++] = '0'; 
    3f8a:	12 e0       	ldi	r17, 0x02	; 2
    3f8c:	10 0f       	add	r17, r16
    3f8e:	0f 5f       	subi	r16, 0xFF	; 255
    3f90:	fe 01       	movw	r30, r28
    3f92:	e0 0f       	add	r30, r16
    3f94:	f1 1d       	adc	r31, r1
    3f96:	80 e3       	ldi	r24, 0x30	; 48
    3f98:	81 83       	std	Z+1, r24	; 0x01
  }   
  
  // Print the generated string.
  for (; i > 0; i--)
    3f9a:	11 23       	and	r17, r17
    3f9c:	41 f0       	breq	.+16     	; 0x3fae <printFloat+0x148>
    serial_write(buf[i-1]);
    3f9e:	fe 01       	movw	r30, r28
    3fa0:	e1 0f       	add	r30, r17
    3fa2:	f1 1d       	adc	r31, r1
    3fa4:	80 81       	ld	r24, Z
    3fa6:	0e 94 22 28 	call	0x5044	; 0x5044 <serial_write>
    i++;
    buf[i++] = '0'; 
  }   
  
  // Print the generated string.
  for (; i > 0; i--)
    3faa:	11 50       	subi	r17, 0x01	; 1
    3fac:	c1 f7       	brne	.-16     	; 0x3f9e <printFloat+0x138>
    serial_write(buf[i-1]);
}
    3fae:	2a 96       	adiw	r28, 0x0a	; 10
    3fb0:	0f b6       	in	r0, 0x3f	; 63
    3fb2:	f8 94       	cli
    3fb4:	de bf       	out	0x3e, r29	; 62
    3fb6:	0f be       	out	0x3f, r0	; 63
    3fb8:	cd bf       	out	0x3d, r28	; 61
    3fba:	df 91       	pop	r29
    3fbc:	cf 91       	pop	r28
    3fbe:	1f 91       	pop	r17
    3fc0:	0f 91       	pop	r16
    3fc2:	ff 90       	pop	r15
    3fc4:	ef 90       	pop	r14
    3fc6:	df 90       	pop	r13
    3fc8:	cf 90       	pop	r12
    3fca:	bf 90       	pop	r11
    3fcc:	af 90       	pop	r10
    3fce:	9f 90       	pop	r9
    3fd0:	8f 90       	pop	r8
    3fd2:	08 95       	ret

00003fd4 <printFloat_CoordValue>:
// in the config.h.
//  - CoordValue: Handles all position or coordinate values in inches or mm reporting.
//  - RateValue: Handles feed rate and current velocity in inches or mm reporting.
//  - SettingValue: Handles all floating point settings values (always in mm.)
void printFloat_CoordValue(float n) { 
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) { 
    3fd4:	20 91 bc 06 	lds	r18, 0x06BC	; 0x8006bc <settings+0x3d>
    3fd8:	20 ff       	sbrs	r18, 0
    3fda:	0a c0       	rjmp	.+20     	; 0x3ff0 <printFloat_CoordValue+0x1c>
    printFloat(n*INCH_PER_MM,N_DECIMAL_COORDVALUE_INCH);
    3fdc:	2b e8       	ldi	r18, 0x8B	; 139
    3fde:	32 e4       	ldi	r19, 0x42	; 66
    3fe0:	41 e2       	ldi	r20, 0x21	; 33
    3fe2:	5d e3       	ldi	r21, 0x3D	; 61
    3fe4:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    3fe8:	44 e0       	ldi	r20, 0x04	; 4
    3fea:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <printFloat>
    3fee:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_COORDVALUE_MM);
    3ff0:	43 e0       	ldi	r20, 0x03	; 3
    3ff2:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <printFloat>
    3ff6:	08 95       	ret

00003ff8 <printFloat_RateValue>:
  }
}

void printFloat_RateValue(float n) { 
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
    3ff8:	20 91 bc 06 	lds	r18, 0x06BC	; 0x8006bc <settings+0x3d>
    3ffc:	20 ff       	sbrs	r18, 0
    3ffe:	0a c0       	rjmp	.+20     	; 0x4014 <printFloat_RateValue+0x1c>
    printFloat(n*INCH_PER_MM,N_DECIMAL_RATEVALUE_INCH);
    4000:	2b e8       	ldi	r18, 0x8B	; 139
    4002:	32 e4       	ldi	r19, 0x42	; 66
    4004:	41 e2       	ldi	r20, 0x21	; 33
    4006:	5d e3       	ldi	r21, 0x3D	; 61
    4008:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    400c:	41 e0       	ldi	r20, 0x01	; 1
    400e:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <printFloat>
    4012:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_RATEVALUE_MM);
    4014:	40 e0       	ldi	r20, 0x00	; 0
    4016:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <printFloat>
    401a:	08 95       	ret

0000401c <printFloat_SettingValue>:
  }
}

void printFloat_SettingValue(float n) { printFloat(n,N_DECIMAL_SETTINGVALUE); }
    401c:	43 e0       	ldi	r20, 0x03	; 3
    401e:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <printFloat>
    4022:	08 95       	ret

00004024 <probe_init>:


// Probe pin initialization routine.
void probe_init() 
{
  PROBE_DDR &= ~(PROBE_MASK); // Configure as input pins
    4024:	3d 98       	cbi	0x07, 5	; 7
  #ifdef DISABLE_PROBE_PIN_PULL_UP
    PROBE_PORT &= ~(PROBE_MASK); // Normal low operation. Requires external pull-down.
  #else
    PROBE_PORT |= PROBE_MASK;    // Enable internal pull-up resistors. Normal high operation.
    4026:	45 9a       	sbi	0x08, 5	; 8
    4028:	08 95       	ret

0000402a <probe_configure_invert_mask>:
// Called by probe_init() and the mc_probe() routines. Sets up the probe pin invert mask to 
// appropriately set the pin logic according to setting for normal-high/normal-low operation 
// and the probing cycle modes for toward-workpiece/away-from-workpiece. 
void probe_configure_invert_mask(uint8_t is_probe_away)
{
  probe_invert_mask = 0; // Initialize as zero.
    402a:	10 92 be 05 	sts	0x05BE, r1	; 0x8005be <probe_invert_mask>
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_PROBE_PIN)) { probe_invert_mask ^= PROBE_MASK; }
    402e:	90 91 bc 06 	lds	r25, 0x06BC	; 0x8006bc <settings+0x3d>
    4032:	99 23       	and	r25, r25
    4034:	1c f0       	brlt	.+6      	; 0x403c <probe_configure_invert_mask+0x12>
    4036:	90 e2       	ldi	r25, 0x20	; 32
    4038:	90 93 be 05 	sts	0x05BE, r25	; 0x8005be <probe_invert_mask>
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
    403c:	88 23       	and	r24, r24
    403e:	31 f0       	breq	.+12     	; 0x404c <probe_configure_invert_mask+0x22>
    4040:	90 91 be 05 	lds	r25, 0x05BE	; 0x8005be <probe_invert_mask>
    4044:	80 e2       	ldi	r24, 0x20	; 32
    4046:	89 27       	eor	r24, r25
    4048:	80 93 be 05 	sts	0x05BE, r24	; 0x8005be <probe_invert_mask>
    404c:	08 95       	ret

0000404e <probe_get_state>:
}


// Returns the probe pin state. Triggered = true. Called by gcode parser and probe state monitor.
uint8_t probe_get_state() { return((PROBE_PIN & PROBE_MASK) ^ probe_invert_mask); }
    404e:	86 b1       	in	r24, 0x06	; 6
    4050:	80 72       	andi	r24, 0x20	; 32
    4052:	90 91 be 05 	lds	r25, 0x05BE	; 0x8005be <probe_invert_mask>
    4056:	89 27       	eor	r24, r25
    4058:	08 95       	ret

0000405a <probe_state_monitor>:
// Monitors probe pin state and records the system position when detected. Called by the
// stepper ISR per ISR tick.
// NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
void probe_state_monitor()
{
  if (sys_probe_state == PROBE_ACTIVE) {
    405a:	80 91 26 05 	lds	r24, 0x0526	; 0x800526 <sys_probe_state>
    405e:	81 30       	cpi	r24, 0x01	; 1
    4060:	a1 f4       	brne	.+40     	; 0x408a <probe_state_monitor+0x30>
    if (probe_get_state()) {
    4062:	0e 94 27 20 	call	0x404e	; 0x404e <probe_get_state>
    4066:	88 23       	and	r24, r24
    4068:	81 f0       	breq	.+32     	; 0x408a <probe_state_monitor+0x30>
      sys_probe_state = PROBE_OFF;
    406a:	10 92 26 05 	sts	0x0526, r1	; 0x800526 <sys_probe_state>
      memcpy(sys.probe_position, sys.position, sizeof(sys.position));
    406e:	8c e0       	ldi	r24, 0x0C	; 12
    4070:	e4 ea       	ldi	r30, 0xA4	; 164
    4072:	f5 e0       	ldi	r31, 0x05	; 5
    4074:	a0 eb       	ldi	r26, 0xB0	; 176
    4076:	b5 e0       	ldi	r27, 0x05	; 5
    4078:	01 90       	ld	r0, Z+
    407a:	0d 92       	st	X+, r0
    407c:	8a 95       	dec	r24
    407e:	e1 f7       	brne	.-8      	; 0x4078 <probe_state_monitor+0x1e>
      bit_true(sys_rt_exec_state, EXEC_MOTION_CANCEL);
    4080:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    4084:	80 64       	ori	r24, 0x40	; 64
    4086:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <sys_rt_exec_state>
    408a:	08 95       	ret

0000408c <protocol_execute_realtime>:
// execute certain tasks without having two or more instances of the same task, such as the planner
// recalculating the buffer upon a feedhold or override.
// NOTE: The sys_rt_exec_state variable flags are set by any process, step or serial interrupts, pinouts,
// limit switches, or the main program.
void protocol_execute_realtime()
{
    408c:	af 92       	push	r10
    408e:	bf 92       	push	r11
    4090:	cf 92       	push	r12
    4092:	df 92       	push	r13
    4094:	ef 92       	push	r14
    4096:	ff 92       	push	r15
    4098:	0f 93       	push	r16
    409a:	1f 93       	push	r17
    409c:	cf 93       	push	r28
    409e:	df 93       	push	r29
  rt_exec = sys_rt_exec_alarm; // Copy volatile sys_rt_exec_alarm.
  if (rt_exec) { // Enter only if any bit flag is true
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
    40a0:	c0 ea       	ldi	r28, 0xA0	; 160
    40a2:	d5 e0       	ldi	r29, 0x05	; 5
    40a4:	01 e0       	ldi	r16, 0x01	; 1
            }
            // TODO: Install return to pre-park position.
          }
          // Start cycle only if queued motions exist in planner buffer and the motion is not canceled.
          if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
            sys.state = STATE_CYCLE;
    40a6:	68 94       	set
    40a8:	aa 24       	eor	r10, r10
    40aa:	a3 f8       	bld	r10, 3
        // NOTE: SAFETY_DOOR is implicitly blocked. It reverts to HOLD when the door is closed.
        if ((sys.state == STATE_IDLE) || ((sys.state & (STATE_HOLD | STATE_MOTION_CANCEL)) && (sys.suspend & SUSPEND_ENABLE_READY))) {
          // Re-energize powered components, if disabled by SAFETY_DOOR.
          if (sys.suspend & SUSPEND_ENERGIZE) { 
            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
    40ac:	0f 2e       	mov	r0, r31
    40ae:	f8 e2       	ldi	r31, 0x28	; 40
    40b0:	ef 2e       	mov	r14, r31
    40b2:	f5 e0       	ldi	r31, 0x05	; 5
    40b4:	ff 2e       	mov	r15, r31
    40b6:	f0 2d       	mov	r31, r0
          report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR); 
          // If already in active, ready-to-resume HOLD, set CYCLE_STOP flag to force de-energize.
          // NOTE: Only temporarily sets the 'rt_exec' variable, not the volatile 'rt_exec_state' variable.
          if (sys.suspend & SUSPEND_ENABLE_READY) { bit_true(rt_exec,EXEC_CYCLE_STOP); }
          sys.suspend |= SUSPEND_ENERGIZE;
          sys.state = STATE_SAFETY_DOOR;
    40b8:	68 94       	set
    40ba:	cc 24       	eor	r12, r12
    40bc:	c5 f8       	bld	r12, 5
        }
    
        // Execute a feed hold with deceleration, only during cycle.
        if (rt_exec & EXEC_FEED_HOLD) {
          // Block SAFETY_DOOR state from prematurely changing back to HOLD.
          if (bit_isfalse(sys.state,STATE_SAFETY_DOOR)) { sys.state = STATE_HOLD; }
    40be:	68 94       	set
    40c0:	dd 24       	eor	r13, r13
    40c2:	d4 f8       	bld	r13, 4
        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
          // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiated beforehand
          // to hold the CYCLE. If so, only flag that motion cancel is complete.
          if (sys.state == STATE_CYCLE) { sys.state = STATE_MOTION_CANCEL; }
    40c4:	68 94       	set
    40c6:	bb 24       	eor	r11, r11
    40c8:	b6 f8       	bld	r11, 6
  uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.

  do { // If system is suspended, suspend loop restarts here.
    
  // Check and execute alarms. 
  rt_exec = sys_rt_exec_alarm; // Copy volatile sys_rt_exec_alarm.
    40ca:	10 91 27 05 	lds	r17, 0x0527	; 0x800527 <sys_rt_exec_alarm>
  if (rt_exec) { // Enter only if any bit flag is true
    40ce:	11 23       	and	r17, r17
    40d0:	b1 f1       	breq	.+108    	; 0x413e <protocol_execute_realtime+0xb2>
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
    40d2:	09 83       	std	Y+1, r16	; 0x01
    if (rt_exec & EXEC_ALARM_HARD_LIMIT) {
    40d4:	11 ff       	sbrs	r17, 1
    40d6:	04 c0       	rjmp	.+8      	; 0x40e0 <protocol_execute_realtime+0x54>
      report_alarm_message(ALARM_HARD_LIMIT_ERROR); 
    40d8:	80 2f       	mov	r24, r16
    40da:	0e 94 ab 22 	call	0x4556	; 0x4556 <report_alarm_message>
    40de:	17 c0       	rjmp	.+46     	; 0x410e <protocol_execute_realtime+0x82>
    } else if (rt_exec & EXEC_ALARM_SOFT_LIMIT) {
    40e0:	12 ff       	sbrs	r17, 2
    40e2:	04 c0       	rjmp	.+8      	; 0x40ec <protocol_execute_realtime+0x60>
      report_alarm_message(ALARM_SOFT_LIMIT_ERROR);
    40e4:	82 e0       	ldi	r24, 0x02	; 2
    40e6:	0e 94 ab 22 	call	0x4556	; 0x4556 <report_alarm_message>
    40ea:	11 c0       	rjmp	.+34     	; 0x410e <protocol_execute_realtime+0x82>
    } else if (rt_exec & EXEC_ALARM_ABORT_CYCLE) {      
    40ec:	13 ff       	sbrs	r17, 3
    40ee:	04 c0       	rjmp	.+8      	; 0x40f8 <protocol_execute_realtime+0x6c>
      report_alarm_message(ALARM_ABORT_CYCLE);
    40f0:	83 e0       	ldi	r24, 0x03	; 3
    40f2:	0e 94 ab 22 	call	0x4556	; 0x4556 <report_alarm_message>
    40f6:	0b c0       	rjmp	.+22     	; 0x410e <protocol_execute_realtime+0x82>
    } else if (rt_exec & EXEC_ALARM_PROBE_FAIL) {
    40f8:	14 ff       	sbrs	r17, 4
    40fa:	04 c0       	rjmp	.+8      	; 0x4104 <protocol_execute_realtime+0x78>
      report_alarm_message(ALARM_PROBE_FAIL);
    40fc:	84 e0       	ldi	r24, 0x04	; 4
    40fe:	0e 94 ab 22 	call	0x4556	; 0x4556 <report_alarm_message>
    4102:	05 c0       	rjmp	.+10     	; 0x410e <protocol_execute_realtime+0x82>
    } else if (rt_exec & EXEC_ALARM_HOMING_FAIL) {
    4104:	15 ff       	sbrs	r17, 5
    4106:	03 c0       	rjmp	.+6      	; 0x410e <protocol_execute_realtime+0x82>
      report_alarm_message(ALARM_HOMING_FAIL);
    4108:	85 e0       	ldi	r24, 0x05	; 5
    410a:	0e 94 ab 22 	call	0x4556	; 0x4556 <report_alarm_message>
    }
    // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
    if (rt_exec & EXEC_CRITICAL_EVENT) {
    410e:	10 ff       	sbrs	r17, 0
    4110:	0f c0       	rjmp	.+30     	; 0x4130 <protocol_execute_realtime+0xa4>
      report_feedback_message(MESSAGE_CRITICAL_EVENT);
    4112:	80 2f       	mov	r24, r16
    4114:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <report_feedback_message>
      bit_false_atomic(sys_rt_exec_state,EXEC_RESET); // Disable any existing reset
    4118:	9f b7       	in	r25, 0x3f	; 63
    411a:	f8 94       	cli
    411c:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    4120:	8f 7e       	andi	r24, 0xEF	; 239
    4122:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <sys_rt_exec_state>
    4126:	9f bf       	out	0x3f, r25	; 63
        // TODO: Allow status reports during a critical alarm. Still need to think about implications of this.
//         if (sys_rt_exec_state & EXEC_STATUS_REPORT) { 
//           report_realtime_status();
//           bit_false_atomic(sys_rt_exec_state,EXEC_STATUS_REPORT); 
//         }
      } while (bit_isfalse(sys_rt_exec_state,EXEC_RESET));
    4128:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    412c:	84 ff       	sbrs	r24, 4
    412e:	fc cf       	rjmp	.-8      	; 0x4128 <protocol_execute_realtime+0x9c>
    }
    bit_false_atomic(sys_rt_exec_alarm,0xFF); // Clear all alarm flags
    4130:	8f b7       	in	r24, 0x3f	; 63
    4132:	f8 94       	cli
    4134:	90 91 27 05 	lds	r25, 0x0527	; 0x800527 <sys_rt_exec_alarm>
    4138:	10 92 27 05 	sts	0x0527, r1	; 0x800527 <sys_rt_exec_alarm>
    413c:	8f bf       	out	0x3f, r24	; 63
  }
  
  // Check amd execute realtime commands
  rt_exec = sys_rt_exec_state; // Copy volatile sys_rt_exec_state.
    413e:	10 91 25 05 	lds	r17, 0x0525	; 0x800525 <sys_rt_exec_state>
  if (rt_exec) { // Enter only if any bit flag is true
    4142:	11 23       	and	r17, r17
    4144:	09 f4       	brne	.+2      	; 0x4148 <protocol_execute_realtime+0xbc>
    4146:	a5 c0       	rjmp	.+330    	; 0x4292 <protocol_execute_realtime+0x206>
  
    // Execute system abort. 
    if (rt_exec & EXEC_RESET) {
    4148:	14 ff       	sbrs	r17, 4
    414a:	04 c0       	rjmp	.+8      	; 0x4154 <protocol_execute_realtime+0xc8>
      sys.abort = true;  // Only place this is set true.
    414c:	81 e0       	ldi	r24, 0x01	; 1
    414e:	80 93 a0 05 	sts	0x05A0, r24	; 0x8005a0 <sys>
      return; // Nothing else to do but exit.
    4152:	bf c0       	rjmp	.+382    	; 0x42d2 <protocol_execute_realtime+0x246>
    }
    
    // Execute and serial print status
    if (rt_exec & EXEC_STATUS_REPORT) { 
    4154:	10 ff       	sbrs	r17, 0
    4156:	0a c0       	rjmp	.+20     	; 0x416c <protocol_execute_realtime+0xe0>
      report_realtime_status();
    4158:	0e 94 06 27 	call	0x4e0c	; 0x4e0c <report_realtime_status>
      bit_false_atomic(sys_rt_exec_state,EXEC_STATUS_REPORT);
    415c:	9f b7       	in	r25, 0x3f	; 63
    415e:	f8 94       	cli
    4160:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    4164:	8e 7f       	andi	r24, 0xFE	; 254
    4166:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <sys_rt_exec_state>
    416a:	9f bf       	out	0x3f, r25	; 63
  
    // Execute hold states.
    // NOTE: The math involved to calculate the hold should be low enough for most, if not all, 
    // operational scenarios. Once hold is initiated, the system enters a suspend state to block
    // all main program processes until either reset or resumed.
    if (rt_exec & (EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR)) {
    416c:	81 2f       	mov	r24, r17
    416e:	88 76       	andi	r24, 0x68	; 104
    4170:	09 f4       	brne	.+2      	; 0x4174 <protocol_execute_realtime+0xe8>
    4172:	a9 c0       	rjmp	.+338    	; 0x42c6 <protocol_execute_realtime+0x23a>
      
      // TODO: CHECK MODE? How to handle this? Likely nothing, since it only works when IDLE and then resets Grbl.
                
      // State check for allowable states for hold methods.
      if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_MOTION_CANCEL | STATE_HOLD | STATE_SAFETY_DOOR))) {
    4174:	89 81       	ldd	r24, Y+1	; 0x01
    4176:	88 23       	and	r24, r24
    4178:	59 f0       	breq	.+22     	; 0x4190 <protocol_execute_realtime+0x104>
    417a:	98 2f       	mov	r25, r24
    417c:	9c 77       	andi	r25, 0x7C	; 124
    417e:	09 f0       	breq	.+2      	; 0x4182 <protocol_execute_realtime+0xf6>
    4180:	9f c0       	rjmp	.+318    	; 0x42c0 <protocol_execute_realtime+0x234>
    4182:	23 c0       	rjmp	.+70     	; 0x41ca <protocol_execute_realtime+0x13e>

        // If in CYCLE state, all hold states immediately initiate a motion HOLD.
        if (sys.state == STATE_CYCLE) {
          st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
    4184:	0e 94 0b 2f 	call	0x5e16	; 0x5e16 <st_update_plan_block_parameters>
          sys.suspend = SUSPEND_ENABLE_HOLD; // Initiate holding cycle with flag.
    4188:	0a 83       	std	Y+2, r16	; 0x02
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend ready state.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_ENABLE_READY; }
    418a:	89 81       	ldd	r24, Y+1	; 0x01
    418c:	81 11       	cpse	r24, r1
    418e:	05 c0       	rjmp	.+10     	; 0x419a <protocol_execute_realtime+0x10e>
    4190:	82 e0       	ldi	r24, 0x02	; 2
    4192:	8a 83       	std	Y+2, r24	; 0x02
        
        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
    4194:	16 fd       	sbrc	r17, 6
    4196:	06 c0       	rjmp	.+12     	; 0x41a4 <protocol_execute_realtime+0x118>
    4198:	99 c0       	rjmp	.+306    	; 0x42cc <protocol_execute_realtime+0x240>
    419a:	16 ff       	sbrs	r17, 6
    419c:	06 c0       	rjmp	.+12     	; 0x41aa <protocol_execute_realtime+0x11e>
          // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiated beforehand
          // to hold the CYCLE. If so, only flag that motion cancel is complete.
          if (sys.state == STATE_CYCLE) { sys.state = STATE_MOTION_CANCEL; }
    419e:	88 30       	cpi	r24, 0x08	; 8
    41a0:	09 f4       	brne	.+2      	; 0x41a4 <protocol_execute_realtime+0x118>
    41a2:	b9 82       	std	Y+1, r11	; 0x01
          sys.suspend |= SUSPEND_MOTION_CANCEL; // Indicate motion cancel when resuming. Special motion complete.
    41a4:	8a 81       	ldd	r24, Y+2	; 0x02
    41a6:	88 60       	ori	r24, 0x08	; 8
    41a8:	8a 83       	std	Y+2, r24	; 0x02
        }
    
        // Execute a feed hold with deceleration, only during cycle.
        if (rt_exec & EXEC_FEED_HOLD) {
    41aa:	13 ff       	sbrs	r17, 3
    41ac:	03 c0       	rjmp	.+6      	; 0x41b4 <protocol_execute_realtime+0x128>
          // Block SAFETY_DOOR state from prematurely changing back to HOLD.
          if (bit_isfalse(sys.state,STATE_SAFETY_DOOR)) { sys.state = STATE_HOLD; }
    41ae:	89 81       	ldd	r24, Y+1	; 0x01
    41b0:	85 ff       	sbrs	r24, 5
    41b2:	d9 82       	std	Y+1, r13	; 0x01
  
        // Execute a safety door stop with a feed hold, only during a cycle, and disable spindle/coolant.
        // NOTE: Safety door differs from feed holds by stopping everything no matter state, disables powered
        // devices (spindle/coolant), and blocks resuming until switch is re-engaged. The power-down is 
        // executed here, if IDLE, or when the CYCLE completes via the EXEC_CYCLE_STOP flag.
        if (rt_exec & EXEC_SAFETY_DOOR) {
    41b4:	15 ff       	sbrs	r17, 5
    41b6:	09 c0       	rjmp	.+18     	; 0x41ca <protocol_execute_realtime+0x13e>
          report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR); 
    41b8:	86 e0       	ldi	r24, 0x06	; 6
    41ba:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <report_feedback_message>
          // If already in active, ready-to-resume HOLD, set CYCLE_STOP flag to force de-energize.
          // NOTE: Only temporarily sets the 'rt_exec' variable, not the volatile 'rt_exec_state' variable.
          if (sys.suspend & SUSPEND_ENABLE_READY) { bit_true(rt_exec,EXEC_CYCLE_STOP); }
    41be:	8a 81       	ldd	r24, Y+2	; 0x02
    41c0:	81 fd       	sbrc	r24, 1
    41c2:	14 60       	ori	r17, 0x04	; 4
          sys.suspend |= SUSPEND_ENERGIZE;
    41c4:	84 60       	ori	r24, 0x04	; 4
    41c6:	8a 83       	std	Y+2, r24	; 0x02
          sys.state = STATE_SAFETY_DOOR;
    41c8:	c9 82       	std	Y+1, r12	; 0x01
        }
         
      }
      bit_false_atomic(sys_rt_exec_state,(EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR));      
    41ca:	9f b7       	in	r25, 0x3f	; 63
    41cc:	f8 94       	cli
    41ce:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    41d2:	87 79       	andi	r24, 0x97	; 151
    41d4:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <sys_rt_exec_state>
    41d8:	9f bf       	out	0x3f, r25	; 63
    }
          
    // Execute a cycle start by starting the stepper interrupt to begin executing the blocks in queue.
    if (rt_exec & EXEC_CYCLE_START) {
    41da:	11 ff       	sbrs	r17, 1
    41dc:	3d c0       	rjmp	.+122    	; 0x4258 <protocol_execute_realtime+0x1cc>
      // Block if called at same time as the hold commands: feed hold, motion cancel, and safety door.
      // Ensures auto-cycle-start doesn't resume a hold without an explicit user-input.
      if (!(rt_exec & (EXEC_FEED_HOLD | EXEC_MOTION_CANCEL | EXEC_SAFETY_DOOR))) { 
    41de:	81 2f       	mov	r24, r17
    41e0:	88 76       	andi	r24, 0x68	; 104
    41e2:	91 f5       	brne	.+100    	; 0x4248 <protocol_execute_realtime+0x1bc>
        // Cycle start only when IDLE or when a hold is complete and ready to resume.
        // NOTE: SAFETY_DOOR is implicitly blocked. It reverts to HOLD when the door is closed.
        if ((sys.state == STATE_IDLE) || ((sys.state & (STATE_HOLD | STATE_MOTION_CANCEL)) && (sys.suspend & SUSPEND_ENABLE_READY))) {
    41e4:	89 81       	ldd	r24, Y+1	; 0x01
    41e6:	88 23       	and	r24, r24
    41e8:	29 f0       	breq	.+10     	; 0x41f4 <protocol_execute_realtime+0x168>
    41ea:	80 75       	andi	r24, 0x50	; 80
    41ec:	69 f1       	breq	.+90     	; 0x4248 <protocol_execute_realtime+0x1bc>
    41ee:	8a 81       	ldd	r24, Y+2	; 0x02
    41f0:	81 ff       	sbrs	r24, 1
    41f2:	2a c0       	rjmp	.+84     	; 0x4248 <protocol_execute_realtime+0x1bc>
          // Re-energize powered components, if disabled by SAFETY_DOOR.
          if (sys.suspend & SUSPEND_ENERGIZE) { 
    41f4:	8a 81       	ldd	r24, Y+2	; 0x02
    41f6:	82 ff       	sbrs	r24, 2
    41f8:	18 c0       	rjmp	.+48     	; 0x422a <protocol_execute_realtime+0x19e>
            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
    41fa:	f7 01       	movw	r30, r14
    41fc:	81 85       	ldd	r24, Z+9	; 0x09
    41fe:	88 23       	and	r24, r24
    4200:	51 f0       	breq	.+20     	; 0x4216 <protocol_execute_realtime+0x18a>
              spindle_set_state(gc_state.modal.spindle, gc_state.spindle_speed); 
    4202:	42 85       	ldd	r20, Z+10	; 0x0a
    4204:	53 85       	ldd	r21, Z+11	; 0x0b
    4206:	64 85       	ldd	r22, Z+12	; 0x0c
    4208:	75 85       	ldd	r23, Z+13	; 0x0d
    420a:	0e 94 c6 2b 	call	0x578c	; 0x578c <spindle_set_state>
              delay_ms(SAFETY_DOOR_SPINDLE_DELAY); // TODO: Blocking function call. Need a non-blocking one eventually.
    420e:	80 ea       	ldi	r24, 0xA0	; 160
    4210:	9f e0       	ldi	r25, 0x0F	; 15
    4212:	0e 94 2b 19 	call	0x3256	; 0x3256 <delay_ms>
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) { 
    4216:	f7 01       	movw	r30, r14
    4218:	80 85       	ldd	r24, Z+8	; 0x08
    421a:	88 23       	and	r24, r24
    421c:	31 f0       	breq	.+12     	; 0x422a <protocol_execute_realtime+0x19e>
              coolant_set_state(gc_state.modal.coolant); 
    421e:	0e 94 ff 04 	call	0x9fe	; 0x9fe <coolant_set_state>
              delay_ms(SAFETY_DOOR_COOLANT_DELAY); // TODO: Blocking function call. Need a non-blocking one eventually.
    4222:	88 ee       	ldi	r24, 0xE8	; 232
    4224:	93 e0       	ldi	r25, 0x03	; 3
    4226:	0e 94 2b 19 	call	0x3256	; 0x3256 <delay_ms>
            }
            // TODO: Install return to pre-park position.
          }
          // Start cycle only if queued motions exist in planner buffer and the motion is not canceled.
          if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
    422a:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <plan_get_current_block>
    422e:	89 2b       	or	r24, r25
    4230:	49 f0       	breq	.+18     	; 0x4244 <protocol_execute_realtime+0x1b8>
    4232:	8a 81       	ldd	r24, Y+2	; 0x02
    4234:	83 fd       	sbrc	r24, 3
    4236:	06 c0       	rjmp	.+12     	; 0x4244 <protocol_execute_realtime+0x1b8>
            sys.state = STATE_CYCLE;
    4238:	a9 82       	std	Y+1, r10	; 0x01
            st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
    423a:	0e 94 2a 2f 	call	0x5e54	; 0x5e54 <st_prep_buffer>
            st_wake_up();
    423e:	0e 94 3c 2c 	call	0x5878	; 0x5878 <st_wake_up>
    4242:	01 c0       	rjmp	.+2      	; 0x4246 <protocol_execute_realtime+0x1ba>
          } else { // Otherwise, do nothing. Set and resume IDLE state.
            sys.state = STATE_IDLE;
    4244:	19 82       	std	Y+1, r1	; 0x01
          }
          sys.suspend = SUSPEND_DISABLE; // Break suspend state.
    4246:	1a 82       	std	Y+2, r1	; 0x02
        }
      }    
      bit_false_atomic(sys_rt_exec_state,EXEC_CYCLE_START);
    4248:	9f b7       	in	r25, 0x3f	; 63
    424a:	f8 94       	cli
    424c:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    4250:	8d 7f       	andi	r24, 0xFD	; 253
    4252:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <sys_rt_exec_state>
    4256:	9f bf       	out	0x3f, r25	; 63
    // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by 
    // realtime command execution in the main program, ensuring that the planner re-plans safely.
    // NOTE: Bresenham algorithm variables are still maintained through both the planner and stepper
    // cycle reinitializations. The stepper path should continue exactly as if nothing has happened.   
    // NOTE: EXEC_CYCLE_STOP is set by the stepper subsystem when a cycle or feed hold completes.
    if (rt_exec & EXEC_CYCLE_STOP) {
    4258:	12 ff       	sbrs	r17, 2
    425a:	1b c0       	rjmp	.+54     	; 0x4292 <protocol_execute_realtime+0x206>
      if (sys.state & (STATE_HOLD | STATE_SAFETY_DOOR) && !(sys.soft_limit)) {
    425c:	89 81       	ldd	r24, Y+1	; 0x01
    425e:	80 73       	andi	r24, 0x30	; 48
    4260:	71 f0       	breq	.+28     	; 0x427e <protocol_execute_realtime+0x1f2>
    4262:	8b 81       	ldd	r24, Y+3	; 0x03
    4264:	81 11       	cpse	r24, r1
    4266:	0b c0       	rjmp	.+22     	; 0x427e <protocol_execute_realtime+0x1f2>
        // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until user
        // has issued a resume command or reset.
        if (sys.suspend & SUSPEND_ENERGIZE) { // De-energize system if safety door has been opened.
    4268:	8a 81       	ldd	r24, Y+2	; 0x02
    426a:	82 ff       	sbrs	r24, 2
    426c:	04 c0       	rjmp	.+8      	; 0x4276 <protocol_execute_realtime+0x1ea>
          spindle_stop();
    426e:	0e 94 bb 2b 	call	0x5776	; 0x5776 <spindle_stop>
          coolant_stop();
    4272:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <coolant_stop>
        }
        bit_true(sys.suspend,SUSPEND_ENABLE_READY);
    4276:	8a 81       	ldd	r24, Y+2	; 0x02
    4278:	82 60       	ori	r24, 0x02	; 2
    427a:	8a 83       	std	Y+2, r24	; 0x02
    427c:	02 c0       	rjmp	.+4      	; 0x4282 <protocol_execute_realtime+0x1f6>
      } else { // Motion is complete. Includes CYCLE, HOMING, and MOTION_CANCEL states.
        sys.suspend = SUSPEND_DISABLE;
    427e:	1a 82       	std	Y+2, r1	; 0x02
        sys.state = STATE_IDLE;
    4280:	19 82       	std	Y+1, r1	; 0x01
      }
      bit_false_atomic(sys_rt_exec_state,EXEC_CYCLE_STOP);
    4282:	9f b7       	in	r25, 0x3f	; 63
    4284:	f8 94       	cli
    4286:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    428a:	8b 7f       	andi	r24, 0xFB	; 251
    428c:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <sys_rt_exec_state>
    4290:	9f bf       	out	0x3f, r25	; 63

  // Overrides flag byte (sys.override) and execution should be installed here, since they 
  // are realtime and require a direct and controlled interface to the main stepper program.

  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_MOTION_CANCEL | STATE_SAFETY_DOOR | STATE_HOMING)) { st_prep_buffer(); }  
    4292:	89 81       	ldd	r24, Y+1	; 0x01
    4294:	8c 77       	andi	r24, 0x7C	; 124
    4296:	11 f0       	breq	.+4      	; 0x429c <protocol_execute_realtime+0x210>
    4298:	0e 94 2a 2f 	call	0x5e54	; 0x5e54 <st_prep_buffer>
  
  // If safety door was opened, actively check when safety door is closed and ready to resume.
  // NOTE: This unlocks the SAFETY_DOOR state to a HOLD state, such that CYCLE_START can activate a resume.
  if (sys.state == STATE_SAFETY_DOOR) { 
    429c:	89 81       	ldd	r24, Y+1	; 0x01
    429e:	80 32       	cpi	r24, 0x20	; 32
    42a0:	41 f4       	brne	.+16     	; 0x42b2 <protocol_execute_realtime+0x226>
    if (bit_istrue(sys.suspend,SUSPEND_ENABLE_READY)) { 
    42a2:	8a 81       	ldd	r24, Y+2	; 0x02
    42a4:	81 ff       	sbrs	r24, 1
    42a6:	05 c0       	rjmp	.+10     	; 0x42b2 <protocol_execute_realtime+0x226>
      if (!(system_check_safety_door_ajar())) {
    42a8:	0e 94 5e 36 	call	0x6cbc	; 0x6cbc <system_check_safety_door_ajar>
    42ac:	81 11       	cpse	r24, r1
    42ae:	01 c0       	rjmp	.+2      	; 0x42b2 <protocol_execute_realtime+0x226>
        sys.state = STATE_HOLD; // Update to HOLD state to indicate door is closed and ready to resume.
    42b0:	d9 82       	std	Y+1, r13	; 0x01
      }
    }
  }

  } while(sys.suspend); // Check for system suspend state before exiting.
    42b2:	8a 81       	ldd	r24, Y+2	; 0x02
    42b4:	81 11       	cpse	r24, r1
    42b6:	09 cf       	rjmp	.-494    	; 0x40ca <protocol_execute_realtime+0x3e>
    42b8:	0c c0       	rjmp	.+24     	; 0x42d2 <protocol_execute_realtime+0x246>
        // If IDLE, Grbl is not in motion. Simply indicate suspend ready state.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_ENABLE_READY; }
        
        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
    42ba:	16 ff       	sbrs	r17, 6
    42bc:	76 cf       	rjmp	.-276    	; 0x41aa <protocol_execute_realtime+0x11e>
    42be:	72 cf       	rjmp	.-284    	; 0x41a4 <protocol_execute_realtime+0x118>
                
      // State check for allowable states for hold methods.
      if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_MOTION_CANCEL | STATE_HOLD | STATE_SAFETY_DOOR))) {

        // If in CYCLE state, all hold states immediately initiate a motion HOLD.
        if (sys.state == STATE_CYCLE) {
    42c0:	88 30       	cpi	r24, 0x08	; 8
    42c2:	d9 f7       	brne	.-10     	; 0x42ba <protocol_execute_realtime+0x22e>
    42c4:	5f cf       	rjmp	.-322    	; 0x4184 <protocol_execute_realtime+0xf8>
      }
      bit_false_atomic(sys_rt_exec_state,(EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR));      
    }
          
    // Execute a cycle start by starting the stepper interrupt to begin executing the blocks in queue.
    if (rt_exec & EXEC_CYCLE_START) {
    42c6:	11 fd       	sbrc	r17, 1
    42c8:	8d cf       	rjmp	.-230    	; 0x41e4 <protocol_execute_realtime+0x158>
    42ca:	c6 cf       	rjmp	.-116    	; 0x4258 <protocol_execute_realtime+0x1cc>
          if (sys.state == STATE_CYCLE) { sys.state = STATE_MOTION_CANCEL; }
          sys.suspend |= SUSPEND_MOTION_CANCEL; // Indicate motion cancel when resuming. Special motion complete.
        }
    
        // Execute a feed hold with deceleration, only during cycle.
        if (rt_exec & EXEC_FEED_HOLD) {
    42cc:	13 fd       	sbrc	r17, 3
    42ce:	71 cf       	rjmp	.-286    	; 0x41b2 <protocol_execute_realtime+0x126>
    42d0:	71 cf       	rjmp	.-286    	; 0x41b4 <protocol_execute_realtime+0x128>
    }
  }

  } while(sys.suspend); // Check for system suspend state before exiting.
  
}  
    42d2:	df 91       	pop	r29
    42d4:	cf 91       	pop	r28
    42d6:	1f 91       	pop	r17
    42d8:	0f 91       	pop	r16
    42da:	ff 90       	pop	r15
    42dc:	ef 90       	pop	r14
    42de:	df 90       	pop	r13
    42e0:	cf 90       	pop	r12
    42e2:	bf 90       	pop	r11
    42e4:	af 90       	pop	r10
    42e6:	08 95       	ret

000042e8 <protocol_auto_cycle_start>:
// command in the planner queue.
// NOTE: This function is called from the main loop, buffer sync, and mc_line() only and executes 
// when one of these conditions exist respectively: There are no more blocks sent (i.e. streaming 
// is finished, single commands), a command that needs to wait for the motions in the buffer to 
// execute calls a buffer sync, or the planner buffer is full and ready to go.
void protocol_auto_cycle_start() { bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START); } 
    42e8:	9f b7       	in	r25, 0x3f	; 63
    42ea:	f8 94       	cli
    42ec:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    42f0:	82 60       	ori	r24, 0x02	; 2
    42f2:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <sys_rt_exec_state>
    42f6:	9f bf       	out	0x3f, r25	; 63
    42f8:	08 95       	ret

000042fa <protocol_main_loop>:

/* 
  GRBL PRIMARY LOOP:
*/
void protocol_main_loop()
{
    42fa:	bf 92       	push	r11
    42fc:	cf 92       	push	r12
    42fe:	df 92       	push	r13
    4300:	ef 92       	push	r14
    4302:	ff 92       	push	r15
    4304:	0f 93       	push	r16
    4306:	1f 93       	push	r17
    4308:	cf 93       	push	r28
    430a:	df 93       	push	r29
  // ------------------------------------------------------------
  // Complete initialization procedures upon a power-up or reset.
  // ------------------------------------------------------------
  
  // Print welcome message   
  report_init_message();
    430c:	0e 94 1e 23 	call	0x463c	; 0x463c <report_init_message>

  // Check for and report alarm state after a reset, error, or an initial power up.
  if (sys.state == STATE_ALARM) {
    4310:	80 91 a1 05 	lds	r24, 0x05A1	; 0x8005a1 <sys+0x1>
    4314:	81 30       	cpi	r24, 0x01	; 1
    4316:	81 f4       	brne	.+32     	; 0x4338 <protocol_main_loop+0x3e>
    report_feedback_message(MESSAGE_ALARM_LOCK); 
    4318:	82 e0       	ldi	r24, 0x02	; 2
    431a:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <report_feedback_message>
          } else if (c == '(') {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            comment = COMMENT_TYPE_PARENTHESES;
    431e:	f1 2c       	mov	r15, r1
    4320:	e1 2c       	mov	r14, r1
    // this indicates that g-code streaming has either filled the planner buffer or has 
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();

    protocol_execute_realtime();  // Runtime command check point.
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    4322:	c0 ea       	ldi	r28, 0xA0	; 160
    4324:	d5 e0       	ldi	r29, 0x05	; 5
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
        char_counter = 0;
    4326:	d1 2c       	mov	r13, r1

  #ifdef REPORT_ECHO_LINE_RECEIVED
    report_echo_line_received(line);
  #endif

  if (line[0] == 0) {
    4328:	02 e0       	ldi	r16, 0x02	; 2
    432a:	14 e0       	ldi	r17, 0x04	; 4
          } else if (c == '(') {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            comment = COMMENT_TYPE_PARENTHESES;
    432c:	cc 24       	eor	r12, r12
    432e:	c3 94       	inc	r12
          } else if (c == ';') {
            // NOTE: ';' comment to EOL is a LinuxCNC definition. Not NIST.
            comment = COMMENT_TYPE_SEMICOLON;
    4330:	68 94       	set
    4332:	bb 24       	eor	r11, r11
    4334:	b1 f8       	bld	r11, 1
    4336:	78 c0       	rjmp	.+240    	; 0x4428 <protocol_main_loop+0x12e>
  // Check for and report alarm state after a reset, error, or an initial power up.
  if (sys.state == STATE_ALARM) {
    report_feedback_message(MESSAGE_ALARM_LOCK); 
  } else {
    // All systems go! But first check for safety door.
    if (system_check_safety_door_ajar()) {
    4338:	0e 94 5e 36 	call	0x6cbc	; 0x6cbc <system_check_safety_door_ajar>
    433c:	88 23       	and	r24, r24
    433e:	41 f0       	breq	.+16     	; 0x4350 <protocol_main_loop+0x56>
      bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
    4340:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    4344:	80 62       	ori	r24, 0x20	; 32
    4346:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <sys_rt_exec_state>
      protocol_execute_realtime(); // Enter safety door mode. Should return as IDLE state.
    434a:	0e 94 46 20 	call	0x408c	; 0x408c <protocol_execute_realtime>
    434e:	02 c0       	rjmp	.+4      	; 0x4354 <protocol_main_loop+0x5a>
    } else {
      sys.state = STATE_IDLE; // Set system to ready. Clear all state flags.
    4350:	10 92 a1 05 	sts	0x05A1, r1	; 0x8005a1 <sys+0x1>
    } 
    system_execute_startup(line); // Execute startup script.
    4354:	82 e0       	ldi	r24, 0x02	; 2
    4356:	94 e0       	ldi	r25, 0x04	; 4
    4358:	0e 94 60 36 	call	0x6cc0	; 0x6cc0 <system_execute_startup>
    435c:	e0 cf       	rjmp	.-64     	; 0x431e <protocol_main_loop+0x24>
    // exceed 256 characters, but the Arduino Uno does not have the memory space for this.
    // With a better processor, it would be very easy to pull this initial parsing out as a 
    // seperate task to be shared by the g-code parser and Grbl's system commands.
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
    435e:	8a 30       	cpi	r24, 0x0A	; 10
    4360:	11 f0       	breq	.+4      	; 0x4366 <protocol_main_loop+0x6c>
    4362:	8d 30       	cpi	r24, 0x0D	; 13
    4364:	79 f5       	brne	.+94     	; 0x43c4 <protocol_main_loop+0xca>
        line[char_counter] = 0; // Set string termination character.
    4366:	ef 2d       	mov	r30, r15
    4368:	f0 e0       	ldi	r31, 0x00	; 0
    436a:	ee 5f       	subi	r30, 0xFE	; 254
    436c:	fb 4f       	sbci	r31, 0xFB	; 251
    436e:	10 82       	st	Z, r1
// Directs and executes one line of formatted input from protocol_process. While mostly
// incoming streaming g-code blocks, this also directs and executes Grbl internal commands,
// such as settings, initiating the homing cycle, and toggling switch states.
static void protocol_execute_line(char *line) 
{      
  protocol_execute_realtime(); // Runtime command check point.
    4370:	0e 94 46 20 	call	0x408c	; 0x408c <protocol_execute_realtime>
  if (sys.abort) { return; } // Bail to calling function upon system abort  
    4374:	88 81       	ld	r24, Y
    4376:	81 11       	cpse	r24, r1
    4378:	51 c0       	rjmp	.+162    	; 0x441c <protocol_main_loop+0x122>

  #ifdef REPORT_ECHO_LINE_RECEIVED
    report_echo_line_received(line);
  #endif

  if (line[0] == 0) {
    437a:	f8 01       	movw	r30, r16
    437c:	80 81       	ld	r24, Z
    437e:	81 11       	cpse	r24, r1
    4380:	06 c0       	rjmp	.+12     	; 0x438e <protocol_main_loop+0x94>
    // Empty or comment line. Send status message for syncing purposes.
    report_status_message(STATUS_OK);
    4382:	8d 2d       	mov	r24, r13
    4384:	0e 94 3f 22 	call	0x447e	; 0x447e <report_status_message>
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
        char_counter = 0;
    4388:	fd 2c       	mov	r15, r13
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
    438a:	ed 2c       	mov	r14, r13
    438c:	4d c0       	rjmp	.+154    	; 0x4428 <protocol_main_loop+0x12e>

  if (line[0] == 0) {
    // Empty or comment line. Send status message for syncing purposes.
    report_status_message(STATUS_OK);

  } else if (line[0] == '$') {
    438e:	84 32       	cpi	r24, 0x24	; 36
    4390:	41 f4       	brne	.+16     	; 0x43a2 <protocol_main_loop+0xa8>
    // Grbl '$' system command
    report_status_message(system_execute_line(line));
    4392:	c8 01       	movw	r24, r16
    4394:	0e 94 82 36 	call	0x6d04	; 0x6d04 <system_execute_line>
    4398:	0e 94 3f 22 	call	0x447e	; 0x447e <report_status_message>
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
        char_counter = 0;
    439c:	fd 2c       	mov	r15, r13
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
    439e:	ed 2c       	mov	r14, r13
    43a0:	43 c0       	rjmp	.+134    	; 0x4428 <protocol_main_loop+0x12e>

  } else if (line[0] == '$') {
    // Grbl '$' system command
    report_status_message(system_execute_line(line));
    
  } else if (sys.state == STATE_ALARM) {
    43a2:	89 81       	ldd	r24, Y+1	; 0x01
    43a4:	81 30       	cpi	r24, 0x01	; 1
    43a6:	31 f4       	brne	.+12     	; 0x43b4 <protocol_main_loop+0xba>
    // Everything else is gcode. Block if in alarm mode.
    report_status_message(STATUS_ALARM_LOCK);
    43a8:	89 e0       	ldi	r24, 0x09	; 9
    43aa:	0e 94 3f 22 	call	0x447e	; 0x447e <report_status_message>
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
        char_counter = 0;
    43ae:	fd 2c       	mov	r15, r13
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
    43b0:	ed 2c       	mov	r14, r13
    43b2:	3a c0       	rjmp	.+116    	; 0x4428 <protocol_main_loop+0x12e>
    // Everything else is gcode. Block if in alarm mode.
    report_status_message(STATUS_ALARM_LOCK);

  } else {
    // Parse and execute g-code block!
    report_status_message(gc_execute_line(line));
    43b4:	c8 01       	movw	r24, r16
    43b6:	0e 94 0b 06 	call	0xc16	; 0xc16 <gc_execute_line>
    43ba:	0e 94 3f 22 	call	0x447e	; 0x447e <report_status_message>
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
        char_counter = 0;
    43be:	fd 2c       	mov	r15, r13
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
    43c0:	ed 2c       	mov	r14, r13
    43c2:	32 c0       	rjmp	.+100    	; 0x4428 <protocol_main_loop+0x12e>
        char_counter = 0;
      } else {
        if (comment != COMMENT_NONE) {
    43c4:	ee 20       	and	r14, r14
    43c6:	39 f0       	breq	.+14     	; 0x43d6 <protocol_main_loop+0xdc>
          // Throw away all comment characters
          if (c == ')') {
    43c8:	89 32       	cpi	r24, 0x29	; 41
    43ca:	71 f5       	brne	.+92     	; 0x4428 <protocol_main_loop+0x12e>
            // End of comment. Resume line. But, not if semicolon type comment.
            if (comment == COMMENT_TYPE_PARENTHESES) { comment = COMMENT_NONE; }
    43cc:	f1 e0       	ldi	r31, 0x01	; 1
    43ce:	ef 12       	cpse	r14, r31
    43d0:	2b c0       	rjmp	.+86     	; 0x4428 <protocol_main_loop+0x12e>
    43d2:	ed 2c       	mov	r14, r13
    43d4:	29 c0       	rjmp	.+82     	; 0x4428 <protocol_main_loop+0x12e>
          }
        } else {
          if (c <= ' ') { 
    43d6:	81 32       	cpi	r24, 0x21	; 33
    43d8:	38 f1       	brcs	.+78     	; 0x4428 <protocol_main_loop+0x12e>
            // Throw away whitepace and control characters  
          } else if (c == '/') { 
    43da:	8f 32       	cpi	r24, 0x2F	; 47
    43dc:	29 f1       	breq	.+74     	; 0x4428 <protocol_main_loop+0x12e>
            // Block delete NOT SUPPORTED. Ignore character.
            // NOTE: If supported, would simply need to check the system if block delete is enabled.
          } else if (c == '(') {
    43de:	88 32       	cpi	r24, 0x28	; 40
    43e0:	01 f1       	breq	.+64     	; 0x4422 <protocol_main_loop+0x128>
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            comment = COMMENT_TYPE_PARENTHESES;
          } else if (c == ';') {
    43e2:	8b 33       	cpi	r24, 0x3B	; 59
    43e4:	01 f1       	breq	.+64     	; 0x4426 <protocol_main_loop+0x12c>
            // NOTE: This maybe installed to tell Grbl when a program is running vs manual input,
            // where, during a program, the system auto-cycle start will continue to execute 
            // everything until the next '%' sign. This will help fix resuming issues with certain
            // functions that empty the planner buffer to execute its task on-time.

          } else if (char_counter >= (LINE_BUFFER_SIZE-1)) {
    43e6:	9e e4       	ldi	r25, 0x4E	; 78
    43e8:	9f 15       	cp	r25, r15
    43ea:	28 f4       	brcc	.+10     	; 0x43f6 <protocol_main_loop+0xfc>
            // Detect line buffer overflow. Report error and reset line buffer.
            report_status_message(STATUS_OVERFLOW);
    43ec:	8b e0       	ldi	r24, 0x0B	; 11
    43ee:	0e 94 3f 22 	call	0x447e	; 0x447e <report_status_message>
            comment = COMMENT_NONE;
            char_counter = 0;
    43f2:	fd 2c       	mov	r15, r13
    43f4:	19 c0       	rjmp	.+50     	; 0x4428 <protocol_main_loop+0x12e>
          } else if (c >= 'a' && c <= 'z') { // Upcase lowercase
    43f6:	9f e9       	ldi	r25, 0x9F	; 159
    43f8:	98 0f       	add	r25, r24
    43fa:	9a 31       	cpi	r25, 0x1A	; 26
    43fc:	40 f4       	brcc	.+16     	; 0x440e <protocol_main_loop+0x114>
            line[char_counter++] = c-'a'+'A';
    43fe:	ef 2d       	mov	r30, r15
    4400:	f0 e0       	ldi	r31, 0x00	; 0
    4402:	ee 5f       	subi	r30, 0xFE	; 254
    4404:	fb 4f       	sbci	r31, 0xFB	; 251
    4406:	80 52       	subi	r24, 0x20	; 32
    4408:	80 83       	st	Z, r24
    440a:	f3 94       	inc	r15
    440c:	0d c0       	rjmp	.+26     	; 0x4428 <protocol_main_loop+0x12e>
          } else {
            line[char_counter++] = c;
    440e:	ef 2d       	mov	r30, r15
    4410:	f0 e0       	ldi	r31, 0x00	; 0
    4412:	ee 5f       	subi	r30, 0xFE	; 254
    4414:	fb 4f       	sbci	r31, 0xFB	; 251
    4416:	80 83       	st	Z, r24
    4418:	f3 94       	inc	r15
    441a:	06 c0       	rjmp	.+12     	; 0x4428 <protocol_main_loop+0x12e>
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
        char_counter = 0;
    441c:	fd 2c       	mov	r15, r13
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
    441e:	ed 2c       	mov	r14, r13
    4420:	03 c0       	rjmp	.+6      	; 0x4428 <protocol_main_loop+0x12e>
          } else if (c == '(') {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            comment = COMMENT_TYPE_PARENTHESES;
    4422:	ec 2c       	mov	r14, r12
    4424:	01 c0       	rjmp	.+2      	; 0x4428 <protocol_main_loop+0x12e>
          } else if (c == ';') {
            // NOTE: ';' comment to EOL is a LinuxCNC definition. Not NIST.
            comment = COMMENT_TYPE_SEMICOLON;
    4426:	eb 2c       	mov	r14, r11
    // line buffer, which is limited in size. The g-code standard actually states a line can't
    // exceed 256 characters, but the Arduino Uno does not have the memory space for this.
    // With a better processor, it would be very easy to pull this initial parsing out as a 
    // seperate task to be shared by the g-code parser and Grbl's system commands.
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
    4428:	0e 94 68 28 	call	0x50d0	; 0x50d0 <serial_read>
    442c:	8f 3f       	cpi	r24, 0xFF	; 255
    442e:	09 f0       	breq	.+2      	; 0x4432 <protocol_main_loop+0x138>
    4430:	96 cf       	rjmp	.-212    	; 0x435e <protocol_main_loop+0x64>
    }
    
    // If there are no more characters in the serial read buffer to be processed and executed,
    // this indicates that g-code streaming has either filled the planner buffer or has 
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();
    4432:	0e 94 74 21 	call	0x42e8	; 0x42e8 <protocol_auto_cycle_start>

    protocol_execute_realtime();  // Runtime command check point.
    4436:	0e 94 46 20 	call	0x408c	; 0x408c <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    443a:	88 81       	ld	r24, Y
    443c:	88 23       	and	r24, r24
    443e:	a1 f3       	breq	.-24     	; 0x4428 <protocol_main_loop+0x12e>
              
  }
  
  return; /* Never reached */
}
    4440:	df 91       	pop	r29
    4442:	cf 91       	pop	r28
    4444:	1f 91       	pop	r17
    4446:	0f 91       	pop	r16
    4448:	ff 90       	pop	r15
    444a:	ef 90       	pop	r14
    444c:	df 90       	pop	r13
    444e:	cf 90       	pop	r12
    4450:	bf 90       	pop	r11
    4452:	08 95       	ret

00004454 <protocol_buffer_synchronize>:


// Block until all buffered steps are executed or in a cycle state. Works with feed hold
// during a synchronize call, if it should happen. Also, waits for clean cycle end.
void protocol_buffer_synchronize()
{
    4454:	cf 93       	push	r28
    4456:	df 93       	push	r29
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
    4458:	0e 94 74 21 	call	0x42e8	; 0x42e8 <protocol_auto_cycle_start>
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    if (sys.abort) { return; } // Check for system abort
    445c:	c0 ea       	ldi	r28, 0xA0	; 160
    445e:	d5 e0       	ldi	r29, 0x05	; 5
void protocol_buffer_synchronize()
{
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    4460:	0e 94 46 20 	call	0x408c	; 0x408c <protocol_execute_realtime>
    if (sys.abort) { return; } // Check for system abort
    4464:	88 81       	ld	r24, Y
    4466:	81 11       	cpse	r24, r1
    4468:	07 c0       	rjmp	.+14     	; 0x4478 <protocol_buffer_synchronize+0x24>
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
    446a:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <plan_get_current_block>
    446e:	89 2b       	or	r24, r25
    4470:	b9 f7       	brne	.-18     	; 0x4460 <protocol_buffer_synchronize+0xc>
    4472:	89 81       	ldd	r24, Y+1	; 0x01
    4474:	88 30       	cpi	r24, 0x08	; 8
    4476:	a1 f3       	breq	.-24     	; 0x4460 <protocol_buffer_synchronize+0xc>
}
    4478:	df 91       	pop	r29
    447a:	cf 91       	pop	r28
    447c:	08 95       	ret

0000447e <report_status_message>:
// and has been sent into protocol_execute_line() routine to be executed by Grbl.
void report_echo_line_received(char *line)
{
  printPgmString(PSTR("[echo: ")); printString(line);
  printPgmString(PSTR("]\r\n"));
}
    447e:	cf 93       	push	r28
    4480:	c8 2f       	mov	r28, r24
    4482:	81 11       	cpse	r24, r1
    4484:	05 c0       	rjmp	.+10     	; 0x4490 <report_status_message+0x12>
    4486:	84 ec       	ldi	r24, 0xC4	; 196
    4488:	99 e0       	ldi	r25, 0x09	; 9
    448a:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    448e:	61 c0       	rjmp	.+194    	; 0x4552 <report_status_message+0xd4>
    4490:	8c eb       	ldi	r24, 0xBC	; 188
    4492:	99 e0       	ldi	r25, 0x09	; 9
    4494:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4498:	8c 2f       	mov	r24, r28
    449a:	90 e0       	ldi	r25, 0x00	; 0
    449c:	fc 01       	movw	r30, r24
    449e:	31 97       	sbiw	r30, 0x01	; 1
    44a0:	e6 31       	cpi	r30, 0x16	; 22
    44a2:	f1 05       	cpc	r31, r1
    44a4:	08 f0       	brcs	.+2      	; 0x44a8 <report_status_message+0x2a>
    44a6:	4a c0       	rjmp	.+148    	; 0x453c <report_status_message+0xbe>
    44a8:	e9 52       	subi	r30, 0x29	; 41
    44aa:	ff 4f       	sbci	r31, 0xFF	; 255
    44ac:	0c 94 38 3d 	jmp	0x7a70	; 0x7a70 <__tablejump2__>
    44b0:	84 ea       	ldi	r24, 0xA4	; 164
    44b2:	99 e0       	ldi	r25, 0x09	; 9
    44b4:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    44b8:	48 c0       	rjmp	.+144    	; 0x454a <report_status_message+0xcc>
    44ba:	82 e9       	ldi	r24, 0x92	; 146
    44bc:	99 e0       	ldi	r25, 0x09	; 9
    44be:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    44c2:	43 c0       	rjmp	.+134    	; 0x454a <report_status_message+0xcc>
    44c4:	80 e8       	ldi	r24, 0x80	; 128
    44c6:	99 e0       	ldi	r25, 0x09	; 9
    44c8:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    44cc:	3e c0       	rjmp	.+124    	; 0x454a <report_status_message+0xcc>
    44ce:	86 e7       	ldi	r24, 0x76	; 118
    44d0:	99 e0       	ldi	r25, 0x09	; 9
    44d2:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    44d6:	39 c0       	rjmp	.+114    	; 0x454a <report_status_message+0xcc>
    44d8:	85 e6       	ldi	r24, 0x65	; 101
    44da:	99 e0       	ldi	r25, 0x09	; 9
    44dc:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    44e0:	34 c0       	rjmp	.+104    	; 0x454a <report_status_message+0xcc>
    44e2:	86 e5       	ldi	r24, 0x56	; 86
    44e4:	99 e0       	ldi	r25, 0x09	; 9
    44e6:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    44ea:	2f c0       	rjmp	.+94     	; 0x454a <report_status_message+0xcc>
    44ec:	85 e3       	ldi	r24, 0x35	; 53
    44ee:	99 e0       	ldi	r25, 0x09	; 9
    44f0:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    44f4:	2a c0       	rjmp	.+84     	; 0x454a <report_status_message+0xcc>
    44f6:	8c e2       	ldi	r24, 0x2C	; 44
    44f8:	99 e0       	ldi	r25, 0x09	; 9
    44fa:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    44fe:	25 c0       	rjmp	.+74     	; 0x454a <report_status_message+0xcc>
    4500:	81 e2       	ldi	r24, 0x21	; 33
    4502:	99 e0       	ldi	r25, 0x09	; 9
    4504:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4508:	20 c0       	rjmp	.+64     	; 0x454a <report_status_message+0xcc>
    450a:	8e e0       	ldi	r24, 0x0E	; 14
    450c:	99 e0       	ldi	r25, 0x09	; 9
    450e:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4512:	1b c0       	rjmp	.+54     	; 0x454a <report_status_message+0xcc>
    4514:	80 e0       	ldi	r24, 0x00	; 0
    4516:	99 e0       	ldi	r25, 0x09	; 9
    4518:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    451c:	16 c0       	rjmp	.+44     	; 0x454a <report_status_message+0xcc>
    451e:	8a ee       	ldi	r24, 0xEA	; 234
    4520:	98 e0       	ldi	r25, 0x08	; 8
    4522:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4526:	11 c0       	rjmp	.+34     	; 0x454a <report_status_message+0xcc>
    4528:	86 ed       	ldi	r24, 0xD6	; 214
    452a:	98 e0       	ldi	r25, 0x08	; 8
    452c:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4530:	0c c0       	rjmp	.+24     	; 0x454a <report_status_message+0xcc>
    4532:	82 ec       	ldi	r24, 0xC2	; 194
    4534:	98 e0       	ldi	r25, 0x08	; 8
    4536:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    453a:	07 c0       	rjmp	.+14     	; 0x454a <report_status_message+0xcc>
    453c:	80 eb       	ldi	r24, 0xB0	; 176
    453e:	98 e0       	ldi	r25, 0x08	; 8
    4540:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4544:	8c 2f       	mov	r24, r28
    4546:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    454a:	8d ea       	ldi	r24, 0xAD	; 173
    454c:	98 e0       	ldi	r25, 0x08	; 8
    454e:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4552:	cf 91       	pop	r28
    4554:	08 95       	ret

00004556 <report_alarm_message>:
    4556:	cf 93       	push	r28
    4558:	c8 2f       	mov	r28, r24
    455a:	85 ea       	ldi	r24, 0xA5	; 165
    455c:	98 e0       	ldi	r25, 0x08	; 8
    455e:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4562:	c3 30       	cpi	r28, 0x03	; 3
    4564:	a9 f0       	breq	.+42     	; 0x4590 <report_alarm_message+0x3a>
    4566:	2c f4       	brge	.+10     	; 0x4572 <report_alarm_message+0x1c>
    4568:	c1 30       	cpi	r28, 0x01	; 1
    456a:	41 f0       	breq	.+16     	; 0x457c <report_alarm_message+0x26>
    456c:	c2 30       	cpi	r28, 0x02	; 2
    456e:	59 f0       	breq	.+22     	; 0x4586 <report_alarm_message+0x30>
    4570:	1d c0       	rjmp	.+58     	; 0x45ac <report_alarm_message+0x56>
    4572:	c4 30       	cpi	r28, 0x04	; 4
    4574:	91 f0       	breq	.+36     	; 0x459a <report_alarm_message+0x44>
    4576:	c5 30       	cpi	r28, 0x05	; 5
    4578:	a9 f0       	breq	.+42     	; 0x45a4 <report_alarm_message+0x4e>
    457a:	18 c0       	rjmp	.+48     	; 0x45ac <report_alarm_message+0x56>
    457c:	8a e9       	ldi	r24, 0x9A	; 154
    457e:	98 e0       	ldi	r25, 0x08	; 8
    4580:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4584:	13 c0       	rjmp	.+38     	; 0x45ac <report_alarm_message+0x56>
    4586:	8f e8       	ldi	r24, 0x8F	; 143
    4588:	98 e0       	ldi	r25, 0x08	; 8
    458a:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    458e:	0e c0       	rjmp	.+28     	; 0x45ac <report_alarm_message+0x56>
    4590:	8c e7       	ldi	r24, 0x7C	; 124
    4592:	98 e0       	ldi	r25, 0x08	; 8
    4594:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4598:	09 c0       	rjmp	.+18     	; 0x45ac <report_alarm_message+0x56>
    459a:	81 e7       	ldi	r24, 0x71	; 113
    459c:	98 e0       	ldi	r25, 0x08	; 8
    459e:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    45a2:	04 c0       	rjmp	.+8      	; 0x45ac <report_alarm_message+0x56>
    45a4:	85 e6       	ldi	r24, 0x65	; 101
    45a6:	98 e0       	ldi	r25, 0x08	; 8
    45a8:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    45ac:	82 e6       	ldi	r24, 0x62	; 98
    45ae:	98 e0       	ldi	r25, 0x08	; 8
    45b0:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    45b4:	84 ef       	ldi	r24, 0xF4	; 244
    45b6:	91 e0       	ldi	r25, 0x01	; 1
    45b8:	0e 94 2b 19 	call	0x3256	; 0x3256 <delay_ms>
    45bc:	cf 91       	pop	r28
    45be:	08 95       	ret

000045c0 <report_feedback_message>:
    45c0:	cf 93       	push	r28
    45c2:	c8 2f       	mov	r28, r24
    45c4:	80 e6       	ldi	r24, 0x60	; 96
    45c6:	98 e0       	ldi	r25, 0x08	; 8
    45c8:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    45cc:	8c 2f       	mov	r24, r28
    45ce:	90 e0       	ldi	r25, 0x00	; 0
    45d0:	fc 01       	movw	r30, r24
    45d2:	31 97       	sbiw	r30, 0x01	; 1
    45d4:	e8 30       	cpi	r30, 0x08	; 8
    45d6:	f1 05       	cpc	r31, r1
    45d8:	58 f5       	brcc	.+86     	; 0x4630 <report_feedback_message+0x70>
    45da:	e3 51       	subi	r30, 0x13	; 19
    45dc:	ff 4f       	sbci	r31, 0xFF	; 255
    45de:	0c 94 38 3d 	jmp	0x7a70	; 0x7a70 <__tablejump2__>
    45e2:	8e e4       	ldi	r24, 0x4E	; 78
    45e4:	98 e0       	ldi	r25, 0x08	; 8
    45e6:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    45ea:	22 c0       	rjmp	.+68     	; 0x4630 <report_feedback_message+0x70>
    45ec:	8a e3       	ldi	r24, 0x3A	; 58
    45ee:	98 e0       	ldi	r25, 0x08	; 8
    45f0:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    45f4:	1d c0       	rjmp	.+58     	; 0x4630 <report_feedback_message+0x70>
    45f6:	88 e2       	ldi	r24, 0x28	; 40
    45f8:	98 e0       	ldi	r25, 0x08	; 8
    45fa:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    45fe:	18 c0       	rjmp	.+48     	; 0x4630 <report_feedback_message+0x70>
    4600:	80 e2       	ldi	r24, 0x20	; 32
    4602:	98 e0       	ldi	r25, 0x08	; 8
    4604:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4608:	13 c0       	rjmp	.+38     	; 0x4630 <report_feedback_message+0x70>
    460a:	87 e1       	ldi	r24, 0x17	; 23
    460c:	98 e0       	ldi	r25, 0x08	; 8
    460e:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4612:	0e c0       	rjmp	.+28     	; 0x4630 <report_feedback_message+0x70>
    4614:	8c e0       	ldi	r24, 0x0C	; 12
    4616:	98 e0       	ldi	r25, 0x08	; 8
    4618:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    461c:	09 c0       	rjmp	.+18     	; 0x4630 <report_feedback_message+0x70>
    461e:	84 e0       	ldi	r24, 0x04	; 4
    4620:	98 e0       	ldi	r25, 0x08	; 8
    4622:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4626:	04 c0       	rjmp	.+8      	; 0x4630 <report_feedback_message+0x70>
    4628:	81 ef       	ldi	r24, 0xF1	; 241
    462a:	97 e0       	ldi	r25, 0x07	; 7
    462c:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4630:	8d ee       	ldi	r24, 0xED	; 237
    4632:	97 e0       	ldi	r25, 0x07	; 7
    4634:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4638:	cf 91       	pop	r28
    463a:	08 95       	ret

0000463c <report_init_message>:
    463c:	80 ed       	ldi	r24, 0xD0	; 208
    463e:	97 e0       	ldi	r25, 0x07	; 7
    4640:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4644:	08 95       	ret

00004646 <report_grbl_help>:
    4646:	8c e8       	ldi	r24, 0x8C	; 140
    4648:	96 e0       	ldi	r25, 0x06	; 6
    464a:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    464e:	08 95       	ret

00004650 <report_grbl_settings>:
    4650:	1f 93       	push	r17
    4652:	cf 93       	push	r28
    4654:	df 93       	push	r29
    4656:	88 e8       	ldi	r24, 0x88	; 136
    4658:	96 e0       	ldi	r25, 0x06	; 6
    465a:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    465e:	cf e7       	ldi	r28, 0x7F	; 127
    4660:	d6 e0       	ldi	r29, 0x06	; 6
    4662:	88 a9       	ldd	r24, Y+48	; 0x30
    4664:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    4668:	8f e6       	ldi	r24, 0x6F	; 111
    466a:	96 e0       	ldi	r25, 0x06	; 6
    466c:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4670:	8b a9       	ldd	r24, Y+51	; 0x33
    4672:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    4676:	81 e5       	ldi	r24, 0x51	; 81
    4678:	96 e0       	ldi	r25, 0x06	; 6
    467a:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    467e:	89 a9       	ldd	r24, Y+49	; 0x31
    4680:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    4684:	88 e3       	ldi	r24, 0x38	; 56
    4686:	96 e0       	ldi	r25, 0x06	; 6
    4688:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    468c:	89 a9       	ldd	r24, Y+49	; 0x31
    468e:	0e 94 21 1f 	call	0x3e42	; 0x3e42 <print_uint8_base2>
    4692:	81 e3       	ldi	r24, 0x31	; 49
    4694:	96 e0       	ldi	r25, 0x06	; 6
    4696:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    469a:	8a a9       	ldd	r24, Y+50	; 0x32
    469c:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    46a0:	89 e1       	ldi	r24, 0x19	; 25
    46a2:	96 e0       	ldi	r25, 0x06	; 6
    46a4:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    46a8:	8a a9       	ldd	r24, Y+50	; 0x32
    46aa:	0e 94 21 1f 	call	0x3e42	; 0x3e42 <print_uint8_base2>
    46ae:	82 e1       	ldi	r24, 0x12	; 18
    46b0:	96 e0       	ldi	r25, 0x06	; 6
    46b2:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    46b6:	8d ad       	ldd	r24, Y+61	; 0x3d
    46b8:	82 fb       	bst	r24, 2
    46ba:	88 27       	eor	r24, r24
    46bc:	80 f9       	bld	r24, 0
    46be:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    46c2:	81 ef       	ldi	r24, 0xF1	; 241
    46c4:	95 e0       	ldi	r25, 0x05	; 5
    46c6:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    46ca:	8d ad       	ldd	r24, Y+61	; 0x3d
    46cc:	86 fb       	bst	r24, 6
    46ce:	88 27       	eor	r24, r24
    46d0:	80 f9       	bld	r24, 0
    46d2:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    46d6:	81 ed       	ldi	r24, 0xD1	; 209
    46d8:	95 e0       	ldi	r25, 0x05	; 5
    46da:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    46de:	8d ad       	ldd	r24, Y+61	; 0x3d
    46e0:	88 1f       	adc	r24, r24
    46e2:	88 27       	eor	r24, r24
    46e4:	88 1f       	adc	r24, r24
    46e6:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    46ea:	81 eb       	ldi	r24, 0xB1	; 177
    46ec:	95 e0       	ldi	r25, 0x05	; 5
    46ee:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    46f2:	8c a9       	ldd	r24, Y+52	; 0x34
    46f4:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    46f8:	8b e9       	ldi	r24, 0x9B	; 155
    46fa:	95 e0       	ldi	r25, 0x05	; 5
    46fc:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4700:	8c a9       	ldd	r24, Y+52	; 0x34
    4702:	0e 94 21 1f 	call	0x3e42	; 0x3e42 <print_uint8_base2>
    4706:	83 e9       	ldi	r24, 0x93	; 147
    4708:	95 e0       	ldi	r25, 0x05	; 5
    470a:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    470e:	6d a9       	ldd	r22, Y+53	; 0x35
    4710:	7e a9       	ldd	r23, Y+54	; 0x36
    4712:	8f a9       	ldd	r24, Y+55	; 0x37
    4714:	98 ad       	ldd	r25, Y+56	; 0x38
    4716:	0e 94 0e 20 	call	0x401c	; 0x401c <printFloat_SettingValue>
    471a:	83 e7       	ldi	r24, 0x73	; 115
    471c:	95 e0       	ldi	r25, 0x05	; 5
    471e:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4722:	69 ad       	ldd	r22, Y+57	; 0x39
    4724:	7a ad       	ldd	r23, Y+58	; 0x3a
    4726:	8b ad       	ldd	r24, Y+59	; 0x3b
    4728:	9c ad       	ldd	r25, Y+60	; 0x3c
    472a:	0e 94 0e 20 	call	0x401c	; 0x401c <printFloat_SettingValue>
    472e:	88 e5       	ldi	r24, 0x58	; 88
    4730:	95 e0       	ldi	r25, 0x05	; 5
    4732:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4736:	8d ad       	ldd	r24, Y+61	; 0x3d
    4738:	81 70       	andi	r24, 0x01	; 1
    473a:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    473e:	8b e3       	ldi	r24, 0x3B	; 59
    4740:	95 e0       	ldi	r25, 0x05	; 5
    4742:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4746:	8d ad       	ldd	r24, Y+61	; 0x3d
    4748:	85 fb       	bst	r24, 5
    474a:	88 27       	eor	r24, r24
    474c:	80 f9       	bld	r24, 0
    474e:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    4752:	80 e2       	ldi	r24, 0x20	; 32
    4754:	95 e0       	ldi	r25, 0x05	; 5
    4756:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    475a:	8d ad       	ldd	r24, Y+61	; 0x3d
    475c:	83 fb       	bst	r24, 3
    475e:	88 27       	eor	r24, r24
    4760:	80 f9       	bld	r24, 0
    4762:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    4766:	85 e0       	ldi	r24, 0x05	; 5
    4768:	95 e0       	ldi	r25, 0x05	; 5
    476a:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    476e:	8d ad       	ldd	r24, Y+61	; 0x3d
    4770:	82 95       	swap	r24
    4772:	81 70       	andi	r24, 0x01	; 1
    4774:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    4778:	89 ee       	ldi	r24, 0xE9	; 233
    477a:	94 e0       	ldi	r25, 0x04	; 4
    477c:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4780:	8e ad       	ldd	r24, Y+62	; 0x3e
    4782:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    4786:	8f ec       	ldi	r24, 0xCF	; 207
    4788:	94 e0       	ldi	r25, 0x04	; 4
    478a:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    478e:	8e ad       	ldd	r24, Y+62	; 0x3e
    4790:	0e 94 21 1f 	call	0x3e42	; 0x3e42 <print_uint8_base2>
    4794:	87 ec       	ldi	r24, 0xC7	; 199
    4796:	94 e0       	ldi	r25, 0x04	; 4
    4798:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    479c:	60 91 be 06 	lds	r22, 0x06BE	; 0x8006be <settings+0x3f>
    47a0:	70 91 bf 06 	lds	r23, 0x06BF	; 0x8006bf <settings+0x40>
    47a4:	80 91 c0 06 	lds	r24, 0x06C0	; 0x8006c0 <settings+0x41>
    47a8:	90 91 c1 06 	lds	r25, 0x06C1	; 0x8006c1 <settings+0x42>
    47ac:	0e 94 0e 20 	call	0x401c	; 0x401c <printFloat_SettingValue>
    47b0:	8a ea       	ldi	r24, 0xAA	; 170
    47b2:	94 e0       	ldi	r25, 0x04	; 4
    47b4:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    47b8:	60 91 c2 06 	lds	r22, 0x06C2	; 0x8006c2 <settings+0x43>
    47bc:	70 91 c3 06 	lds	r23, 0x06C3	; 0x8006c3 <settings+0x44>
    47c0:	80 91 c4 06 	lds	r24, 0x06C4	; 0x8006c4 <settings+0x45>
    47c4:	90 91 c5 06 	lds	r25, 0x06C5	; 0x8006c5 <settings+0x46>
    47c8:	0e 94 0e 20 	call	0x401c	; 0x401c <printFloat_SettingValue>
    47cc:	8d e8       	ldi	r24, 0x8D	; 141
    47ce:	94 e0       	ldi	r25, 0x04	; 4
    47d0:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    47d4:	80 91 c6 06 	lds	r24, 0x06C6	; 0x8006c6 <settings+0x47>
    47d8:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    47dc:	8e e6       	ldi	r24, 0x6E	; 110
    47de:	94 e0       	ldi	r25, 0x04	; 4
    47e0:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    47e4:	60 91 c8 06 	lds	r22, 0x06C8	; 0x8006c8 <settings+0x49>
    47e8:	70 91 c9 06 	lds	r23, 0x06C9	; 0x8006c9 <settings+0x4a>
    47ec:	80 91 ca 06 	lds	r24, 0x06CA	; 0x8006ca <settings+0x4b>
    47f0:	90 91 cb 06 	lds	r25, 0x06CB	; 0x8006cb <settings+0x4c>
    47f4:	0e 94 0e 20 	call	0x401c	; 0x401c <printFloat_SettingValue>
    47f8:	85 e5       	ldi	r24, 0x55	; 85
    47fa:	94 e0       	ldi	r25, 0x04	; 4
    47fc:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4800:	14 e6       	ldi	r17, 0x64	; 100
    4802:	d0 e0       	ldi	r29, 0x00	; 0
    4804:	f2 c0       	rjmp	.+484    	; 0x49ea <report_grbl_settings+0x39a>
    4806:	83 e5       	ldi	r24, 0x53	; 83
    4808:	94 e0       	ldi	r25, 0x04	; 4
    480a:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    480e:	8c 2f       	mov	r24, r28
    4810:	81 0f       	add	r24, r17
    4812:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    4816:	81 e5       	ldi	r24, 0x51	; 81
    4818:	94 e0       	ldi	r25, 0x04	; 4
    481a:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    481e:	d1 30       	cpi	r29, 0x01	; 1
    4820:	11 f1       	breq	.+68     	; 0x4866 <report_grbl_settings+0x216>
    4822:	30 f0       	brcs	.+12     	; 0x4830 <report_grbl_settings+0x1e0>
    4824:	d2 30       	cpi	r29, 0x02	; 2
    4826:	d1 f1       	breq	.+116    	; 0x489c <report_grbl_settings+0x24c>
    4828:	d3 30       	cpi	r29, 0x03	; 3
    482a:	09 f0       	breq	.+2      	; 0x482e <report_grbl_settings+0x1de>
    482c:	70 c0       	rjmp	.+224    	; 0x490e <report_grbl_settings+0x2be>
    482e:	54 c0       	rjmp	.+168    	; 0x48d8 <report_grbl_settings+0x288>
    4830:	ec 2f       	mov	r30, r28
    4832:	f0 e0       	ldi	r31, 0x00	; 0
    4834:	ee 0f       	add	r30, r30
    4836:	ff 1f       	adc	r31, r31
    4838:	ee 0f       	add	r30, r30
    483a:	ff 1f       	adc	r31, r31
    483c:	e1 58       	subi	r30, 0x81	; 129
    483e:	f9 4f       	sbci	r31, 0xF9	; 249
    4840:	60 81       	ld	r22, Z
    4842:	71 81       	ldd	r23, Z+1	; 0x01
    4844:	82 81       	ldd	r24, Z+2	; 0x02
    4846:	93 81       	ldd	r25, Z+3	; 0x03
    4848:	0e 94 0e 20 	call	0x401c	; 0x401c <printFloat_SettingValue>
    484c:	8e e4       	ldi	r24, 0x4E	; 78
    484e:	94 e0       	ldi	r25, 0x04	; 4
    4850:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4854:	c1 30       	cpi	r28, 0x01	; 1
    4856:	09 f4       	brne	.+2      	; 0x485a <report_grbl_settings+0x20a>
    4858:	6a c0       	rjmp	.+212    	; 0x492e <report_grbl_settings+0x2de>
    485a:	08 f4       	brcc	.+2      	; 0x485e <report_grbl_settings+0x20e>
    485c:	62 c0       	rjmp	.+196    	; 0x4922 <report_grbl_settings+0x2d2>
    485e:	c2 30       	cpi	r28, 0x02	; 2
    4860:	09 f4       	brne	.+2      	; 0x4864 <report_grbl_settings+0x214>
    4862:	6b c0       	rjmp	.+214    	; 0x493a <report_grbl_settings+0x2ea>
    4864:	7f c0       	rjmp	.+254    	; 0x4964 <report_grbl_settings+0x314>
    4866:	ec 2f       	mov	r30, r28
    4868:	f0 e0       	ldi	r31, 0x00	; 0
    486a:	ee 0f       	add	r30, r30
    486c:	ff 1f       	adc	r31, r31
    486e:	ee 0f       	add	r30, r30
    4870:	ff 1f       	adc	r31, r31
    4872:	e5 57       	subi	r30, 0x75	; 117
    4874:	f9 4f       	sbci	r31, 0xF9	; 249
    4876:	60 81       	ld	r22, Z
    4878:	71 81       	ldd	r23, Z+1	; 0x01
    487a:	82 81       	ldd	r24, Z+2	; 0x02
    487c:	93 81       	ldd	r25, Z+3	; 0x03
    487e:	0e 94 0e 20 	call	0x401c	; 0x401c <printFloat_SettingValue>
    4882:	8e e4       	ldi	r24, 0x4E	; 78
    4884:	94 e0       	ldi	r25, 0x04	; 4
    4886:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    488a:	c1 30       	cpi	r28, 0x01	; 1
    488c:	09 f4       	brne	.+2      	; 0x4890 <report_grbl_settings+0x240>
    488e:	4f c0       	rjmp	.+158    	; 0x492e <report_grbl_settings+0x2de>
    4890:	08 f4       	brcc	.+2      	; 0x4894 <report_grbl_settings+0x244>
    4892:	47 c0       	rjmp	.+142    	; 0x4922 <report_grbl_settings+0x2d2>
    4894:	c2 30       	cpi	r28, 0x02	; 2
    4896:	09 f4       	brne	.+2      	; 0x489a <report_grbl_settings+0x24a>
    4898:	50 c0       	rjmp	.+160    	; 0x493a <report_grbl_settings+0x2ea>
    489a:	72 c0       	rjmp	.+228    	; 0x4980 <report_grbl_settings+0x330>
    489c:	ec 2f       	mov	r30, r28
    489e:	f0 e0       	ldi	r31, 0x00	; 0
    48a0:	ee 0f       	add	r30, r30
    48a2:	ff 1f       	adc	r31, r31
    48a4:	ee 0f       	add	r30, r30
    48a6:	ff 1f       	adc	r31, r31
    48a8:	e9 56       	subi	r30, 0x69	; 105
    48aa:	f9 4f       	sbci	r31, 0xF9	; 249
    48ac:	20 e0       	ldi	r18, 0x00	; 0
    48ae:	30 e0       	ldi	r19, 0x00	; 0
    48b0:	41 e6       	ldi	r20, 0x61	; 97
    48b2:	55 e4       	ldi	r21, 0x45	; 69
    48b4:	60 81       	ld	r22, Z
    48b6:	71 81       	ldd	r23, Z+1	; 0x01
    48b8:	82 81       	ldd	r24, Z+2	; 0x02
    48ba:	93 81       	ldd	r25, Z+3	; 0x03
    48bc:	0e 94 a9 39 	call	0x7352	; 0x7352 <__divsf3>
    48c0:	0e 94 0e 20 	call	0x401c	; 0x401c <printFloat_SettingValue>
    48c4:	8e e4       	ldi	r24, 0x4E	; 78
    48c6:	94 e0       	ldi	r25, 0x04	; 4
    48c8:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    48cc:	c1 30       	cpi	r28, 0x01	; 1
    48ce:	79 f1       	breq	.+94     	; 0x492e <report_grbl_settings+0x2de>
    48d0:	40 f1       	brcs	.+80     	; 0x4922 <report_grbl_settings+0x2d2>
    48d2:	c2 30       	cpi	r28, 0x02	; 2
    48d4:	91 f1       	breq	.+100    	; 0x493a <report_grbl_settings+0x2ea>
    48d6:	62 c0       	rjmp	.+196    	; 0x499c <report_grbl_settings+0x34c>
    48d8:	ec 2f       	mov	r30, r28
    48da:	f0 e0       	ldi	r31, 0x00	; 0
    48dc:	ee 0f       	add	r30, r30
    48de:	ff 1f       	adc	r31, r31
    48e0:	ee 0f       	add	r30, r30
    48e2:	ff 1f       	adc	r31, r31
    48e4:	ed 55       	subi	r30, 0x5D	; 93
    48e6:	f9 4f       	sbci	r31, 0xF9	; 249
    48e8:	80 81       	ld	r24, Z
    48ea:	91 81       	ldd	r25, Z+1	; 0x01
    48ec:	a2 81       	ldd	r26, Z+2	; 0x02
    48ee:	b3 81       	ldd	r27, Z+3	; 0x03
    48f0:	bc 01       	movw	r22, r24
    48f2:	cd 01       	movw	r24, r26
    48f4:	90 58       	subi	r25, 0x80	; 128
    48f6:	0e 94 0e 20 	call	0x401c	; 0x401c <printFloat_SettingValue>
    48fa:	8e e4       	ldi	r24, 0x4E	; 78
    48fc:	94 e0       	ldi	r25, 0x04	; 4
    48fe:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4902:	c1 30       	cpi	r28, 0x01	; 1
    4904:	a1 f0       	breq	.+40     	; 0x492e <report_grbl_settings+0x2de>
    4906:	68 f0       	brcs	.+26     	; 0x4922 <report_grbl_settings+0x2d2>
    4908:	c2 30       	cpi	r28, 0x02	; 2
    490a:	b9 f0       	breq	.+46     	; 0x493a <report_grbl_settings+0x2ea>
    490c:	55 c0       	rjmp	.+170    	; 0x49b8 <report_grbl_settings+0x368>
    490e:	8e e4       	ldi	r24, 0x4E	; 78
    4910:	94 e0       	ldi	r25, 0x04	; 4
    4912:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4916:	c1 30       	cpi	r28, 0x01	; 1
    4918:	51 f0       	breq	.+20     	; 0x492e <report_grbl_settings+0x2de>
    491a:	18 f0       	brcs	.+6      	; 0x4922 <report_grbl_settings+0x2d2>
    491c:	c2 30       	cpi	r28, 0x02	; 2
    491e:	69 f0       	breq	.+26     	; 0x493a <report_grbl_settings+0x2ea>
    4920:	19 c0       	rjmp	.+50     	; 0x4954 <report_grbl_settings+0x304>
    4922:	8c e4       	ldi	r24, 0x4C	; 76
    4924:	94 e0       	ldi	r25, 0x04	; 4
    4926:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    492a:	c0 e0       	ldi	r28, 0x00	; 0
    492c:	66 c0       	rjmp	.+204    	; 0x49fa <report_grbl_settings+0x3aa>
    492e:	8a e4       	ldi	r24, 0x4A	; 74
    4930:	94 e0       	ldi	r25, 0x04	; 4
    4932:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4936:	c1 e0       	ldi	r28, 0x01	; 1
    4938:	60 c0       	rjmp	.+192    	; 0x49fa <report_grbl_settings+0x3aa>
    493a:	88 e4       	ldi	r24, 0x48	; 72
    493c:	94 e0       	ldi	r25, 0x04	; 4
    493e:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4942:	c2 e0       	ldi	r28, 0x02	; 2
    4944:	d1 30       	cpi	r29, 0x01	; 1
    4946:	d9 f0       	breq	.+54     	; 0x497e <report_grbl_settings+0x32e>
    4948:	68 f0       	brcs	.+26     	; 0x4964 <report_grbl_settings+0x314>
    494a:	d2 30       	cpi	r29, 0x02	; 2
    494c:	31 f1       	breq	.+76     	; 0x499a <report_grbl_settings+0x34a>
    494e:	d3 30       	cpi	r29, 0x03	; 3
    4950:	91 f1       	breq	.+100    	; 0x49b6 <report_grbl_settings+0x366>
    4952:	90 c0       	rjmp	.+288    	; 0x4a74 <report_grbl_settings+0x424>
    4954:	d1 30       	cpi	r29, 0x01	; 1
    4956:	a1 f0       	breq	.+40     	; 0x4980 <report_grbl_settings+0x330>
    4958:	28 f0       	brcs	.+10     	; 0x4964 <report_grbl_settings+0x314>
    495a:	d2 30       	cpi	r29, 0x02	; 2
    495c:	f9 f0       	breq	.+62     	; 0x499c <report_grbl_settings+0x34c>
    495e:	d3 30       	cpi	r29, 0x03	; 3
    4960:	b9 f5       	brne	.+110    	; 0x49d0 <report_grbl_settings+0x380>
    4962:	2a c0       	rjmp	.+84     	; 0x49b8 <report_grbl_settings+0x368>
    4964:	8e e3       	ldi	r24, 0x3E	; 62
    4966:	94 e0       	ldi	r25, 0x04	; 4
    4968:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    496c:	87 e0       	ldi	r24, 0x07	; 7
    496e:	94 e0       	ldi	r25, 0x04	; 4
    4970:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4974:	cf 5f       	subi	r28, 0xFF	; 255
    4976:	c3 30       	cpi	r28, 0x03	; 3
    4978:	08 f4       	brcc	.+2      	; 0x497c <report_grbl_settings+0x32c>
    497a:	55 c0       	rjmp	.+170    	; 0x4a26 <report_grbl_settings+0x3d6>
    497c:	31 c0       	rjmp	.+98     	; 0x49e0 <report_grbl_settings+0x390>
    497e:	c2 e0       	ldi	r28, 0x02	; 2
    4980:	8c e2       	ldi	r24, 0x2C	; 44
    4982:	94 e0       	ldi	r25, 0x04	; 4
    4984:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4988:	87 e0       	ldi	r24, 0x07	; 7
    498a:	94 e0       	ldi	r25, 0x04	; 4
    498c:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4990:	cf 5f       	subi	r28, 0xFF	; 255
    4992:	c3 30       	cpi	r28, 0x03	; 3
    4994:	08 f4       	brcc	.+2      	; 0x4998 <report_grbl_settings+0x348>
    4996:	54 c0       	rjmp	.+168    	; 0x4a40 <report_grbl_settings+0x3f0>
    4998:	23 c0       	rjmp	.+70     	; 0x49e0 <report_grbl_settings+0x390>
    499a:	c2 e0       	ldi	r28, 0x02	; 2
    499c:	8b e1       	ldi	r24, 0x1B	; 27
    499e:	94 e0       	ldi	r25, 0x04	; 4
    49a0:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    49a4:	87 e0       	ldi	r24, 0x07	; 7
    49a6:	94 e0       	ldi	r25, 0x04	; 4
    49a8:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    49ac:	cf 5f       	subi	r28, 0xFF	; 255
    49ae:	c3 30       	cpi	r28, 0x03	; 3
    49b0:	08 f4       	brcc	.+2      	; 0x49b4 <report_grbl_settings+0x364>
    49b2:	53 c0       	rjmp	.+166    	; 0x4a5a <report_grbl_settings+0x40a>
    49b4:	15 c0       	rjmp	.+42     	; 0x49e0 <report_grbl_settings+0x390>
    49b6:	c2 e0       	ldi	r28, 0x02	; 2
    49b8:	8b e0       	ldi	r24, 0x0B	; 11
    49ba:	94 e0       	ldi	r25, 0x04	; 4
    49bc:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    49c0:	87 e0       	ldi	r24, 0x07	; 7
    49c2:	94 e0       	ldi	r25, 0x04	; 4
    49c4:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    49c8:	cf 5f       	subi	r28, 0xFF	; 255
    49ca:	c3 30       	cpi	r28, 0x03	; 3
    49cc:	f8 f0       	brcs	.+62     	; 0x4a0c <report_grbl_settings+0x3bc>
    49ce:	08 c0       	rjmp	.+16     	; 0x49e0 <report_grbl_settings+0x390>
    49d0:	87 e0       	ldi	r24, 0x07	; 7
    49d2:	94 e0       	ldi	r25, 0x04	; 4
    49d4:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    49d8:	cf 5f       	subi	r28, 0xFF	; 255
    49da:	c3 30       	cpi	r28, 0x03	; 3
    49dc:	08 f4       	brcc	.+2      	; 0x49e0 <report_grbl_settings+0x390>
    49de:	13 cf       	rjmp	.-474    	; 0x4806 <report_grbl_settings+0x1b6>
    49e0:	16 5f       	subi	r17, 0xF6	; 246
    49e2:	df 5f       	subi	r29, 0xFF	; 255
    49e4:	1c 38       	cpi	r17, 0x8C	; 140
    49e6:	09 f4       	brne	.+2      	; 0x49ea <report_grbl_settings+0x39a>
    49e8:	4a c0       	rjmp	.+148    	; 0x4a7e <report_grbl_settings+0x42e>
    49ea:	c0 e0       	ldi	r28, 0x00	; 0
    49ec:	0c cf       	rjmp	.-488    	; 0x4806 <report_grbl_settings+0x1b6>
    49ee:	87 e0       	ldi	r24, 0x07	; 7
    49f0:	94 e0       	ldi	r25, 0x04	; 4
    49f2:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    49f6:	cf 5f       	subi	r28, 0xFF	; 255
    49f8:	06 cf       	rjmp	.-500    	; 0x4806 <report_grbl_settings+0x1b6>
    49fa:	d1 30       	cpi	r29, 0x01	; 1
    49fc:	09 f2       	breq	.-126    	; 0x4980 <report_grbl_settings+0x330>
    49fe:	08 f4       	brcc	.+2      	; 0x4a02 <report_grbl_settings+0x3b2>
    4a00:	b1 cf       	rjmp	.-158    	; 0x4964 <report_grbl_settings+0x314>
    4a02:	d2 30       	cpi	r29, 0x02	; 2
    4a04:	59 f2       	breq	.-106    	; 0x499c <report_grbl_settings+0x34c>
    4a06:	d3 30       	cpi	r29, 0x03	; 3
    4a08:	91 f7       	brne	.-28     	; 0x49ee <report_grbl_settings+0x39e>
    4a0a:	d6 cf       	rjmp	.-84     	; 0x49b8 <report_grbl_settings+0x368>
    4a0c:	83 e5       	ldi	r24, 0x53	; 83
    4a0e:	94 e0       	ldi	r25, 0x04	; 4
    4a10:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4a14:	81 2f       	mov	r24, r17
    4a16:	8c 0f       	add	r24, r28
    4a18:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    4a1c:	81 e5       	ldi	r24, 0x51	; 81
    4a1e:	94 e0       	ldi	r25, 0x04	; 4
    4a20:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4a24:	59 cf       	rjmp	.-334    	; 0x48d8 <report_grbl_settings+0x288>
    4a26:	83 e5       	ldi	r24, 0x53	; 83
    4a28:	94 e0       	ldi	r25, 0x04	; 4
    4a2a:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4a2e:	81 2f       	mov	r24, r17
    4a30:	8c 0f       	add	r24, r28
    4a32:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    4a36:	81 e5       	ldi	r24, 0x51	; 81
    4a38:	94 e0       	ldi	r25, 0x04	; 4
    4a3a:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4a3e:	f8 ce       	rjmp	.-528    	; 0x4830 <report_grbl_settings+0x1e0>
    4a40:	83 e5       	ldi	r24, 0x53	; 83
    4a42:	94 e0       	ldi	r25, 0x04	; 4
    4a44:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4a48:	81 2f       	mov	r24, r17
    4a4a:	8c 0f       	add	r24, r28
    4a4c:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    4a50:	81 e5       	ldi	r24, 0x51	; 81
    4a52:	94 e0       	ldi	r25, 0x04	; 4
    4a54:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4a58:	06 cf       	rjmp	.-500    	; 0x4866 <report_grbl_settings+0x216>
    4a5a:	83 e5       	ldi	r24, 0x53	; 83
    4a5c:	94 e0       	ldi	r25, 0x04	; 4
    4a5e:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4a62:	81 2f       	mov	r24, r17
    4a64:	8c 0f       	add	r24, r28
    4a66:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    4a6a:	81 e5       	ldi	r24, 0x51	; 81
    4a6c:	94 e0       	ldi	r25, 0x04	; 4
    4a6e:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4a72:	14 cf       	rjmp	.-472    	; 0x489c <report_grbl_settings+0x24c>
    4a74:	87 e0       	ldi	r24, 0x07	; 7
    4a76:	94 e0       	ldi	r25, 0x04	; 4
    4a78:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4a7c:	b1 cf       	rjmp	.-158    	; 0x49e0 <report_grbl_settings+0x390>
    4a7e:	df 91       	pop	r29
    4a80:	cf 91       	pop	r28
    4a82:	1f 91       	pop	r17
    4a84:	08 95       	ret

00004a86 <report_probe_parameters>:
    4a86:	cf 93       	push	r28
    4a88:	81 e0       	ldi	r24, 0x01	; 1
    4a8a:	94 e0       	ldi	r25, 0x04	; 4
    4a8c:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4a90:	c0 e0       	ldi	r28, 0x00	; 0
    4a92:	6c 2f       	mov	r22, r28
    4a94:	80 eb       	ldi	r24, 0xB0	; 176
    4a96:	95 e0       	ldi	r25, 0x05	; 5
    4a98:	0e 94 72 38 	call	0x70e4	; 0x70e4 <system_convert_axis_steps_to_mpos>
    4a9c:	0e 94 ea 1f 	call	0x3fd4	; 0x3fd4 <printFloat_CoordValue>
    4aa0:	c2 30       	cpi	r28, 0x02	; 2
    4aa2:	20 f4       	brcc	.+8      	; 0x4aac <report_probe_parameters+0x26>
    4aa4:	8f ef       	ldi	r24, 0xFF	; 255
    4aa6:	93 e0       	ldi	r25, 0x03	; 3
    4aa8:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4aac:	cf 5f       	subi	r28, 0xFF	; 255
    4aae:	c3 30       	cpi	r28, 0x03	; 3
    4ab0:	81 f7       	brne	.-32     	; 0x4a92 <report_probe_parameters+0xc>
    4ab2:	8d ef       	ldi	r24, 0xFD	; 253
    4ab4:	93 e0       	ldi	r25, 0x03	; 3
    4ab6:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4aba:	80 91 bc 05 	lds	r24, 0x05BC	; 0x8005bc <sys+0x1c>
    4abe:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    4ac2:	89 ef       	ldi	r24, 0xF9	; 249
    4ac4:	93 e0       	ldi	r25, 0x03	; 3
    4ac6:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4aca:	cf 91       	pop	r28
    4acc:	08 95       	ret

00004ace <report_ngc_parameters>:
    4ace:	ef 92       	push	r14
    4ad0:	ff 92       	push	r15
    4ad2:	0f 93       	push	r16
    4ad4:	1f 93       	push	r17
    4ad6:	cf 93       	push	r28
    4ad8:	df 93       	push	r29
    4ada:	cd b7       	in	r28, 0x3d	; 61
    4adc:	de b7       	in	r29, 0x3e	; 62
    4ade:	2c 97       	sbiw	r28, 0x0c	; 12
    4ae0:	0f b6       	in	r0, 0x3f	; 63
    4ae2:	f8 94       	cli
    4ae4:	de bf       	out	0x3e, r29	; 62
    4ae6:	0f be       	out	0x3f, r0	; 63
    4ae8:	cd bf       	out	0x3d, r28	; 61
    4aea:	00 e0       	ldi	r16, 0x00	; 0
    4aec:	be 01       	movw	r22, r28
    4aee:	6f 5f       	subi	r22, 0xFF	; 255
    4af0:	7f 4f       	sbci	r23, 0xFF	; 255
    4af2:	80 2f       	mov	r24, r16
    4af4:	0e 94 0a 2a 	call	0x5414	; 0x5414 <settings_read_coord_data>
    4af8:	81 11       	cpse	r24, r1
    4afa:	04 c0       	rjmp	.+8      	; 0x4b04 <report_ngc_parameters+0x36>
    4afc:	87 e0       	ldi	r24, 0x07	; 7
    4afe:	0e 94 3f 22 	call	0x447e	; 0x447e <report_status_message>
    4b02:	6e c0       	rjmp	.+220    	; 0x4be0 <report_ngc_parameters+0x112>
    4b04:	86 ef       	ldi	r24, 0xF6	; 246
    4b06:	93 e0       	ldi	r25, 0x03	; 3
    4b08:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4b0c:	06 30       	cpi	r16, 0x06	; 6
    4b0e:	19 f0       	breq	.+6      	; 0x4b16 <report_ngc_parameters+0x48>
    4b10:	07 30       	cpi	r16, 0x07	; 7
    4b12:	31 f0       	breq	.+12     	; 0x4b20 <report_ngc_parameters+0x52>
    4b14:	0a c0       	rjmp	.+20     	; 0x4b2a <report_ngc_parameters+0x5c>
    4b16:	83 ef       	ldi	r24, 0xF3	; 243
    4b18:	93 e0       	ldi	r25, 0x03	; 3
    4b1a:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4b1e:	09 c0       	rjmp	.+18     	; 0x4b32 <report_ngc_parameters+0x64>
    4b20:	80 ef       	ldi	r24, 0xF0	; 240
    4b22:	93 e0       	ldi	r25, 0x03	; 3
    4b24:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4b28:	04 c0       	rjmp	.+8      	; 0x4b32 <report_ngc_parameters+0x64>
    4b2a:	86 e3       	ldi	r24, 0x36	; 54
    4b2c:	80 0f       	add	r24, r16
    4b2e:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    4b32:	8e ee       	ldi	r24, 0xEE	; 238
    4b34:	93 e0       	ldi	r25, 0x03	; 3
    4b36:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4b3a:	ce 01       	movw	r24, r28
    4b3c:	01 96       	adiw	r24, 0x01	; 1
    4b3e:	7c 01       	movw	r14, r24
    4b40:	10 e0       	ldi	r17, 0x00	; 0
    4b42:	f7 01       	movw	r30, r14
    4b44:	61 91       	ld	r22, Z+
    4b46:	71 91       	ld	r23, Z+
    4b48:	81 91       	ld	r24, Z+
    4b4a:	91 91       	ld	r25, Z+
    4b4c:	7f 01       	movw	r14, r30
    4b4e:	0e 94 ea 1f 	call	0x3fd4	; 0x3fd4 <printFloat_CoordValue>
    4b52:	12 30       	cpi	r17, 0x02	; 2
    4b54:	28 f4       	brcc	.+10     	; 0x4b60 <report_ngc_parameters+0x92>
    4b56:	8c ee       	ldi	r24, 0xEC	; 236
    4b58:	93 e0       	ldi	r25, 0x03	; 3
    4b5a:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4b5e:	04 c0       	rjmp	.+8      	; 0x4b68 <report_ngc_parameters+0x9a>
    4b60:	88 ee       	ldi	r24, 0xE8	; 232
    4b62:	93 e0       	ldi	r25, 0x03	; 3
    4b64:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4b68:	1f 5f       	subi	r17, 0xFF	; 255
    4b6a:	13 30       	cpi	r17, 0x03	; 3
    4b6c:	51 f7       	brne	.-44     	; 0x4b42 <report_ngc_parameters+0x74>
    4b6e:	0f 5f       	subi	r16, 0xFF	; 255
    4b70:	08 30       	cpi	r16, 0x08	; 8
    4b72:	09 f0       	breq	.+2      	; 0x4b76 <report_ngc_parameters+0xa8>
    4b74:	bb cf       	rjmp	.-138    	; 0x4aec <report_ngc_parameters+0x1e>
    4b76:	82 ee       	ldi	r24, 0xE2	; 226
    4b78:	93 e0       	ldi	r25, 0x03	; 3
    4b7a:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4b7e:	0f 2e       	mov	r0, r31
    4b80:	f7 e5       	ldi	r31, 0x57	; 87
    4b82:	ef 2e       	mov	r14, r31
    4b84:	f5 e0       	ldi	r31, 0x05	; 5
    4b86:	ff 2e       	mov	r15, r31
    4b88:	f0 2d       	mov	r31, r0
    4b8a:	10 e0       	ldi	r17, 0x00	; 0
    4b8c:	f7 01       	movw	r30, r14
    4b8e:	61 91       	ld	r22, Z+
    4b90:	71 91       	ld	r23, Z+
    4b92:	81 91       	ld	r24, Z+
    4b94:	91 91       	ld	r25, Z+
    4b96:	7f 01       	movw	r14, r30
    4b98:	0e 94 ea 1f 	call	0x3fd4	; 0x3fd4 <printFloat_CoordValue>
    4b9c:	12 30       	cpi	r17, 0x02	; 2
    4b9e:	28 f4       	brcc	.+10     	; 0x4baa <report_ngc_parameters+0xdc>
    4ba0:	80 ee       	ldi	r24, 0xE0	; 224
    4ba2:	93 e0       	ldi	r25, 0x03	; 3
    4ba4:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4ba8:	04 c0       	rjmp	.+8      	; 0x4bb2 <report_ngc_parameters+0xe4>
    4baa:	8c ed       	ldi	r24, 0xDC	; 220
    4bac:	93 e0       	ldi	r25, 0x03	; 3
    4bae:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4bb2:	1f 5f       	subi	r17, 0xFF	; 255
    4bb4:	13 30       	cpi	r17, 0x03	; 3
    4bb6:	51 f7       	brne	.-44     	; 0x4b8c <report_ngc_parameters+0xbe>
    4bb8:	86 ed       	ldi	r24, 0xD6	; 214
    4bba:	93 e0       	ldi	r25, 0x03	; 3
    4bbc:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4bc0:	60 91 63 05 	lds	r22, 0x0563	; 0x800563 <gc_state+0x3b>
    4bc4:	70 91 64 05 	lds	r23, 0x0564	; 0x800564 <gc_state+0x3c>
    4bc8:	80 91 65 05 	lds	r24, 0x0565	; 0x800565 <gc_state+0x3d>
    4bcc:	90 91 66 05 	lds	r25, 0x0566	; 0x800566 <gc_state+0x3e>
    4bd0:	0e 94 ea 1f 	call	0x3fd4	; 0x3fd4 <printFloat_CoordValue>
    4bd4:	82 ed       	ldi	r24, 0xD2	; 210
    4bd6:	93 e0       	ldi	r25, 0x03	; 3
    4bd8:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4bdc:	0e 94 43 25 	call	0x4a86	; 0x4a86 <report_probe_parameters>
    4be0:	2c 96       	adiw	r28, 0x0c	; 12
    4be2:	0f b6       	in	r0, 0x3f	; 63
    4be4:	f8 94       	cli
    4be6:	de bf       	out	0x3e, r29	; 62
    4be8:	0f be       	out	0x3f, r0	; 63
    4bea:	cd bf       	out	0x3d, r28	; 61
    4bec:	df 91       	pop	r29
    4bee:	cf 91       	pop	r28
    4bf0:	1f 91       	pop	r17
    4bf2:	0f 91       	pop	r16
    4bf4:	ff 90       	pop	r15
    4bf6:	ef 90       	pop	r14
    4bf8:	08 95       	ret

00004bfa <report_gcode_modes>:
    4bfa:	cf 93       	push	r28
    4bfc:	df 93       	push	r29
    4bfe:	80 ed       	ldi	r24, 0xD0	; 208
    4c00:	93 e0       	ldi	r25, 0x03	; 3
    4c02:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4c06:	80 91 28 05 	lds	r24, 0x0528	; 0x800528 <gc_state>
    4c0a:	82 30       	cpi	r24, 0x02	; 2
    4c0c:	a9 f0       	breq	.+42     	; 0x4c38 <report_gcode_modes+0x3e>
    4c0e:	28 f4       	brcc	.+10     	; 0x4c1a <report_gcode_modes+0x20>
    4c10:	88 23       	and	r24, r24
    4c12:	41 f0       	breq	.+16     	; 0x4c24 <report_gcode_modes+0x2a>
    4c14:	81 30       	cpi	r24, 0x01	; 1
    4c16:	59 f0       	breq	.+22     	; 0x4c2e <report_gcode_modes+0x34>
    4c18:	1e c0       	rjmp	.+60     	; 0x4c56 <report_gcode_modes+0x5c>
    4c1a:	83 30       	cpi	r24, 0x03	; 3
    4c1c:	91 f0       	breq	.+36     	; 0x4c42 <report_gcode_modes+0x48>
    4c1e:	88 30       	cpi	r24, 0x08	; 8
    4c20:	a9 f0       	breq	.+42     	; 0x4c4c <report_gcode_modes+0x52>
    4c22:	19 c0       	rjmp	.+50     	; 0x4c56 <report_gcode_modes+0x5c>
    4c24:	8d ec       	ldi	r24, 0xCD	; 205
    4c26:	93 e0       	ldi	r25, 0x03	; 3
    4c28:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4c2c:	1d c0       	rjmp	.+58     	; 0x4c68 <report_gcode_modes+0x6e>
    4c2e:	8a ec       	ldi	r24, 0xCA	; 202
    4c30:	93 e0       	ldi	r25, 0x03	; 3
    4c32:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4c36:	18 c0       	rjmp	.+48     	; 0x4c68 <report_gcode_modes+0x6e>
    4c38:	87 ec       	ldi	r24, 0xC7	; 199
    4c3a:	93 e0       	ldi	r25, 0x03	; 3
    4c3c:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4c40:	13 c0       	rjmp	.+38     	; 0x4c68 <report_gcode_modes+0x6e>
    4c42:	84 ec       	ldi	r24, 0xC4	; 196
    4c44:	93 e0       	ldi	r25, 0x03	; 3
    4c46:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4c4a:	0e c0       	rjmp	.+28     	; 0x4c68 <report_gcode_modes+0x6e>
    4c4c:	80 ec       	ldi	r24, 0xC0	; 192
    4c4e:	93 e0       	ldi	r25, 0x03	; 3
    4c50:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4c54:	09 c0       	rjmp	.+18     	; 0x4c68 <report_gcode_modes+0x6e>
    4c56:	8b eb       	ldi	r24, 0xBB	; 187
    4c58:	93 e0       	ldi	r25, 0x03	; 3
    4c5a:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4c5e:	80 91 28 05 	lds	r24, 0x0528	; 0x800528 <gc_state>
    4c62:	82 50       	subi	r24, 0x02	; 2
    4c64:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    4c68:	88 eb       	ldi	r24, 0xB8	; 184
    4c6a:	93 e0       	ldi	r25, 0x03	; 3
    4c6c:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4c70:	c8 e2       	ldi	r28, 0x28	; 40
    4c72:	d5 e0       	ldi	r29, 0x05	; 5
    4c74:	8e 81       	ldd	r24, Y+6	; 0x06
    4c76:	8a 5c       	subi	r24, 0xCA	; 202
    4c78:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    4c7c:	8c 81       	ldd	r24, Y+4	; 0x04
    4c7e:	81 30       	cpi	r24, 0x01	; 1
    4c80:	49 f0       	breq	.+18     	; 0x4c94 <report_gcode_modes+0x9a>
    4c82:	18 f0       	brcs	.+6      	; 0x4c8a <report_gcode_modes+0x90>
    4c84:	82 30       	cpi	r24, 0x02	; 2
    4c86:	59 f0       	breq	.+22     	; 0x4c9e <report_gcode_modes+0xa4>
    4c88:	0e c0       	rjmp	.+28     	; 0x4ca6 <report_gcode_modes+0xac>
    4c8a:	83 eb       	ldi	r24, 0xB3	; 179
    4c8c:	93 e0       	ldi	r25, 0x03	; 3
    4c8e:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4c92:	09 c0       	rjmp	.+18     	; 0x4ca6 <report_gcode_modes+0xac>
    4c94:	8e ea       	ldi	r24, 0xAE	; 174
    4c96:	93 e0       	ldi	r25, 0x03	; 3
    4c98:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4c9c:	04 c0       	rjmp	.+8      	; 0x4ca6 <report_gcode_modes+0xac>
    4c9e:	89 ea       	ldi	r24, 0xA9	; 169
    4ca0:	93 e0       	ldi	r25, 0x03	; 3
    4ca2:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4ca6:	80 91 2a 05 	lds	r24, 0x052A	; 0x80052a <gc_state+0x2>
    4caa:	81 11       	cpse	r24, r1
    4cac:	05 c0       	rjmp	.+10     	; 0x4cb8 <report_gcode_modes+0xbe>
    4cae:	84 ea       	ldi	r24, 0xA4	; 164
    4cb0:	93 e0       	ldi	r25, 0x03	; 3
    4cb2:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4cb6:	04 c0       	rjmp	.+8      	; 0x4cc0 <report_gcode_modes+0xc6>
    4cb8:	8f e9       	ldi	r24, 0x9F	; 159
    4cba:	93 e0       	ldi	r25, 0x03	; 3
    4cbc:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4cc0:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <gc_state+0x3>
    4cc4:	81 11       	cpse	r24, r1
    4cc6:	05 c0       	rjmp	.+10     	; 0x4cd2 <report_gcode_modes+0xd8>
    4cc8:	8a e9       	ldi	r24, 0x9A	; 154
    4cca:	93 e0       	ldi	r25, 0x03	; 3
    4ccc:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4cd0:	04 c0       	rjmp	.+8      	; 0x4cda <report_gcode_modes+0xe0>
    4cd2:	85 e9       	ldi	r24, 0x95	; 149
    4cd4:	93 e0       	ldi	r25, 0x03	; 3
    4cd6:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4cda:	80 91 29 05 	lds	r24, 0x0529	; 0x800529 <gc_state+0x1>
    4cde:	81 30       	cpi	r24, 0x01	; 1
    4ce0:	29 f4       	brne	.+10     	; 0x4cec <report_gcode_modes+0xf2>
    4ce2:	80 e9       	ldi	r24, 0x90	; 144
    4ce4:	93 e0       	ldi	r25, 0x03	; 3
    4ce6:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4cea:	04 c0       	rjmp	.+8      	; 0x4cf4 <report_gcode_modes+0xfa>
    4cec:	8b e8       	ldi	r24, 0x8B	; 139
    4cee:	93 e0       	ldi	r25, 0x03	; 3
    4cf0:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4cf4:	80 91 2f 05 	lds	r24, 0x052F	; 0x80052f <gc_state+0x7>
    4cf8:	81 30       	cpi	r24, 0x01	; 1
    4cfa:	49 f0       	breq	.+18     	; 0x4d0e <report_gcode_modes+0x114>
    4cfc:	18 f0       	brcs	.+6      	; 0x4d04 <report_gcode_modes+0x10a>
    4cfe:	82 30       	cpi	r24, 0x02	; 2
    4d00:	59 f0       	breq	.+22     	; 0x4d18 <report_gcode_modes+0x11e>
    4d02:	0e c0       	rjmp	.+28     	; 0x4d20 <report_gcode_modes+0x126>
    4d04:	87 e8       	ldi	r24, 0x87	; 135
    4d06:	93 e0       	ldi	r25, 0x03	; 3
    4d08:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4d0c:	09 c0       	rjmp	.+18     	; 0x4d20 <report_gcode_modes+0x126>
    4d0e:	83 e8       	ldi	r24, 0x83	; 131
    4d10:	93 e0       	ldi	r25, 0x03	; 3
    4d12:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4d16:	04 c0       	rjmp	.+8      	; 0x4d20 <report_gcode_modes+0x126>
    4d18:	8f e7       	ldi	r24, 0x7F	; 127
    4d1a:	93 e0       	ldi	r25, 0x03	; 3
    4d1c:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4d20:	80 91 31 05 	lds	r24, 0x0531	; 0x800531 <gc_state+0x9>
    4d24:	81 30       	cpi	r24, 0x01	; 1
    4d26:	21 f0       	breq	.+8      	; 0x4d30 <report_gcode_modes+0x136>
    4d28:	68 f0       	brcs	.+26     	; 0x4d44 <report_gcode_modes+0x14a>
    4d2a:	82 30       	cpi	r24, 0x02	; 2
    4d2c:	31 f0       	breq	.+12     	; 0x4d3a <report_gcode_modes+0x140>
    4d2e:	0e c0       	rjmp	.+28     	; 0x4d4c <report_gcode_modes+0x152>
    4d30:	8b e7       	ldi	r24, 0x7B	; 123
    4d32:	93 e0       	ldi	r25, 0x03	; 3
    4d34:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4d38:	09 c0       	rjmp	.+18     	; 0x4d4c <report_gcode_modes+0x152>
    4d3a:	87 e7       	ldi	r24, 0x77	; 119
    4d3c:	93 e0       	ldi	r25, 0x03	; 3
    4d3e:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4d42:	04 c0       	rjmp	.+8      	; 0x4d4c <report_gcode_modes+0x152>
    4d44:	83 e7       	ldi	r24, 0x73	; 115
    4d46:	93 e0       	ldi	r25, 0x03	; 3
    4d48:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4d4c:	80 91 30 05 	lds	r24, 0x0530	; 0x800530 <gc_state+0x8>
    4d50:	88 23       	and	r24, r24
    4d52:	19 f0       	breq	.+6      	; 0x4d5a <report_gcode_modes+0x160>
    4d54:	82 30       	cpi	r24, 0x02	; 2
    4d56:	31 f0       	breq	.+12     	; 0x4d64 <report_gcode_modes+0x16a>
    4d58:	09 c0       	rjmp	.+18     	; 0x4d6c <report_gcode_modes+0x172>
    4d5a:	8f e6       	ldi	r24, 0x6F	; 111
    4d5c:	93 e0       	ldi	r25, 0x03	; 3
    4d5e:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4d62:	04 c0       	rjmp	.+8      	; 0x4d6c <report_gcode_modes+0x172>
    4d64:	8b e6       	ldi	r24, 0x6B	; 107
    4d66:	93 e0       	ldi	r25, 0x03	; 3
    4d68:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4d6c:	88 e6       	ldi	r24, 0x68	; 104
    4d6e:	93 e0       	ldi	r25, 0x03	; 3
    4d70:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4d74:	c8 e2       	ldi	r28, 0x28	; 40
    4d76:	d5 e0       	ldi	r29, 0x05	; 5
    4d78:	8a 89       	ldd	r24, Y+18	; 0x12
    4d7a:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    4d7e:	85 e6       	ldi	r24, 0x65	; 101
    4d80:	93 e0       	ldi	r25, 0x03	; 3
    4d82:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4d86:	6e 85       	ldd	r22, Y+14	; 0x0e
    4d88:	7f 85       	ldd	r23, Y+15	; 0x0f
    4d8a:	88 89       	ldd	r24, Y+16	; 0x10
    4d8c:	99 89       	ldd	r25, Y+17	; 0x11
    4d8e:	0e 94 fc 1f 	call	0x3ff8	; 0x3ff8 <printFloat_RateValue>
    4d92:	82 e6       	ldi	r24, 0x62	; 98
    4d94:	93 e0       	ldi	r25, 0x03	; 3
    4d96:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4d9a:	6a 85       	ldd	r22, Y+10	; 0x0a
    4d9c:	7b 85       	ldd	r23, Y+11	; 0x0b
    4d9e:	8c 85       	ldd	r24, Y+12	; 0x0c
    4da0:	9d 85       	ldd	r25, Y+13	; 0x0d
    4da2:	0e 94 fc 1f 	call	0x3ff8	; 0x3ff8 <printFloat_RateValue>
    4da6:	8e e5       	ldi	r24, 0x5E	; 94
    4da8:	93 e0       	ldi	r25, 0x03	; 3
    4daa:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4dae:	df 91       	pop	r29
    4db0:	cf 91       	pop	r28
    4db2:	08 95       	ret

00004db4 <report_startup_line>:
    4db4:	1f 93       	push	r17
    4db6:	cf 93       	push	r28
    4db8:	df 93       	push	r29
    4dba:	18 2f       	mov	r17, r24
    4dbc:	eb 01       	movw	r28, r22
    4dbe:	8b e5       	ldi	r24, 0x5B	; 91
    4dc0:	93 e0       	ldi	r25, 0x03	; 3
    4dc2:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4dc6:	81 2f       	mov	r24, r17
    4dc8:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    4dcc:	89 e5       	ldi	r24, 0x59	; 89
    4dce:	93 e0       	ldi	r25, 0x03	; 3
    4dd0:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4dd4:	ce 01       	movw	r24, r28
    4dd6:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printString>
    4dda:	86 e5       	ldi	r24, 0x56	; 86
    4ddc:	93 e0       	ldi	r25, 0x03	; 3
    4dde:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4de2:	df 91       	pop	r29
    4de4:	cf 91       	pop	r28
    4de6:	1f 91       	pop	r17
    4de8:	08 95       	ret

00004dea <report_build_info>:
    4dea:	cf 93       	push	r28
    4dec:	df 93       	push	r29
    4dee:	ec 01       	movw	r28, r24
    4df0:	86 e4       	ldi	r24, 0x46	; 70
    4df2:	93 e0       	ldi	r25, 0x03	; 3
    4df4:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4df8:	ce 01       	movw	r24, r28
    4dfa:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printString>
    4dfe:	82 e4       	ldi	r24, 0x42	; 66
    4e00:	93 e0       	ldi	r25, 0x03	; 3
    4e02:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4e06:	df 91       	pop	r29
    4e08:	cf 91       	pop	r28
    4e0a:	08 95       	ret

00004e0c <report_realtime_status>:
 // and the actual location of the CNC machine. Users may change the following function to their
 // specific needs, but the desired real-time data report must be as short as possible. This is
 // requires as it minimizes the computational overhead and allows grbl to keep running smoothly, 
 // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
void report_realtime_status()
{
    4e0c:	af 92       	push	r10
    4e0e:	bf 92       	push	r11
    4e10:	cf 92       	push	r12
    4e12:	df 92       	push	r13
    4e14:	ff 92       	push	r15
    4e16:	0f 93       	push	r16
    4e18:	1f 93       	push	r17
    4e1a:	cf 93       	push	r28
    4e1c:	df 93       	push	r29
    4e1e:	cd b7       	in	r28, 0x3d	; 61
    4e20:	de b7       	in	r29, 0x3e	; 62
    4e22:	68 97       	sbiw	r28, 0x18	; 24
    4e24:	0f b6       	in	r0, 0x3f	; 63
    4e26:	f8 94       	cli
    4e28:	de bf       	out	0x3e, r29	; 62
    4e2a:	0f be       	out	0x3f, r0	; 63
    4e2c:	cd bf       	out	0x3d, r28	; 61
  // the system power on location (0,0,0) and work coordinate position (G54 and G92 applied). Eventually
  // to be added are distance to go on block, processed block id, and feed rate. Also a settings bitmask
  // for a user to select the desired real-time data.
  uint8_t idx;
  int32_t current_position[N_AXIS]; // Copy current state of the system position variable
  memcpy(current_position,sys.position,sizeof(sys.position));
    4e2e:	8c e0       	ldi	r24, 0x0C	; 12
    4e30:	e4 ea       	ldi	r30, 0xA4	; 164
    4e32:	f5 e0       	ldi	r31, 0x05	; 5
    4e34:	de 01       	movw	r26, r28
    4e36:	11 96       	adiw	r26, 0x01	; 1
    4e38:	01 90       	ld	r0, Z+
    4e3a:	0d 92       	st	X+, r0
    4e3c:	8a 95       	dec	r24
    4e3e:	e1 f7       	brne	.-8      	; 0x4e38 <report_realtime_status+0x2c>
  float print_position[N_AXIS];
 
  // Report current machine state
  switch (sys.state) {
    4e40:	e0 91 a1 05 	lds	r30, 0x05A1	; 0x8005a1 <sys+0x1>
    4e44:	8e 2f       	mov	r24, r30
    4e46:	90 e0       	ldi	r25, 0x00	; 0
    4e48:	81 34       	cpi	r24, 0x41	; 65
    4e4a:	91 05       	cpc	r25, r1
    4e4c:	38 f5       	brcc	.+78     	; 0x4e9c <report_realtime_status+0x90>
    4e4e:	fc 01       	movw	r30, r24
    4e50:	eb 50       	subi	r30, 0x0B	; 11
    4e52:	ff 4f       	sbci	r31, 0xFF	; 255
    4e54:	0c 94 38 3d 	jmp	0x7a70	; 0x7a70 <__tablejump2__>
    case STATE_IDLE: printPgmString(PSTR("<Idle")); break;
    4e58:	8c e3       	ldi	r24, 0x3C	; 60
    4e5a:	93 e0       	ldi	r25, 0x03	; 3
    4e5c:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4e60:	1d c0       	rjmp	.+58     	; 0x4e9c <report_realtime_status+0x90>
    case STATE_MOTION_CANCEL: // Report run state.
    case STATE_CYCLE: printPgmString(PSTR("<Run")); break;
    4e62:	87 e3       	ldi	r24, 0x37	; 55
    4e64:	93 e0       	ldi	r25, 0x03	; 3
    4e66:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4e6a:	18 c0       	rjmp	.+48     	; 0x4e9c <report_realtime_status+0x90>
    case STATE_HOLD: printPgmString(PSTR("<Hold")); break;
    4e6c:	81 e3       	ldi	r24, 0x31	; 49
    4e6e:	93 e0       	ldi	r25, 0x03	; 3
    4e70:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4e74:	13 c0       	rjmp	.+38     	; 0x4e9c <report_realtime_status+0x90>
    case STATE_HOMING: printPgmString(PSTR("<Home")); break;
    4e76:	8b e2       	ldi	r24, 0x2B	; 43
    4e78:	93 e0       	ldi	r25, 0x03	; 3
    4e7a:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4e7e:	0e c0       	rjmp	.+28     	; 0x4e9c <report_realtime_status+0x90>
    case STATE_ALARM: printPgmString(PSTR("<Alarm")); break;
    4e80:	84 e2       	ldi	r24, 0x24	; 36
    4e82:	93 e0       	ldi	r25, 0x03	; 3
    4e84:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4e88:	09 c0       	rjmp	.+18     	; 0x4e9c <report_realtime_status+0x90>
    case STATE_CHECK_MODE: printPgmString(PSTR("<Check")); break;
    4e8a:	8d e1       	ldi	r24, 0x1D	; 29
    4e8c:	93 e0       	ldi	r25, 0x03	; 3
    4e8e:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4e92:	04 c0       	rjmp	.+8      	; 0x4e9c <report_realtime_status+0x90>
    case STATE_SAFETY_DOOR: printPgmString(PSTR("<Door")); break;
    4e94:	87 e1       	ldi	r24, 0x17	; 23
    4e96:	93 e0       	ldi	r25, 0x03	; 3
    4e98:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
  }
 
  // If reporting a position, convert the current step count (current_position) to millimeters.
  if (bit_istrue(settings.status_report_mask,(BITFLAG_RT_STATUS_MACHINE_POSITION | BITFLAG_RT_STATUS_WORK_POSITION))) {
    4e9c:	80 91 b3 06 	lds	r24, 0x06B3	; 0x8006b3 <settings+0x34>
    4ea0:	83 70       	andi	r24, 0x03	; 3
    4ea2:	39 f0       	breq	.+14     	; 0x4eb2 <report_realtime_status+0xa6>
    system_convert_array_steps_to_mpos(print_position,current_position);
    4ea4:	be 01       	movw	r22, r28
    4ea6:	6f 5f       	subi	r22, 0xFF	; 255
    4ea8:	7f 4f       	sbci	r23, 0xFF	; 255
    4eaa:	ce 01       	movw	r24, r28
    4eac:	0d 96       	adiw	r24, 0x0d	; 13
    4eae:	0e 94 8e 38 	call	0x711c	; 0x711c <system_convert_array_steps_to_mpos>
  }
  
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
    4eb2:	80 91 b3 06 	lds	r24, 0x06B3	; 0x8006b3 <settings+0x34>
    4eb6:	80 ff       	sbrs	r24, 0
    4eb8:	1a c0       	rjmp	.+52     	; 0x4eee <report_realtime_status+0xe2>
    printPgmString(PSTR(",MPos:")); 
    4eba:	80 e1       	ldi	r24, 0x10	; 16
    4ebc:	93 e0       	ldi	r25, 0x03	; 3
    4ebe:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4ec2:	6e 01       	movw	r12, r28
    4ec4:	2d e0       	ldi	r18, 0x0D	; 13
    4ec6:	c2 0e       	add	r12, r18
    4ec8:	d1 1c       	adc	r13, r1
    for (idx=0; idx< N_AXIS; idx++) {
    4eca:	10 e0       	ldi	r17, 0x00	; 0
      printFloat_CoordValue(print_position[idx]);
    4ecc:	f6 01       	movw	r30, r12
    4ece:	61 91       	ld	r22, Z+
    4ed0:	71 91       	ld	r23, Z+
    4ed2:	81 91       	ld	r24, Z+
    4ed4:	91 91       	ld	r25, Z+
    4ed6:	6f 01       	movw	r12, r30
    4ed8:	0e 94 ea 1f 	call	0x3fd4	; 0x3fd4 <printFloat_CoordValue>
      if (idx < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    4edc:	12 30       	cpi	r17, 0x02	; 2
    4ede:	20 f4       	brcc	.+8      	; 0x4ee8 <report_realtime_status+0xdc>
    4ee0:	8e e0       	ldi	r24, 0x0E	; 14
    4ee2:	93 e0       	ldi	r25, 0x03	; 3
    4ee4:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
  }
  
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
    printPgmString(PSTR(",MPos:")); 
    for (idx=0; idx< N_AXIS; idx++) {
    4ee8:	1f 5f       	subi	r17, 0xFF	; 255
    4eea:	13 30       	cpi	r17, 0x03	; 3
    4eec:	79 f7       	brne	.-34     	; 0x4ecc <report_realtime_status+0xc0>
      if (idx < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    }
  }
  
  // Report work position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_WORK_POSITION)) {
    4eee:	80 91 b3 06 	lds	r24, 0x06B3	; 0x8006b3 <settings+0x34>
    4ef2:	81 ff       	sbrs	r24, 1
    4ef4:	4c c0       	rjmp	.+152    	; 0x4f8e <report_realtime_status+0x182>
    printPgmString(PSTR(",WPos:")); 
    4ef6:	87 e0       	ldi	r24, 0x07	; 7
    4ef8:	93 e0       	ldi	r25, 0x03	; 3
    4efa:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    4efe:	8e 01       	movw	r16, r28
    4f00:	03 5f       	subi	r16, 0xF3	; 243
    4f02:	1f 4f       	sbci	r17, 0xFF	; 255
    4f04:	0f 2e       	mov	r0, r31
    4f06:	fb e4       	ldi	r31, 0x4B	; 75
    4f08:	cf 2e       	mov	r12, r31
    4f0a:	f5 e0       	ldi	r31, 0x05	; 5
    4f0c:	df 2e       	mov	r13, r31
    4f0e:	f0 2d       	mov	r31, r0
    for (idx=0; idx< N_AXIS; idx++) {
    4f10:	f1 2c       	mov	r15, r1
      // Apply work coordinate offsets and tool length offset to current position.
      print_position[idx] -= gc_state.coord_system[idx]+gc_state.coord_offset[idx];
    4f12:	f6 01       	movw	r30, r12
    4f14:	61 91       	ld	r22, Z+
    4f16:	71 91       	ld	r23, Z+
    4f18:	81 91       	ld	r24, Z+
    4f1a:	91 91       	ld	r25, Z+
    4f1c:	6f 01       	movw	r12, r30
    4f1e:	20 85       	ldd	r18, Z+8	; 0x08
    4f20:	31 85       	ldd	r19, Z+9	; 0x09
    4f22:	42 85       	ldd	r20, Z+10	; 0x0a
    4f24:	53 85       	ldd	r21, Z+11	; 0x0b
    4f26:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    4f2a:	9b 01       	movw	r18, r22
    4f2c:	ac 01       	movw	r20, r24
    4f2e:	f8 01       	movw	r30, r16
    4f30:	60 81       	ld	r22, Z
    4f32:	71 81       	ldd	r23, Z+1	; 0x01
    4f34:	82 81       	ldd	r24, Z+2	; 0x02
    4f36:	93 81       	ldd	r25, Z+3	; 0x03
    4f38:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    4f3c:	f8 01       	movw	r30, r16
    4f3e:	60 83       	st	Z, r22
    4f40:	71 83       	std	Z+1, r23	; 0x01
    4f42:	82 83       	std	Z+2, r24	; 0x02
    4f44:	93 83       	std	Z+3, r25	; 0x03
      if (idx == TOOL_LENGTH_OFFSET_AXIS) { print_position[idx] -= gc_state.tool_length_offset; }    
    4f46:	f2 e0       	ldi	r31, 0x02	; 2
    4f48:	ff 12       	cpse	r15, r31
    4f4a:	12 c0       	rjmp	.+36     	; 0x4f70 <report_realtime_status+0x164>
    4f4c:	20 91 63 05 	lds	r18, 0x0563	; 0x800563 <gc_state+0x3b>
    4f50:	30 91 64 05 	lds	r19, 0x0564	; 0x800564 <gc_state+0x3c>
    4f54:	40 91 65 05 	lds	r20, 0x0565	; 0x800565 <gc_state+0x3d>
    4f58:	50 91 66 05 	lds	r21, 0x0566	; 0x800566 <gc_state+0x3e>
    4f5c:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    4f60:	f8 01       	movw	r30, r16
    4f62:	60 83       	st	Z, r22
    4f64:	71 83       	std	Z+1, r23	; 0x01
    4f66:	82 83       	std	Z+2, r24	; 0x02
    4f68:	93 83       	std	Z+3, r25	; 0x03
      printFloat_CoordValue(print_position[idx]);
    4f6a:	0e 94 ea 1f 	call	0x3fd4	; 0x3fd4 <printFloat_CoordValue>
    4f6e:	0f c0       	rjmp	.+30     	; 0x4f8e <report_realtime_status+0x182>
    4f70:	0e 94 ea 1f 	call	0x3fd4	; 0x3fd4 <printFloat_CoordValue>
      if (idx < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    4f74:	f1 e0       	ldi	r31, 0x01	; 1
    4f76:	ff 15       	cp	r31, r15
    4f78:	20 f0       	brcs	.+8      	; 0x4f82 <report_realtime_status+0x176>
    4f7a:	85 e0       	ldi	r24, 0x05	; 5
    4f7c:	93 e0       	ldi	r25, 0x03	; 3
    4f7e:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
  }
  
  // Report work position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_WORK_POSITION)) {
    printPgmString(PSTR(",WPos:")); 
    for (idx=0; idx< N_AXIS; idx++) {
    4f82:	f3 94       	inc	r15
    4f84:	0c 5f       	subi	r16, 0xFC	; 252
    4f86:	1f 4f       	sbci	r17, 0xFF	; 255
    4f88:	23 e0       	ldi	r18, 0x03	; 3
    4f8a:	f2 12       	cpse	r15, r18
    4f8c:	c2 cf       	rjmp	.-124    	; 0x4f12 <report_realtime_status+0x106>
      if (idx < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    }
  }
        
  // Returns the number of active blocks are in the planner buffer.
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_PLANNER_BUFFER)) {
    4f8e:	80 91 b3 06 	lds	r24, 0x06B3	; 0x8006b3 <settings+0x34>
    4f92:	82 ff       	sbrs	r24, 2
    4f94:	08 c0       	rjmp	.+16     	; 0x4fa6 <report_realtime_status+0x19a>
    printPgmString(PSTR(",Buf:"));
    4f96:	8f ef       	ldi	r24, 0xFF	; 255
    4f98:	92 e0       	ldi	r25, 0x02	; 2
    4f9a:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    print_uint8_base10(plan_get_block_buffer_count());
    4f9e:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <plan_get_block_buffer_count>
    4fa2:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
  }

  // Report serial read buffer status
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_SERIAL_RX)) {
    4fa6:	80 91 b3 06 	lds	r24, 0x06B3	; 0x8006b3 <settings+0x34>
    4faa:	83 ff       	sbrs	r24, 3
    4fac:	08 c0       	rjmp	.+16     	; 0x4fbe <report_realtime_status+0x1b2>
    printPgmString(PSTR(",RX:"));
    4fae:	8a ef       	ldi	r24, 0xFA	; 250
    4fb0:	92 e0       	ldi	r25, 0x02	; 2
    4fb2:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    print_uint8_base10(serial_get_rx_buffer_count());
    4fb6:	0e 94 01 28 	call	0x5002	; 0x5002 <serial_get_rx_buffer_count>
    4fba:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <print_uint8_base10>
    // Report realtime rate 
    printPgmString(PSTR(",F:")); 
    printFloat_RateValue(st_get_realtime_rate());
  #endif    
  
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_LIMIT_PINS)) {
    4fbe:	80 91 b3 06 	lds	r24, 0x06B3	; 0x8006b3 <settings+0x34>
    4fc2:	84 ff       	sbrs	r24, 4
    4fc4:	0a c0       	rjmp	.+20     	; 0x4fda <report_realtime_status+0x1ce>
    printPgmString(PSTR(",Lim:"));
    4fc6:	84 ef       	ldi	r24, 0xF4	; 244
    4fc8:	92 e0       	ldi	r25, 0x02	; 2
    4fca:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
    print_unsigned_int8(limits_get_state(),2,N_AXIS);
    4fce:	0e 94 1e 11 	call	0x223c	; 0x223c <limits_get_state>
    4fd2:	43 e0       	ldi	r20, 0x03	; 3
    4fd4:	62 e0       	ldi	r22, 0x02	; 2
    4fd6:	0e 94 dd 1e 	call	0x3dba	; 0x3dba <print_unsigned_int8>
  #ifdef REPORT_CONTROL_PIN_STATE 
    printPgmString(PSTR(",Ctl:"));
    print_uint8_base2(CONTROL_PIN & CONTROL_MASK);
  #endif
  
  printPgmString(PSTR(">\r\n"));
    4fda:	80 ef       	ldi	r24, 0xF0	; 240
    4fdc:	92 e0       	ldi	r25, 0x02	; 2
    4fde:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <printPgmString>
}
    4fe2:	68 96       	adiw	r28, 0x18	; 24
    4fe4:	0f b6       	in	r0, 0x3f	; 63
    4fe6:	f8 94       	cli
    4fe8:	de bf       	out	0x3e, r29	; 62
    4fea:	0f be       	out	0x3f, r0	; 63
    4fec:	cd bf       	out	0x3d, r28	; 61
    4fee:	df 91       	pop	r29
    4ff0:	cf 91       	pop	r28
    4ff2:	1f 91       	pop	r17
    4ff4:	0f 91       	pop	r16
    4ff6:	ff 90       	pop	r15
    4ff8:	df 90       	pop	r13
    4ffa:	cf 90       	pop	r12
    4ffc:	bf 90       	pop	r11
    4ffe:	af 90       	pop	r10
    5000:	08 95       	ret

00005002 <serial_get_rx_buffer_count>:
uint8_t serial_get_tx_buffer_count()
{
  uint8_t ttail = serial_tx_buffer_tail; // Copy to limit multiple calls to volatile
  if (serial_tx_buffer_head >= ttail) { return(serial_tx_buffer_head-ttail); }
  return (TX_BUFFER_SIZE - (ttail-serial_tx_buffer_head));
}
    5002:	90 91 54 04 	lds	r25, 0x0454	; 0x800454 <serial_rx_buffer_tail>
    5006:	80 91 55 04 	lds	r24, 0x0455	; 0x800455 <serial_rx_buffer_head>
    500a:	89 17       	cp	r24, r25
    500c:	10 f0       	brcs	.+4      	; 0x5012 <serial_get_rx_buffer_count+0x10>
    500e:	89 1b       	sub	r24, r25
    5010:	08 95       	ret
    5012:	80 58       	subi	r24, 0x80	; 128
    5014:	89 1b       	sub	r24, r25
    5016:	08 95       	ret

00005018 <serial_init>:
  #if BAUD_RATE < 57600
    uint16_t UBRR0_value = ((F_CPU / (8L * BAUD_RATE)) - 1)/2 ;
    UCSR0A &= ~(1 << U2X0); // baud doubler off  - Only needed on Uno XXX
  #else
    uint16_t UBRR0_value = ((F_CPU / (4L * BAUD_RATE)) - 1)/2;
    UCSR0A |= (1 << U2X0);  // baud doubler on for high baud rates, i.e. 115200
    5018:	e0 ec       	ldi	r30, 0xC0	; 192
    501a:	f0 e0       	ldi	r31, 0x00	; 0
    501c:	80 81       	ld	r24, Z
    501e:	82 60       	ori	r24, 0x02	; 2
    5020:	80 83       	st	Z, r24
  #endif
  UBRR0H = UBRR0_value >> 8;
    5022:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
  UBRR0L = UBRR0_value;
    5026:	80 e1       	ldi	r24, 0x10	; 16
    5028:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
            
  // enable rx and tx
  UCSR0B |= 1<<RXEN0;
    502c:	e1 ec       	ldi	r30, 0xC1	; 193
    502e:	f0 e0       	ldi	r31, 0x00	; 0
    5030:	80 81       	ld	r24, Z
    5032:	80 61       	ori	r24, 0x10	; 16
    5034:	80 83       	st	Z, r24
  UCSR0B |= 1<<TXEN0;
    5036:	80 81       	ld	r24, Z
    5038:	88 60       	ori	r24, 0x08	; 8
    503a:	80 83       	st	Z, r24
	
  // enable interrupt on complete reception of a byte
  UCSR0B |= 1<<RXCIE0;
    503c:	80 81       	ld	r24, Z
    503e:	80 68       	ori	r24, 0x80	; 128
    5040:	80 83       	st	Z, r24
    5042:	08 95       	ret

00005044 <serial_write>:

// Writes one byte to the TX serial buffer. Called by main program.
// TODO: Check if we can speed this up for writing strings, rather than single bytes.
void serial_write(uint8_t data) {
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
    5044:	e0 91 53 04 	lds	r30, 0x0453	; 0x800453 <serial_tx_buffer_head>
    5048:	21 e0       	ldi	r18, 0x01	; 1
    504a:	2e 0f       	add	r18, r30
  if (next_head == TX_BUFFER_SIZE) { next_head = 0; }
    504c:	20 34       	cpi	r18, 0x40	; 64
    504e:	31 f4       	brne	.+12     	; 0x505c <serial_write+0x18>
    5050:	20 e0       	ldi	r18, 0x00	; 0
    5052:	04 c0       	rjmp	.+8      	; 0x505c <serial_write+0x18>

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) { 
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.    
    if (sys_rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
    5054:	90 91 25 05 	lds	r25, 0x0525	; 0x800525 <sys_rt_exec_state>
    5058:	94 fd       	sbrc	r25, 4
    505a:	0f c0       	rjmp	.+30     	; 0x507a <serial_write+0x36>
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
  if (next_head == TX_BUFFER_SIZE) { next_head = 0; }

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) { 
    505c:	90 91 52 04 	lds	r25, 0x0452	; 0x800452 <serial_tx_buffer_tail>
    5060:	92 17       	cp	r25, r18
    5062:	c1 f3       	breq	.-16     	; 0x5054 <serial_write+0x10>
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.    
    if (sys_rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
  }

  // Store data and advance head
  serial_tx_buffer[serial_tx_buffer_head] = data;
    5064:	f0 e0       	ldi	r31, 0x00	; 0
    5066:	e1 54       	subi	r30, 0x41	; 65
    5068:	fa 4f       	sbci	r31, 0xFA	; 250
    506a:	80 83       	st	Z, r24
  serial_tx_buffer_head = next_head;
    506c:	20 93 53 04 	sts	0x0453, r18	; 0x800453 <serial_tx_buffer_head>
  
  // Enable Data Register Empty Interrupt to make sure tx-streaming is running
  UCSR0B |=  (1 << UDRIE0); 
    5070:	e1 ec       	ldi	r30, 0xC1	; 193
    5072:	f0 e0       	ldi	r31, 0x00	; 0
    5074:	80 81       	ld	r24, Z
    5076:	80 62       	ori	r24, 0x20	; 32
    5078:	80 83       	st	Z, r24
    507a:	08 95       	ret

0000507c <__vector_19>:
}


// Data Register Empty Interrupt handler
ISR(SERIAL_UDRE)
{
    507c:	1f 92       	push	r1
    507e:	0f 92       	push	r0
    5080:	0f b6       	in	r0, 0x3f	; 63
    5082:	0f 92       	push	r0
    5084:	11 24       	eor	r1, r1
    5086:	8f 93       	push	r24
    5088:	9f 93       	push	r25
    508a:	ef 93       	push	r30
    508c:	ff 93       	push	r31
  uint8_t tail = serial_tx_buffer_tail; // Temporary serial_tx_buffer_tail (to optimize for volatile)
    508e:	80 91 52 04 	lds	r24, 0x0452	; 0x800452 <serial_tx_buffer_tail>
      flow_ctrl = XON_SENT; 
    } else
  #endif
  { 
    // Send a byte from the buffer	
    UDR0 = serial_tx_buffer[tail];
    5092:	e8 2f       	mov	r30, r24
    5094:	f0 e0       	ldi	r31, 0x00	; 0
    5096:	e1 54       	subi	r30, 0x41	; 65
    5098:	fa 4f       	sbci	r31, 0xFA	; 250
    509a:	90 81       	ld	r25, Z
    509c:	90 93 c6 00 	sts	0x00C6, r25	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
  
    // Update tail position
    tail++;
    50a0:	8f 5f       	subi	r24, 0xFF	; 255
    if (tail == TX_BUFFER_SIZE) { tail = 0; }
    50a2:	80 34       	cpi	r24, 0x40	; 64
    50a4:	09 f4       	brne	.+2      	; 0x50a8 <__vector_19+0x2c>
    50a6:	80 e0       	ldi	r24, 0x00	; 0
  
    serial_tx_buffer_tail = tail;
    50a8:	80 93 52 04 	sts	0x0452, r24	; 0x800452 <serial_tx_buffer_tail>
  }
  
  // Turn off Data Register Empty Interrupt to stop tx-streaming if this concludes the transfer
  if (tail == serial_tx_buffer_head) { UCSR0B &= ~(1 << UDRIE0); }
    50ac:	90 91 53 04 	lds	r25, 0x0453	; 0x800453 <serial_tx_buffer_head>
    50b0:	89 13       	cpse	r24, r25
    50b2:	05 c0       	rjmp	.+10     	; 0x50be <__vector_19+0x42>
    50b4:	e1 ec       	ldi	r30, 0xC1	; 193
    50b6:	f0 e0       	ldi	r31, 0x00	; 0
    50b8:	80 81       	ld	r24, Z
    50ba:	8f 7d       	andi	r24, 0xDF	; 223
    50bc:	80 83       	st	Z, r24
}
    50be:	ff 91       	pop	r31
    50c0:	ef 91       	pop	r30
    50c2:	9f 91       	pop	r25
    50c4:	8f 91       	pop	r24
    50c6:	0f 90       	pop	r0
    50c8:	0f be       	out	0x3f, r0	; 63
    50ca:	0f 90       	pop	r0
    50cc:	1f 90       	pop	r1
    50ce:	18 95       	reti

000050d0 <serial_read>:


// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
    50d0:	90 91 54 04 	lds	r25, 0x0454	; 0x800454 <serial_rx_buffer_tail>
  if (serial_rx_buffer_head == tail) {
    50d4:	80 91 55 04 	lds	r24, 0x0455	; 0x800455 <serial_rx_buffer_head>
    50d8:	98 17       	cp	r25, r24
    50da:	61 f0       	breq	.+24     	; 0x50f4 <serial_read+0x24>
    return SERIAL_NO_DATA;
  } else {
    uint8_t data = serial_rx_buffer[tail];
    50dc:	e9 2f       	mov	r30, r25
    50de:	f0 e0       	ldi	r31, 0x00	; 0
    50e0:	e1 50       	subi	r30, 0x01	; 1
    50e2:	fa 4f       	sbci	r31, 0xFA	; 250
    50e4:	80 81       	ld	r24, Z
    
    tail++;
    50e6:	9f 5f       	subi	r25, 0xFF	; 255
    if (tail == RX_BUFFER_SIZE) { tail = 0; }
    50e8:	90 38       	cpi	r25, 0x80	; 128
    50ea:	09 f4       	brne	.+2      	; 0x50ee <serial_read+0x1e>
    50ec:	90 e0       	ldi	r25, 0x00	; 0
    serial_rx_buffer_tail = tail;
    50ee:	90 93 54 04 	sts	0x0454, r25	; 0x800454 <serial_rx_buffer_tail>
        flow_ctrl = SEND_XON;
        UCSR0B |=  (1 << UDRIE0); // Force TX
      }
    #endif
    
    return data;
    50f2:	08 95       	ret
// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
  if (serial_rx_buffer_head == tail) {
    return SERIAL_NO_DATA;
    50f4:	8f ef       	ldi	r24, 0xFF	; 255
      }
    #endif
    
    return data;
  }
}
    50f6:	08 95       	ret

000050f8 <__vector_18>:


ISR(SERIAL_RX)
{
    50f8:	1f 92       	push	r1
    50fa:	0f 92       	push	r0
    50fc:	0f b6       	in	r0, 0x3f	; 63
    50fe:	0f 92       	push	r0
    5100:	11 24       	eor	r1, r1
    5102:	2f 93       	push	r18
    5104:	3f 93       	push	r19
    5106:	4f 93       	push	r20
    5108:	5f 93       	push	r21
    510a:	6f 93       	push	r22
    510c:	7f 93       	push	r23
    510e:	8f 93       	push	r24
    5110:	9f 93       	push	r25
    5112:	af 93       	push	r26
    5114:	bf 93       	push	r27
    5116:	ef 93       	push	r30
    5118:	ff 93       	push	r31
  uint8_t data = UDR0;
    511a:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
  uint8_t next_head;
  
  // Pick off realtime command characters directly from the serial stream. These characters are
  // not passed into the buffer, but these set system state flag bits for realtime execution.
  switch (data) {
    511e:	8f 33       	cpi	r24, 0x3F	; 63
    5120:	59 f0       	breq	.+22     	; 0x5138 <__vector_18+0x40>
    5122:	28 f4       	brcc	.+10     	; 0x512e <__vector_18+0x36>
    5124:	88 31       	cpi	r24, 0x18	; 24
    5126:	61 f1       	breq	.+88     	; 0x5180 <__vector_18+0x88>
    5128:	81 32       	cpi	r24, 0x21	; 33
    512a:	c1 f0       	breq	.+48     	; 0x515c <__vector_18+0x64>
    512c:	2c c0       	rjmp	.+88     	; 0x5186 <__vector_18+0x8e>
    512e:	80 34       	cpi	r24, 0x40	; 64
    5130:	f1 f0       	breq	.+60     	; 0x516e <__vector_18+0x76>
    5132:	8e 37       	cpi	r24, 0x7E	; 126
    5134:	51 f0       	breq	.+20     	; 0x514a <__vector_18+0x52>
    5136:	27 c0       	rjmp	.+78     	; 0x5186 <__vector_18+0x8e>
    case CMD_STATUS_REPORT: bit_true_atomic(sys_rt_exec_state, EXEC_STATUS_REPORT); break; // Set as true
    5138:	9f b7       	in	r25, 0x3f	; 63
    513a:	f8 94       	cli
    513c:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    5140:	81 60       	ori	r24, 0x01	; 1
    5142:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <sys_rt_exec_state>
    5146:	9f bf       	out	0x3f, r25	; 63
    5148:	2f c0       	rjmp	.+94     	; 0x51a8 <__vector_18+0xb0>
    case CMD_CYCLE_START:   bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START); break; // Set as true
    514a:	9f b7       	in	r25, 0x3f	; 63
    514c:	f8 94       	cli
    514e:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    5152:	82 60       	ori	r24, 0x02	; 2
    5154:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <sys_rt_exec_state>
    5158:	9f bf       	out	0x3f, r25	; 63
    515a:	26 c0       	rjmp	.+76     	; 0x51a8 <__vector_18+0xb0>
    case CMD_FEED_HOLD:     bit_true_atomic(sys_rt_exec_state, EXEC_FEED_HOLD); break; // Set as true
    515c:	9f b7       	in	r25, 0x3f	; 63
    515e:	f8 94       	cli
    5160:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    5164:	88 60       	ori	r24, 0x08	; 8
    5166:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <sys_rt_exec_state>
    516a:	9f bf       	out	0x3f, r25	; 63
    516c:	1d c0       	rjmp	.+58     	; 0x51a8 <__vector_18+0xb0>
    case CMD_SAFETY_DOOR:   bit_true_atomic(sys_rt_exec_state, EXEC_SAFETY_DOOR); break; // Set as true
    516e:	9f b7       	in	r25, 0x3f	; 63
    5170:	f8 94       	cli
    5172:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    5176:	80 62       	ori	r24, 0x20	; 32
    5178:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <sys_rt_exec_state>
    517c:	9f bf       	out	0x3f, r25	; 63
    517e:	14 c0       	rjmp	.+40     	; 0x51a8 <__vector_18+0xb0>
    case CMD_RESET:         mc_reset(); break; // Call motion control reset routine.
    5180:	0e 94 36 18 	call	0x306c	; 0x306c <mc_reset>
    5184:	11 c0       	rjmp	.+34     	; 0x51a8 <__vector_18+0xb0>
    default: // Write character to buffer    
      next_head = serial_rx_buffer_head + 1;
    5186:	e0 91 55 04 	lds	r30, 0x0455	; 0x800455 <serial_rx_buffer_head>
    518a:	91 e0       	ldi	r25, 0x01	; 1
    518c:	9e 0f       	add	r25, r30
      if (next_head == RX_BUFFER_SIZE) { next_head = 0; }
    518e:	90 38       	cpi	r25, 0x80	; 128
    5190:	09 f4       	brne	.+2      	; 0x5194 <__vector_18+0x9c>
    5192:	90 e0       	ldi	r25, 0x00	; 0
    
      // Write data to buffer unless it is full.
      if (next_head != serial_rx_buffer_tail) {
    5194:	20 91 54 04 	lds	r18, 0x0454	; 0x800454 <serial_rx_buffer_tail>
    5198:	92 17       	cp	r25, r18
    519a:	31 f0       	breq	.+12     	; 0x51a8 <__vector_18+0xb0>
        serial_rx_buffer[serial_rx_buffer_head] = data;
    519c:	f0 e0       	ldi	r31, 0x00	; 0
    519e:	e1 50       	subi	r30, 0x01	; 1
    51a0:	fa 4f       	sbci	r31, 0xFA	; 250
    51a2:	80 83       	st	Z, r24
        serial_rx_buffer_head = next_head;    
    51a4:	90 93 55 04 	sts	0x0455, r25	; 0x800455 <serial_rx_buffer_head>
        #endif
        
      }
      //TODO: else alarm on overflow?
  }
}
    51a8:	ff 91       	pop	r31
    51aa:	ef 91       	pop	r30
    51ac:	bf 91       	pop	r27
    51ae:	af 91       	pop	r26
    51b0:	9f 91       	pop	r25
    51b2:	8f 91       	pop	r24
    51b4:	7f 91       	pop	r23
    51b6:	6f 91       	pop	r22
    51b8:	5f 91       	pop	r21
    51ba:	4f 91       	pop	r20
    51bc:	3f 91       	pop	r19
    51be:	2f 91       	pop	r18
    51c0:	0f 90       	pop	r0
    51c2:	0f be       	out	0x3f, r0	; 63
    51c4:	0f 90       	pop	r0
    51c6:	1f 90       	pop	r1
    51c8:	18 95       	reti

000051ca <serial_reset_read_buffer>:


void serial_reset_read_buffer() 
{
  serial_rx_buffer_tail = serial_rx_buffer_head;
    51ca:	80 91 55 04 	lds	r24, 0x0455	; 0x800455 <serial_rx_buffer_head>
    51ce:	80 93 54 04 	sts	0x0454, r24	; 0x800454 <serial_rx_buffer_tail>
    51d2:	08 95       	ret

000051d4 <settings_store_startup_line>:

// Method to store startup lines into EEPROM
void settings_store_startup_line(uint8_t n, char *line)
{
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
  memcpy_to_eeprom_with_checksum(addr,(char*)line, LINE_BUFFER_SIZE);
    51d4:	21 e5       	ldi	r18, 0x51	; 81
    51d6:	82 9f       	mul	r24, r18
    51d8:	c0 01       	movw	r24, r0
    51da:	11 24       	eor	r1, r1
    51dc:	40 e5       	ldi	r20, 0x50	; 80
    51de:	50 e0       	ldi	r21, 0x00	; 0
    51e0:	9d 5f       	subi	r25, 0xFD	; 253
    51e2:	0e 94 3a 05 	call	0xa74	; 0xa74 <memcpy_to_eeprom_with_checksum>
    51e6:	08 95       	ret

000051e8 <settings_store_build_info>:


// Method to store build info into EEPROM
void settings_store_build_info(char *line)
{
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_BUILD_INFO,(char*)line, LINE_BUFFER_SIZE);
    51e8:	40 e5       	ldi	r20, 0x50	; 80
    51ea:	50 e0       	ldi	r21, 0x00	; 0
    51ec:	bc 01       	movw	r22, r24
    51ee:	8e ea       	ldi	r24, 0xAE	; 174
    51f0:	93 e0       	ldi	r25, 0x03	; 3
    51f2:	0e 94 3a 05 	call	0xa74	; 0xa74 <memcpy_to_eeprom_with_checksum>
    51f6:	08 95       	ret

000051f8 <settings_write_coord_data>:

// Method to store coord data parameters into EEPROM
void settings_write_coord_data(uint8_t coord_select, float *coord_data)
{  
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
  memcpy_to_eeprom_with_checksum(addr,(char*)coord_data, sizeof(float)*N_AXIS);
    51f8:	2d e0       	ldi	r18, 0x0D	; 13
    51fa:	82 9f       	mul	r24, r18
    51fc:	c0 01       	movw	r24, r0
    51fe:	11 24       	eor	r1, r1
    5200:	4c e0       	ldi	r20, 0x0C	; 12
    5202:	50 e0       	ldi	r21, 0x00	; 0
    5204:	9e 5f       	subi	r25, 0xFE	; 254
    5206:	0e 94 3a 05 	call	0xa74	; 0xa74 <memcpy_to_eeprom_with_checksum>
    520a:	08 95       	ret

0000520c <write_global_settings>:


// Method to store Grbl global settings struct and version number into EEPROM
void write_global_settings() 
{
  eeprom_put_char(0, SETTINGS_VERSION);
    520c:	69 e0       	ldi	r22, 0x09	; 9
    520e:	80 e0       	ldi	r24, 0x00	; 0
    5210:	90 e0       	ldi	r25, 0x00	; 0
    5212:	0e 94 1b 05 	call	0xa36	; 0xa36 <eeprom_put_char>
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_GLOBAL, (char*)&settings, sizeof(settings_t));
    5216:	4d e4       	ldi	r20, 0x4D	; 77
    5218:	50 e0       	ldi	r21, 0x00	; 0
    521a:	6f e7       	ldi	r22, 0x7F	; 127
    521c:	76 e0       	ldi	r23, 0x06	; 6
    521e:	81 e0       	ldi	r24, 0x01	; 1
    5220:	90 e0       	ldi	r25, 0x00	; 0
    5222:	0e 94 3a 05 	call	0xa74	; 0xa74 <memcpy_to_eeprom_with_checksum>
    5226:	08 95       	ret

00005228 <settings_restore>:
}


// Method to restore EEPROM-saved Grbl global settings back to defaults. 
void settings_restore(uint8_t restore_flag) {  
    5228:	0f 93       	push	r16
    522a:	1f 93       	push	r17
    522c:	cf 93       	push	r28
    522e:	df 93       	push	r29
    5230:	cd b7       	in	r28, 0x3d	; 61
    5232:	de b7       	in	r29, 0x3e	; 62
    5234:	2c 97       	sbiw	r28, 0x0c	; 12
    5236:	0f b6       	in	r0, 0x3f	; 63
    5238:	f8 94       	cli
    523a:	de bf       	out	0x3e, r29	; 62
    523c:	0f be       	out	0x3f, r0	; 63
    523e:	cd bf       	out	0x3d, r28	; 61
    5240:	08 2f       	mov	r16, r24
  if (restore_flag & SETTINGS_RESTORE_DEFAULTS) {
    5242:	80 ff       	sbrs	r24, 0
    5244:	84 c0       	rjmp	.+264    	; 0x534e <settings_restore+0x126>
	settings.pulse_microseconds = DEFAULT_STEP_PULSE_MICROSECONDS;
    5246:	ef e7       	ldi	r30, 0x7F	; 127
    5248:	f6 e0       	ldi	r31, 0x06	; 6
    524a:	8a e0       	ldi	r24, 0x0A	; 10
    524c:	80 ab       	std	Z+48, r24	; 0x30
	settings.stepper_idle_lock_time = DEFAULT_STEPPER_IDLE_LOCK_TIME;
    524e:	89 e1       	ldi	r24, 0x19	; 25
    5250:	83 ab       	std	Z+51, r24	; 0x33
	settings.step_invert_mask = DEFAULT_STEPPING_INVERT_MASK;
    5252:	11 aa       	std	Z+49, r1	; 0x31
	settings.dir_invert_mask = DEFAULT_DIRECTION_INVERT_MASK;
    5254:	12 aa       	std	Z+50, r1	; 0x32
	settings.status_report_mask = DEFAULT_STATUS_REPORT_MASK;
    5256:	83 e0       	ldi	r24, 0x03	; 3
    5258:	84 ab       	std	Z+52, r24	; 0x34
	settings.junction_deviation = DEFAULT_JUNCTION_DEVIATION;
    525a:	8a e0       	ldi	r24, 0x0A	; 10
    525c:	97 ed       	ldi	r25, 0xD7	; 215
    525e:	a3 e2       	ldi	r26, 0x23	; 35
    5260:	bc e3       	ldi	r27, 0x3C	; 60
    5262:	85 ab       	std	Z+53, r24	; 0x35
    5264:	96 ab       	std	Z+54, r25	; 0x36
    5266:	a7 ab       	std	Z+55, r26	; 0x37
    5268:	b0 af       	std	Z+56, r27	; 0x38
	settings.arc_tolerance = DEFAULT_ARC_TOLERANCE;
    526a:	8f e6       	ldi	r24, 0x6F	; 111
    526c:	92 e1       	ldi	r25, 0x12	; 18
    526e:	a3 e0       	ldi	r26, 0x03	; 3
    5270:	bb e3       	ldi	r27, 0x3B	; 59
    5272:	81 af       	std	Z+57, r24	; 0x39
    5274:	92 af       	std	Z+58, r25	; 0x3a
    5276:	a3 af       	std	Z+59, r26	; 0x3b
    5278:	b4 af       	std	Z+60, r27	; 0x3c
	settings.homing_dir_mask = DEFAULT_HOMING_DIR_MASK;
    527a:	16 ae       	std	Z+62, r1	; 0x3e
	settings.homing_feed_rate = DEFAULT_HOMING_FEED_RATE;
    527c:	80 e0       	ldi	r24, 0x00	; 0
    527e:	90 e0       	ldi	r25, 0x00	; 0
    5280:	a8 ec       	ldi	r26, 0xC8	; 200
    5282:	b1 e4       	ldi	r27, 0x41	; 65
    5284:	80 93 be 06 	sts	0x06BE, r24	; 0x8006be <settings+0x3f>
    5288:	90 93 bf 06 	sts	0x06BF, r25	; 0x8006bf <settings+0x40>
    528c:	a0 93 c0 06 	sts	0x06C0, r26	; 0x8006c0 <settings+0x41>
    5290:	b0 93 c1 06 	sts	0x06C1, r27	; 0x8006c1 <settings+0x42>
	settings.homing_seek_rate = DEFAULT_HOMING_SEEK_RATE;
    5294:	80 e0       	ldi	r24, 0x00	; 0
    5296:	90 e0       	ldi	r25, 0x00	; 0
    5298:	aa ef       	ldi	r26, 0xFA	; 250
    529a:	b3 e4       	ldi	r27, 0x43	; 67
    529c:	80 93 c2 06 	sts	0x06C2, r24	; 0x8006c2 <settings+0x43>
    52a0:	90 93 c3 06 	sts	0x06C3, r25	; 0x8006c3 <settings+0x44>
    52a4:	a0 93 c4 06 	sts	0x06C4, r26	; 0x8006c4 <settings+0x45>
    52a8:	b0 93 c5 06 	sts	0x06C5, r27	; 0x8006c5 <settings+0x46>
	settings.homing_debounce_delay = DEFAULT_HOMING_DEBOUNCE_DELAY;
    52ac:	2a ef       	ldi	r18, 0xFA	; 250
    52ae:	30 e0       	ldi	r19, 0x00	; 0
    52b0:	30 93 c7 06 	sts	0x06C7, r19	; 0x8006c7 <settings+0x48>
    52b4:	20 93 c6 06 	sts	0x06C6, r18	; 0x8006c6 <settings+0x47>
	settings.homing_pulloff = DEFAULT_HOMING_PULLOFF;
    52b8:	40 e0       	ldi	r20, 0x00	; 0
    52ba:	50 e0       	ldi	r21, 0x00	; 0
    52bc:	60 e8       	ldi	r22, 0x80	; 128
    52be:	7f e3       	ldi	r23, 0x3F	; 63
    52c0:	40 93 c8 06 	sts	0x06C8, r20	; 0x8006c8 <settings+0x49>
    52c4:	50 93 c9 06 	sts	0x06C9, r21	; 0x8006c9 <settings+0x4a>
    52c8:	60 93 ca 06 	sts	0x06CA, r22	; 0x8006ca <settings+0x4b>
    52cc:	70 93 cb 06 	sts	0x06CB, r23	; 0x8006cb <settings+0x4c>

	settings.flags = 0;
    52d0:	15 ae       	std	Z+61, r1	; 0x3d
	if (DEFAULT_INVERT_LIMIT_PINS) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
	if (DEFAULT_SOFT_LIMIT_ENABLE) { settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE; }
	if (DEFAULT_HARD_LIMIT_ENABLE) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
	if (DEFAULT_HOMING_ENABLE) { settings.flags |= BITFLAG_HOMING_ENABLE; }
  
	settings.steps_per_mm[X_AXIS] = DEFAULT_X_STEPS_PER_MM;
    52d2:	40 e0       	ldi	r20, 0x00	; 0
    52d4:	50 e0       	ldi	r21, 0x00	; 0
    52d6:	6a e7       	ldi	r22, 0x7A	; 122
    52d8:	73 e4       	ldi	r23, 0x43	; 67
    52da:	40 83       	st	Z, r20
    52dc:	51 83       	std	Z+1, r21	; 0x01
    52de:	62 83       	std	Z+2, r22	; 0x02
    52e0:	73 83       	std	Z+3, r23	; 0x03
	settings.steps_per_mm[Y_AXIS] = DEFAULT_Y_STEPS_PER_MM;
    52e2:	44 83       	std	Z+4, r20	; 0x04
    52e4:	55 83       	std	Z+5, r21	; 0x05
    52e6:	66 83       	std	Z+6, r22	; 0x06
    52e8:	77 83       	std	Z+7, r23	; 0x07
	settings.steps_per_mm[Z_AXIS] = DEFAULT_Z_STEPS_PER_MM;
    52ea:	40 87       	std	Z+8, r20	; 0x08
    52ec:	51 87       	std	Z+9, r21	; 0x09
    52ee:	62 87       	std	Z+10, r22	; 0x0a
    52f0:	73 87       	std	Z+11, r23	; 0x0b
	settings.max_rate[X_AXIS] = DEFAULT_X_MAX_RATE;
    52f2:	84 87       	std	Z+12, r24	; 0x0c
    52f4:	95 87       	std	Z+13, r25	; 0x0d
    52f6:	a6 87       	std	Z+14, r26	; 0x0e
    52f8:	b7 87       	std	Z+15, r27	; 0x0f
	settings.max_rate[Y_AXIS] = DEFAULT_Y_MAX_RATE;
    52fa:	80 8b       	std	Z+16, r24	; 0x10
    52fc:	91 8b       	std	Z+17, r25	; 0x11
    52fe:	a2 8b       	std	Z+18, r26	; 0x12
    5300:	b3 8b       	std	Z+19, r27	; 0x13
	settings.max_rate[Z_AXIS] = DEFAULT_Z_MAX_RATE;
    5302:	84 8b       	std	Z+20, r24	; 0x14
    5304:	95 8b       	std	Z+21, r25	; 0x15
    5306:	a6 8b       	std	Z+22, r26	; 0x16
    5308:	b7 8b       	std	Z+23, r27	; 0x17
	settings.acceleration[X_AXIS] = DEFAULT_X_ACCELERATION;
    530a:	80 e0       	ldi	r24, 0x00	; 0
    530c:	90 ea       	ldi	r25, 0xA0	; 160
    530e:	ac e0       	ldi	r26, 0x0C	; 12
    5310:	b7 e4       	ldi	r27, 0x47	; 71
    5312:	80 8f       	std	Z+24, r24	; 0x18
    5314:	91 8f       	std	Z+25, r25	; 0x19
    5316:	a2 8f       	std	Z+26, r26	; 0x1a
    5318:	b3 8f       	std	Z+27, r27	; 0x1b
	settings.acceleration[Y_AXIS] = DEFAULT_Y_ACCELERATION;
    531a:	84 8f       	std	Z+28, r24	; 0x1c
    531c:	95 8f       	std	Z+29, r25	; 0x1d
    531e:	a6 8f       	std	Z+30, r26	; 0x1e
    5320:	b7 8f       	std	Z+31, r27	; 0x1f
	settings.acceleration[Z_AXIS] = DEFAULT_Z_ACCELERATION;
    5322:	80 a3       	std	Z+32, r24	; 0x20
    5324:	91 a3       	std	Z+33, r25	; 0x21
    5326:	a2 a3       	std	Z+34, r26	; 0x22
    5328:	b3 a3       	std	Z+35, r27	; 0x23
	settings.max_travel[X_AXIS] = (-DEFAULT_X_MAX_TRAVEL);
    532a:	80 e0       	ldi	r24, 0x00	; 0
    532c:	90 e0       	ldi	r25, 0x00	; 0
    532e:	a8 e4       	ldi	r26, 0x48	; 72
    5330:	b3 ec       	ldi	r27, 0xC3	; 195
    5332:	84 a3       	std	Z+36, r24	; 0x24
    5334:	95 a3       	std	Z+37, r25	; 0x25
    5336:	a6 a3       	std	Z+38, r26	; 0x26
    5338:	b7 a3       	std	Z+39, r27	; 0x27
	settings.max_travel[Y_AXIS] = (-DEFAULT_Y_MAX_TRAVEL);
    533a:	80 a7       	std	Z+40, r24	; 0x28
    533c:	91 a7       	std	Z+41, r25	; 0x29
    533e:	a2 a7       	std	Z+42, r26	; 0x2a
    5340:	b3 a7       	std	Z+43, r27	; 0x2b
	settings.max_travel[Z_AXIS] = (-DEFAULT_Z_MAX_TRAVEL);    
    5342:	84 a7       	std	Z+44, r24	; 0x2c
    5344:	95 a7       	std	Z+45, r25	; 0x2d
    5346:	a6 a7       	std	Z+46, r26	; 0x2e
    5348:	b7 a7       	std	Z+47, r27	; 0x2f

	write_global_settings();
    534a:	0e 94 06 29 	call	0x520c	; 0x520c <write_global_settings>
  }
  
  if (restore_flag & SETTINGS_RESTORE_PARAMETERS) {
    534e:	01 ff       	sbrs	r16, 1
    5350:	11 c0       	rjmp	.+34     	; 0x5374 <settings_restore+0x14c>
	uint8_t idx;
	float coord_data[N_AXIS];
	memset(&coord_data, 0, sizeof(coord_data));
    5352:	fe 01       	movw	r30, r28
    5354:	31 96       	adiw	r30, 0x01	; 1
    5356:	8c e0       	ldi	r24, 0x0C	; 12
    5358:	df 01       	movw	r26, r30
    535a:	1d 92       	st	X+, r1
    535c:	8a 95       	dec	r24
    535e:	e9 f7       	brne	.-6      	; 0x535a <settings_restore+0x132>
	for (idx=0; idx <= SETTING_INDEX_NCOORD; idx++) { settings_write_coord_data(idx, coord_data); }
    5360:	10 e0       	ldi	r17, 0x00	; 0
    5362:	be 01       	movw	r22, r28
    5364:	6f 5f       	subi	r22, 0xFF	; 255
    5366:	7f 4f       	sbci	r23, 0xFF	; 255
    5368:	81 2f       	mov	r24, r17
    536a:	0e 94 fc 28 	call	0x51f8	; 0x51f8 <settings_write_coord_data>
    536e:	1f 5f       	subi	r17, 0xFF	; 255
    5370:	18 30       	cpi	r17, 0x08	; 8
    5372:	b9 f7       	brne	.-18     	; 0x5362 <settings_restore+0x13a>
  }
  
  if (restore_flag & SETTINGS_RESTORE_STARTUP_LINES) {
    5374:	02 ff       	sbrs	r16, 2
    5376:	0a c0       	rjmp	.+20     	; 0x538c <settings_restore+0x164>
	#if N_STARTUP_LINE > 0
	eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK, 0);
    5378:	60 e0       	ldi	r22, 0x00	; 0
    537a:	80 e0       	ldi	r24, 0x00	; 0
    537c:	93 e0       	ldi	r25, 0x03	; 3
    537e:	0e 94 1b 05 	call	0xa36	; 0xa36 <eeprom_put_char>
	#endif
	#if N_STARTUP_LINE > 1
	eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+1), 0);
    5382:	60 e0       	ldi	r22, 0x00	; 0
    5384:	81 e5       	ldi	r24, 0x51	; 81
    5386:	93 e0       	ldi	r25, 0x03	; 3
    5388:	0e 94 1b 05 	call	0xa36	; 0xa36 <eeprom_put_char>
	#endif
  }
  
  if (restore_flag & SETTINGS_RESTORE_BUILD_INFO) { eeprom_put_char(EEPROM_ADDR_BUILD_INFO , 0); }
    538c:	03 ff       	sbrs	r16, 3
    538e:	05 c0       	rjmp	.+10     	; 0x539a <settings_restore+0x172>
    5390:	60 e0       	ldi	r22, 0x00	; 0
    5392:	8e ea       	ldi	r24, 0xAE	; 174
    5394:	93 e0       	ldi	r25, 0x03	; 3
    5396:	0e 94 1b 05 	call	0xa36	; 0xa36 <eeprom_put_char>
}
    539a:	2c 96       	adiw	r28, 0x0c	; 12
    539c:	0f b6       	in	r0, 0x3f	; 63
    539e:	f8 94       	cli
    53a0:	de bf       	out	0x3e, r29	; 62
    53a2:	0f be       	out	0x3f, r0	; 63
    53a4:	cd bf       	out	0x3d, r28	; 61
    53a6:	df 91       	pop	r29
    53a8:	cf 91       	pop	r28
    53aa:	1f 91       	pop	r17
    53ac:	0f 91       	pop	r16
    53ae:	08 95       	ret

000053b0 <settings_read_startup_line>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_startup_line(uint8_t n, char *line)
{
    53b0:	1f 93       	push	r17
    53b2:	cf 93       	push	r28
    53b4:	df 93       	push	r29
    53b6:	18 2f       	mov	r17, r24
    53b8:	eb 01       	movw	r28, r22
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
  if (!(memcpy_from_eeprom_with_checksum((char*)line, addr, LINE_BUFFER_SIZE))) {
    53ba:	81 e5       	ldi	r24, 0x51	; 81
    53bc:	18 9f       	mul	r17, r24
    53be:	b0 01       	movw	r22, r0
    53c0:	11 24       	eor	r1, r1
    53c2:	7d 5f       	subi	r23, 0xFD	; 253
    53c4:	40 e5       	ldi	r20, 0x50	; 80
    53c6:	50 e0       	ldi	r21, 0x00	; 0
    53c8:	ce 01       	movw	r24, r28
    53ca:	0e 94 7f 05 	call	0xafe	; 0xafe <memcpy_from_eeprom_with_checksum>
    53ce:	89 2b       	or	r24, r25
    53d0:	39 f4       	brne	.+14     	; 0x53e0 <settings_read_startup_line+0x30>
    // Reset line with default value
    line[0] = 0; // Empty line
    53d2:	18 82       	st	Y, r1
    settings_store_startup_line(n, line);
    53d4:	be 01       	movw	r22, r28
    53d6:	81 2f       	mov	r24, r17
    53d8:	0e 94 ea 28 	call	0x51d4	; 0x51d4 <settings_store_startup_line>
    return(false);
    53dc:	80 e0       	ldi	r24, 0x00	; 0
    53de:	01 c0       	rjmp	.+2      	; 0x53e2 <settings_read_startup_line+0x32>
  }
  return(true);
    53e0:	81 e0       	ldi	r24, 0x01	; 1
}
    53e2:	df 91       	pop	r29
    53e4:	cf 91       	pop	r28
    53e6:	1f 91       	pop	r17
    53e8:	08 95       	ret

000053ea <settings_read_build_info>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_build_info(char *line)
{
    53ea:	cf 93       	push	r28
    53ec:	df 93       	push	r29
    53ee:	ec 01       	movw	r28, r24
  if (!(memcpy_from_eeprom_with_checksum((char*)line, EEPROM_ADDR_BUILD_INFO, LINE_BUFFER_SIZE))) {
    53f0:	40 e5       	ldi	r20, 0x50	; 80
    53f2:	50 e0       	ldi	r21, 0x00	; 0
    53f4:	6e ea       	ldi	r22, 0xAE	; 174
    53f6:	73 e0       	ldi	r23, 0x03	; 3
    53f8:	0e 94 7f 05 	call	0xafe	; 0xafe <memcpy_from_eeprom_with_checksum>
    53fc:	89 2b       	or	r24, r25
    53fe:	31 f4       	brne	.+12     	; 0x540c <settings_read_build_info+0x22>
    // Reset line with default value
    line[0] = 0; // Empty line
    5400:	18 82       	st	Y, r1
    settings_store_build_info(line);
    5402:	ce 01       	movw	r24, r28
    5404:	0e 94 f4 28 	call	0x51e8	; 0x51e8 <settings_store_build_info>
    return(false);
    5408:	80 e0       	ldi	r24, 0x00	; 0
    540a:	01 c0       	rjmp	.+2      	; 0x540e <settings_read_build_info+0x24>
  }
  return(true);
    540c:	81 e0       	ldi	r24, 0x01	; 1
}
    540e:	df 91       	pop	r29
    5410:	cf 91       	pop	r28
    5412:	08 95       	ret

00005414 <settings_read_coord_data>:


// Read selected coordinate data from EEPROM. Updates pointed coord_data value.
uint8_t settings_read_coord_data(uint8_t coord_select, float *coord_data)
{
    5414:	1f 93       	push	r17
    5416:	cf 93       	push	r28
    5418:	df 93       	push	r29
    541a:	18 2f       	mov	r17, r24
    541c:	eb 01       	movw	r28, r22
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
  if (!(memcpy_from_eeprom_with_checksum((char*)coord_data, addr, sizeof(float)*N_AXIS))) {
    541e:	8d e0       	ldi	r24, 0x0D	; 13
    5420:	18 9f       	mul	r17, r24
    5422:	b0 01       	movw	r22, r0
    5424:	11 24       	eor	r1, r1
    5426:	7e 5f       	subi	r23, 0xFE	; 254
    5428:	4c e0       	ldi	r20, 0x0C	; 12
    542a:	50 e0       	ldi	r21, 0x00	; 0
    542c:	ce 01       	movw	r24, r28
    542e:	0e 94 7f 05 	call	0xafe	; 0xafe <memcpy_from_eeprom_with_checksum>
    5432:	89 2b       	or	r24, r25
    5434:	59 f4       	brne	.+22     	; 0x544c <settings_read_coord_data+0x38>
    // Reset with default zero vector
    clear_vector_float(coord_data); 
    5436:	8c e0       	ldi	r24, 0x0C	; 12
    5438:	fe 01       	movw	r30, r28
    543a:	11 92       	st	Z+, r1
    543c:	8a 95       	dec	r24
    543e:	e9 f7       	brne	.-6      	; 0x543a <settings_read_coord_data+0x26>
    settings_write_coord_data(coord_select,coord_data);
    5440:	be 01       	movw	r22, r28
    5442:	81 2f       	mov	r24, r17
    5444:	0e 94 fc 28 	call	0x51f8	; 0x51f8 <settings_write_coord_data>
    return(false);
    5448:	80 e0       	ldi	r24, 0x00	; 0
    544a:	01 c0       	rjmp	.+2      	; 0x544e <settings_read_coord_data+0x3a>
  }
  return(true);
    544c:	81 e0       	ldi	r24, 0x01	; 1
}  
    544e:	df 91       	pop	r29
    5450:	cf 91       	pop	r28
    5452:	1f 91       	pop	r17
    5454:	08 95       	ret

00005456 <read_global_settings>:


// Reads Grbl global settings struct from EEPROM.
uint8_t read_global_settings() {
  // Check version-byte of eeprom
  uint8_t version = eeprom_get_char(0);
    5456:	80 e0       	ldi	r24, 0x00	; 0
    5458:	90 e0       	ldi	r25, 0x00	; 0
    545a:	0e 94 13 05 	call	0xa26	; 0xa26 <eeprom_get_char>
  if (version == SETTINGS_VERSION) {
    545e:	89 30       	cpi	r24, 0x09	; 9
    5460:	69 f4       	brne	.+26     	; 0x547c <read_global_settings+0x26>
    // Read settings-record and check checksum
    if (!(memcpy_from_eeprom_with_checksum((char*)&settings, EEPROM_ADDR_GLOBAL, sizeof(settings_t)))) {
    5462:	4d e4       	ldi	r20, 0x4D	; 77
    5464:	50 e0       	ldi	r21, 0x00	; 0
    5466:	61 e0       	ldi	r22, 0x01	; 1
    5468:	70 e0       	ldi	r23, 0x00	; 0
    546a:	8f e7       	ldi	r24, 0x7F	; 127
    546c:	96 e0       	ldi	r25, 0x06	; 6
    546e:	0e 94 7f 05 	call	0xafe	; 0xafe <memcpy_from_eeprom_with_checksum>
      return(false);
    5472:	21 e0       	ldi	r18, 0x01	; 1
    5474:	89 2b       	or	r24, r25
    5476:	19 f4       	brne	.+6      	; 0x547e <read_global_settings+0x28>
    5478:	20 e0       	ldi	r18, 0x00	; 0
    547a:	01 c0       	rjmp	.+2      	; 0x547e <read_global_settings+0x28>
    }
  } else {
    return(false); 
    547c:	20 e0       	ldi	r18, 0x00	; 0
  }
  return(true);
}
    547e:	82 2f       	mov	r24, r18
    5480:	08 95       	ret

00005482 <settings_store_global_setting>:


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
    5482:	cf 92       	push	r12
    5484:	df 92       	push	r13
    5486:	ef 92       	push	r14
    5488:	ff 92       	push	r15
    548a:	cf 93       	push	r28
    548c:	df 93       	push	r29
    548e:	c8 2f       	mov	r28, r24
    5490:	6a 01       	movw	r12, r20
    5492:	7b 01       	movw	r14, r22
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); } 
    5494:	20 e0       	ldi	r18, 0x00	; 0
    5496:	30 e0       	ldi	r19, 0x00	; 0
    5498:	a9 01       	movw	r20, r18
    549a:	c7 01       	movw	r24, r14
    549c:	b6 01       	movw	r22, r12
    549e:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    54a2:	88 23       	and	r24, r24
    54a4:	0c f4       	brge	.+2      	; 0x54a8 <settings_store_global_setting+0x26>
    54a6:	dd c0       	rjmp	.+442    	; 0x5662 <settings_store_global_setting+0x1e0>
  if (parameter >= AXIS_SETTINGS_START_VAL) {
    54a8:	c4 36       	cpi	r28, 0x64	; 100
    54aa:	a0 f0       	brcs	.+40     	; 0x54d4 <settings_store_global_setting+0x52>
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    54ac:	ec e9       	ldi	r30, 0x9C	; 156
    54ae:	ec 0f       	add	r30, r28
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    54b0:	e3 30       	cpi	r30, 0x03	; 3
    54b2:	20 f0       	brcs	.+8      	; 0x54bc <settings_store_global_setting+0x3a>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    54b4:	ea 30       	cpi	r30, 0x0A	; 10
    54b6:	08 f0       	brcs	.+2      	; 0x54ba <settings_store_global_setting+0x38>
    54b8:	e2 c0       	rjmp	.+452    	; 0x567e <settings_store_global_setting+0x1fc>
    54ba:	d5 c0       	rjmp	.+426    	; 0x5666 <settings_store_global_setting+0x1e4>
        switch (set_idx) {
          case 0:
            #ifdef MAX_STEP_RATE_HZ
              if (value*settings.max_rate[parameter] > (MAX_STEP_RATE_HZ*60.0)) { return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            #endif
            settings.steps_per_mm[parameter] = value;
    54bc:	f0 e0       	ldi	r31, 0x00	; 0
    54be:	ee 0f       	add	r30, r30
    54c0:	ff 1f       	adc	r31, r31
    54c2:	ee 0f       	add	r30, r30
    54c4:	ff 1f       	adc	r31, r31
    54c6:	e1 58       	subi	r30, 0x81	; 129
    54c8:	f9 4f       	sbci	r31, 0xF9	; 249
    54ca:	c0 82       	st	Z, r12
    54cc:	d1 82       	std	Z+1, r13	; 0x01
    54ce:	e2 82       	std	Z+2, r14	; 0x02
    54d0:	f3 82       	std	Z+3, r15	; 0x03
            break;
    54d2:	c3 c0       	rjmp	.+390    	; 0x565a <settings_store_global_setting+0x1d8>
        parameter -= AXIS_SETTINGS_INCREMENT;
      }
    }
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    54d4:	c7 01       	movw	r24, r14
    54d6:	b6 01       	movw	r22, r12
    54d8:	0e 94 e4 3c 	call	0x79c8	; 0x79c8 <trunc>
    54dc:	0e 94 22 3a 	call	0x7444	; 0x7444 <__fixunssfsi>
    switch(parameter) {
    54e0:	8c 2f       	mov	r24, r28
    54e2:	90 e0       	ldi	r25, 0x00	; 0
    54e4:	8c 31       	cpi	r24, 0x1C	; 28
    54e6:	91 05       	cpc	r25, r1
    54e8:	08 f0       	brcs	.+2      	; 0x54ec <settings_store_global_setting+0x6a>
    54ea:	bf c0       	rjmp	.+382    	; 0x566a <settings_store_global_setting+0x1e8>
    54ec:	fc 01       	movw	r30, r24
    54ee:	ea 5c       	subi	r30, 0xCA	; 202
    54f0:	fe 4f       	sbci	r31, 0xFE	; 254
    54f2:	0c 94 38 3d 	jmp	0x7a70	; 0x7a70 <__tablejump2__>
      case 0: 
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    54f6:	63 30       	cpi	r22, 0x03	; 3
    54f8:	08 f4       	brcc	.+2      	; 0x54fc <settings_store_global_setting+0x7a>
    54fa:	b9 c0       	rjmp	.+370    	; 0x566e <settings_store_global_setting+0x1ec>
        settings.pulse_microseconds = int_value; break;
    54fc:	60 93 af 06 	sts	0x06AF, r22	; 0x8006af <settings+0x30>
    5500:	ac c0       	rjmp	.+344    	; 0x565a <settings_store_global_setting+0x1d8>
      case 1: settings.stepper_idle_lock_time = int_value; break;
    5502:	60 93 b2 06 	sts	0x06B2, r22	; 0x8006b2 <settings+0x33>
    5506:	a9 c0       	rjmp	.+338    	; 0x565a <settings_store_global_setting+0x1d8>
      case 2: 
        settings.step_invert_mask = int_value; 
    5508:	60 93 b0 06 	sts	0x06B0, r22	; 0x8006b0 <settings+0x31>
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    550c:	0e 94 7d 2e 	call	0x5cfa	; 0x5cfa <st_generate_step_dir_invert_masks>
        break;
    5510:	a4 c0       	rjmp	.+328    	; 0x565a <settings_store_global_setting+0x1d8>
      case 3: 
        settings.dir_invert_mask = int_value; 
    5512:	60 93 b1 06 	sts	0x06B1, r22	; 0x8006b1 <settings+0x32>
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    5516:	0e 94 7d 2e 	call	0x5cfa	; 0x5cfa <st_generate_step_dir_invert_masks>
        break;
    551a:	9f c0       	rjmp	.+318    	; 0x565a <settings_store_global_setting+0x1d8>
      case 4: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
    551c:	66 23       	and	r22, r22
    551e:	31 f0       	breq	.+12     	; 0x552c <settings_store_global_setting+0xaa>
    5520:	ef e7       	ldi	r30, 0x7F	; 127
    5522:	f6 e0       	ldi	r31, 0x06	; 6
    5524:	85 ad       	ldd	r24, Z+61	; 0x3d
    5526:	84 60       	ori	r24, 0x04	; 4
    5528:	85 af       	std	Z+61, r24	; 0x3d
    552a:	97 c0       	rjmp	.+302    	; 0x565a <settings_store_global_setting+0x1d8>
        else { settings.flags &= ~BITFLAG_INVERT_ST_ENABLE; }
    552c:	ef e7       	ldi	r30, 0x7F	; 127
    552e:	f6 e0       	ldi	r31, 0x06	; 6
    5530:	85 ad       	ldd	r24, Z+61	; 0x3d
    5532:	8b 7f       	andi	r24, 0xFB	; 251
    5534:	85 af       	std	Z+61, r24	; 0x3d
    5536:	91 c0       	rjmp	.+290    	; 0x565a <settings_store_global_setting+0x1d8>
        break;
      case 5: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
    5538:	66 23       	and	r22, r22
    553a:	31 f0       	breq	.+12     	; 0x5548 <settings_store_global_setting+0xc6>
    553c:	ef e7       	ldi	r30, 0x7F	; 127
    553e:	f6 e0       	ldi	r31, 0x06	; 6
    5540:	85 ad       	ldd	r24, Z+61	; 0x3d
    5542:	80 64       	ori	r24, 0x40	; 64
    5544:	85 af       	std	Z+61, r24	; 0x3d
    5546:	89 c0       	rjmp	.+274    	; 0x565a <settings_store_global_setting+0x1d8>
        else { settings.flags &= ~BITFLAG_INVERT_LIMIT_PINS; }
    5548:	ef e7       	ldi	r30, 0x7F	; 127
    554a:	f6 e0       	ldi	r31, 0x06	; 6
    554c:	85 ad       	ldd	r24, Z+61	; 0x3d
    554e:	8f 7b       	andi	r24, 0xBF	; 191
    5550:	85 af       	std	Z+61, r24	; 0x3d
    5552:	83 c0       	rjmp	.+262    	; 0x565a <settings_store_global_setting+0x1d8>
        break;
      case 6: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_PROBE_PIN; }
    5554:	66 23       	and	r22, r22
    5556:	31 f0       	breq	.+12     	; 0x5564 <settings_store_global_setting+0xe2>
    5558:	ef e7       	ldi	r30, 0x7F	; 127
    555a:	f6 e0       	ldi	r31, 0x06	; 6
    555c:	85 ad       	ldd	r24, Z+61	; 0x3d
    555e:	80 68       	ori	r24, 0x80	; 128
    5560:	85 af       	std	Z+61, r24	; 0x3d
    5562:	7b c0       	rjmp	.+246    	; 0x565a <settings_store_global_setting+0x1d8>
        else { settings.flags &= ~BITFLAG_INVERT_PROBE_PIN; }
    5564:	ef e7       	ldi	r30, 0x7F	; 127
    5566:	f6 e0       	ldi	r31, 0x06	; 6
    5568:	85 ad       	ldd	r24, Z+61	; 0x3d
    556a:	8f 77       	andi	r24, 0x7F	; 127
    556c:	85 af       	std	Z+61, r24	; 0x3d
    556e:	75 c0       	rjmp	.+234    	; 0x565a <settings_store_global_setting+0x1d8>
        break;
      case 10: settings.status_report_mask = int_value; break;
    5570:	60 93 b3 06 	sts	0x06B3, r22	; 0x8006b3 <settings+0x34>
    5574:	72 c0       	rjmp	.+228    	; 0x565a <settings_store_global_setting+0x1d8>
      case 11: settings.junction_deviation = value; break;
    5576:	c0 92 b4 06 	sts	0x06B4, r12	; 0x8006b4 <settings+0x35>
    557a:	d0 92 b5 06 	sts	0x06B5, r13	; 0x8006b5 <settings+0x36>
    557e:	e0 92 b6 06 	sts	0x06B6, r14	; 0x8006b6 <settings+0x37>
    5582:	f0 92 b7 06 	sts	0x06B7, r15	; 0x8006b7 <settings+0x38>
    5586:	69 c0       	rjmp	.+210    	; 0x565a <settings_store_global_setting+0x1d8>
      case 12: settings.arc_tolerance = value; break;
    5588:	c0 92 b8 06 	sts	0x06B8, r12	; 0x8006b8 <settings+0x39>
    558c:	d0 92 b9 06 	sts	0x06B9, r13	; 0x8006b9 <settings+0x3a>
    5590:	e0 92 ba 06 	sts	0x06BA, r14	; 0x8006ba <settings+0x3b>
    5594:	f0 92 bb 06 	sts	0x06BB, r15	; 0x8006bb <settings+0x3c>
    5598:	60 c0       	rjmp	.+192    	; 0x565a <settings_store_global_setting+0x1d8>
      case 13:
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
    559a:	66 23       	and	r22, r22
    559c:	31 f0       	breq	.+12     	; 0x55aa <settings_store_global_setting+0x128>
    559e:	ef e7       	ldi	r30, 0x7F	; 127
    55a0:	f6 e0       	ldi	r31, 0x06	; 6
    55a2:	85 ad       	ldd	r24, Z+61	; 0x3d
    55a4:	81 60       	ori	r24, 0x01	; 1
    55a6:	85 af       	std	Z+61, r24	; 0x3d
    55a8:	58 c0       	rjmp	.+176    	; 0x565a <settings_store_global_setting+0x1d8>
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
    55aa:	ef e7       	ldi	r30, 0x7F	; 127
    55ac:	f6 e0       	ldi	r31, 0x06	; 6
    55ae:	85 ad       	ldd	r24, Z+61	; 0x3d
    55b0:	8e 7f       	andi	r24, 0xFE	; 254
    55b2:	85 af       	std	Z+61, r24	; 0x3d
    55b4:	52 c0       	rjmp	.+164    	; 0x565a <settings_store_global_setting+0x1d8>
        break;
      case 20:
        if (int_value) { 
    55b6:	66 23       	and	r22, r22
    55b8:	41 f0       	breq	.+16     	; 0x55ca <settings_store_global_setting+0x148>
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    55ba:	80 91 bc 06 	lds	r24, 0x06BC	; 0x8006bc <settings+0x3d>
    55be:	84 ff       	sbrs	r24, 4
    55c0:	58 c0       	rjmp	.+176    	; 0x5672 <settings_store_global_setting+0x1f0>
          settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE; 
    55c2:	80 62       	ori	r24, 0x20	; 32
    55c4:	80 93 bc 06 	sts	0x06BC, r24	; 0x8006bc <settings+0x3d>
    55c8:	48 c0       	rjmp	.+144    	; 0x565a <settings_store_global_setting+0x1d8>
        } else { settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; }
    55ca:	ef e7       	ldi	r30, 0x7F	; 127
    55cc:	f6 e0       	ldi	r31, 0x06	; 6
    55ce:	85 ad       	ldd	r24, Z+61	; 0x3d
    55d0:	8f 7d       	andi	r24, 0xDF	; 223
    55d2:	85 af       	std	Z+61, r24	; 0x3d
    55d4:	42 c0       	rjmp	.+132    	; 0x565a <settings_store_global_setting+0x1d8>
        break;
      case 21:
        if (int_value) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
    55d6:	66 23       	and	r22, r22
    55d8:	31 f0       	breq	.+12     	; 0x55e6 <settings_store_global_setting+0x164>
    55da:	ef e7       	ldi	r30, 0x7F	; 127
    55dc:	f6 e0       	ldi	r31, 0x06	; 6
    55de:	85 ad       	ldd	r24, Z+61	; 0x3d
    55e0:	88 60       	ori	r24, 0x08	; 8
    55e2:	85 af       	std	Z+61, r24	; 0x3d
    55e4:	05 c0       	rjmp	.+10     	; 0x55f0 <settings_store_global_setting+0x16e>
        else { settings.flags &= ~BITFLAG_HARD_LIMIT_ENABLE; }
    55e6:	ef e7       	ldi	r30, 0x7F	; 127
    55e8:	f6 e0       	ldi	r31, 0x06	; 6
    55ea:	85 ad       	ldd	r24, Z+61	; 0x3d
    55ec:	87 7f       	andi	r24, 0xF7	; 247
    55ee:	85 af       	std	Z+61, r24	; 0x3d
        limits_init(); // Re-init to immediately change. NOTE: Nice to have but could be problematic later.
    55f0:	0e 94 06 11 	call	0x220c	; 0x220c <limits_init>
        break;
    55f4:	32 c0       	rjmp	.+100    	; 0x565a <settings_store_global_setting+0x1d8>
      case 22:
        if (int_value) { settings.flags |= BITFLAG_HOMING_ENABLE; }
    55f6:	66 23       	and	r22, r22
    55f8:	31 f0       	breq	.+12     	; 0x5606 <settings_store_global_setting+0x184>
    55fa:	ef e7       	ldi	r30, 0x7F	; 127
    55fc:	f6 e0       	ldi	r31, 0x06	; 6
    55fe:	85 ad       	ldd	r24, Z+61	; 0x3d
    5600:	80 61       	ori	r24, 0x10	; 16
    5602:	85 af       	std	Z+61, r24	; 0x3d
    5604:	2a c0       	rjmp	.+84     	; 0x565a <settings_store_global_setting+0x1d8>
        else { 
          settings.flags &= ~BITFLAG_HOMING_ENABLE; 
          settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; // Force disable soft-limits.
    5606:	ef e7       	ldi	r30, 0x7F	; 127
    5608:	f6 e0       	ldi	r31, 0x06	; 6
    560a:	85 ad       	ldd	r24, Z+61	; 0x3d
    560c:	8f 7c       	andi	r24, 0xCF	; 207
    560e:	85 af       	std	Z+61, r24	; 0x3d
    5610:	24 c0       	rjmp	.+72     	; 0x565a <settings_store_global_setting+0x1d8>
        }
        break;
      case 23: settings.homing_dir_mask = int_value; break;
    5612:	60 93 bd 06 	sts	0x06BD, r22	; 0x8006bd <settings+0x3e>
    5616:	21 c0       	rjmp	.+66     	; 0x565a <settings_store_global_setting+0x1d8>
      case 24: settings.homing_feed_rate = value; break;
    5618:	c0 92 be 06 	sts	0x06BE, r12	; 0x8006be <settings+0x3f>
    561c:	d0 92 bf 06 	sts	0x06BF, r13	; 0x8006bf <settings+0x40>
    5620:	e0 92 c0 06 	sts	0x06C0, r14	; 0x8006c0 <settings+0x41>
    5624:	f0 92 c1 06 	sts	0x06C1, r15	; 0x8006c1 <settings+0x42>
    5628:	18 c0       	rjmp	.+48     	; 0x565a <settings_store_global_setting+0x1d8>
      case 25: settings.homing_seek_rate = value; break;
    562a:	c0 92 c2 06 	sts	0x06C2, r12	; 0x8006c2 <settings+0x43>
    562e:	d0 92 c3 06 	sts	0x06C3, r13	; 0x8006c3 <settings+0x44>
    5632:	e0 92 c4 06 	sts	0x06C4, r14	; 0x8006c4 <settings+0x45>
    5636:	f0 92 c5 06 	sts	0x06C5, r15	; 0x8006c5 <settings+0x46>
    563a:	0f c0       	rjmp	.+30     	; 0x565a <settings_store_global_setting+0x1d8>
      case 26: settings.homing_debounce_delay = int_value; break;
    563c:	86 2f       	mov	r24, r22
    563e:	90 e0       	ldi	r25, 0x00	; 0
    5640:	90 93 c7 06 	sts	0x06C7, r25	; 0x8006c7 <settings+0x48>
    5644:	80 93 c6 06 	sts	0x06C6, r24	; 0x8006c6 <settings+0x47>
    5648:	08 c0       	rjmp	.+16     	; 0x565a <settings_store_global_setting+0x1d8>
      case 27: settings.homing_pulloff = value; break;
    564a:	c0 92 c8 06 	sts	0x06C8, r12	; 0x8006c8 <settings+0x49>
    564e:	d0 92 c9 06 	sts	0x06C9, r13	; 0x8006c9 <settings+0x4a>
    5652:	e0 92 ca 06 	sts	0x06CA, r14	; 0x8006ca <settings+0x4b>
    5656:	f0 92 cb 06 	sts	0x06CB, r15	; 0x8006cb <settings+0x4c>
      default: 
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
    565a:	0e 94 06 29 	call	0x520c	; 0x520c <write_global_settings>
  return(STATUS_OK);
    565e:	80 e0       	ldi	r24, 0x00	; 0
    5660:	58 c0       	rjmp	.+176    	; 0x5712 <settings_store_global_setting+0x290>
}


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); } 
    5662:	84 e0       	ldi	r24, 0x04	; 4
    5664:	56 c0       	rjmp	.+172    	; 0x5712 <settings_store_global_setting+0x290>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    5666:	83 e0       	ldi	r24, 0x03	; 3
    5668:	54 c0       	rjmp	.+168    	; 0x5712 <settings_store_global_setting+0x290>
      case 24: settings.homing_feed_rate = value; break;
      case 25: settings.homing_seek_rate = value; break;
      case 26: settings.homing_debounce_delay = int_value; break;
      case 27: settings.homing_pulloff = value; break;
      default: 
        return(STATUS_INVALID_STATEMENT);
    566a:	83 e0       	ldi	r24, 0x03	; 3
    566c:	52 c0       	rjmp	.+164    	; 0x5712 <settings_store_global_setting+0x290>
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    switch(parameter) {
      case 0: 
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    566e:	86 e0       	ldi	r24, 0x06	; 6
    5670:	50 c0       	rjmp	.+160    	; 0x5712 <settings_store_global_setting+0x290>
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
        break;
      case 20:
        if (int_value) { 
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    5672:	8a e0       	ldi	r24, 0x0A	; 10
    5674:	4e c0       	rjmp	.+156    	; 0x5712 <settings_store_global_setting+0x290>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    5676:	83 e0       	ldi	r24, 0x03	; 3
    5678:	4c c0       	rjmp	.+152    	; 0x5712 <settings_store_global_setting+0x290>
    567a:	83 e0       	ldi	r24, 0x03	; 3
    567c:	4a c0       	rjmp	.+148    	; 0x5712 <settings_store_global_setting+0x290>
        parameter -= AXIS_SETTINGS_INCREMENT;
    567e:	e2 e9       	ldi	r30, 0x92	; 146
    5680:	ec 0f       	add	r30, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    5682:	e3 30       	cpi	r30, 0x03	; 3
    5684:	70 f0       	brcs	.+28     	; 0x56a2 <settings_store_global_setting+0x220>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    5686:	ea 30       	cpi	r30, 0x0A	; 10
    5688:	b0 f3       	brcs	.-20     	; 0x5676 <settings_store_global_setting+0x1f4>
        parameter -= AXIS_SETTINGS_INCREMENT;
    568a:	88 e8       	ldi	r24, 0x88	; 136
    568c:	8c 0f       	add	r24, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    568e:	83 30       	cpi	r24, 0x03	; 3
    5690:	a0 f0       	brcs	.+40     	; 0x56ba <settings_store_global_setting+0x238>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    5692:	8a 30       	cpi	r24, 0x0A	; 10
    5694:	90 f3       	brcs	.-28     	; 0x567a <settings_store_global_setting+0x1f8>
        parameter -= AXIS_SETTINGS_INCREMENT;
    5696:	8e e7       	ldi	r24, 0x7E	; 126
    5698:	8c 0f       	add	r24, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    569a:	83 30       	cpi	r24, 0x03	; 3
    569c:	48 f1       	brcs	.+82     	; 0x56f0 <settings_store_global_setting+0x26e>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    569e:	83 e0       	ldi	r24, 0x03	; 3
    56a0:	38 c0       	rjmp	.+112    	; 0x5712 <settings_store_global_setting+0x290>
            break;
          case 1:
            #ifdef MAX_STEP_RATE_HZ
              if (value*settings.steps_per_mm[parameter] > (MAX_STEP_RATE_HZ*60.0)) {  return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            #endif
            settings.max_rate[parameter] = value;
    56a2:	f0 e0       	ldi	r31, 0x00	; 0
    56a4:	ee 0f       	add	r30, r30
    56a6:	ff 1f       	adc	r31, r31
    56a8:	ee 0f       	add	r30, r30
    56aa:	ff 1f       	adc	r31, r31
    56ac:	e5 57       	subi	r30, 0x75	; 117
    56ae:	f9 4f       	sbci	r31, 0xF9	; 249
    56b0:	c0 82       	st	Z, r12
    56b2:	d1 82       	std	Z+1, r13	; 0x01
    56b4:	e2 82       	std	Z+2, r14	; 0x02
    56b6:	f3 82       	std	Z+3, r15	; 0x03
            break;
    56b8:	d0 cf       	rjmp	.-96     	; 0x565a <settings_store_global_setting+0x1d8>
          case 2: settings.acceleration[parameter] = value*60*60; break; // Convert to mm/min^2 for grbl internal use.
    56ba:	c8 2f       	mov	r28, r24
    56bc:	d0 e0       	ldi	r29, 0x00	; 0
    56be:	cc 0f       	add	r28, r28
    56c0:	dd 1f       	adc	r29, r29
    56c2:	cc 0f       	add	r28, r28
    56c4:	dd 1f       	adc	r29, r29
    56c6:	c9 56       	subi	r28, 0x69	; 105
    56c8:	d9 4f       	sbci	r29, 0xF9	; 249
    56ca:	20 e0       	ldi	r18, 0x00	; 0
    56cc:	30 e0       	ldi	r19, 0x00	; 0
    56ce:	40 e7       	ldi	r20, 0x70	; 112
    56d0:	52 e4       	ldi	r21, 0x42	; 66
    56d2:	c7 01       	movw	r24, r14
    56d4:	b6 01       	movw	r22, r12
    56d6:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    56da:	20 e0       	ldi	r18, 0x00	; 0
    56dc:	30 e0       	ldi	r19, 0x00	; 0
    56de:	40 e7       	ldi	r20, 0x70	; 112
    56e0:	52 e4       	ldi	r21, 0x42	; 66
    56e2:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    56e6:	68 83       	st	Y, r22
    56e8:	79 83       	std	Y+1, r23	; 0x01
    56ea:	8a 83       	std	Y+2, r24	; 0x02
    56ec:	9b 83       	std	Y+3, r25	; 0x03
    56ee:	b5 cf       	rjmp	.-150    	; 0x565a <settings_store_global_setting+0x1d8>
          case 3: settings.max_travel[parameter] = -value; break;  // Store as negative for grbl internal use.
    56f0:	e8 2f       	mov	r30, r24
    56f2:	f0 e0       	ldi	r31, 0x00	; 0
    56f4:	ee 0f       	add	r30, r30
    56f6:	ff 1f       	adc	r31, r31
    56f8:	ee 0f       	add	r30, r30
    56fa:	ff 1f       	adc	r31, r31
    56fc:	ed 55       	subi	r30, 0x5D	; 93
    56fe:	f9 4f       	sbci	r31, 0xF9	; 249
    5700:	f7 fa       	bst	r15, 7
    5702:	f0 94       	com	r15
    5704:	f7 f8       	bld	r15, 7
    5706:	f0 94       	com	r15
    5708:	c0 82       	st	Z, r12
    570a:	d1 82       	std	Z+1, r13	; 0x01
    570c:	e2 82       	std	Z+2, r14	; 0x02
    570e:	f3 82       	std	Z+3, r15	; 0x03
    5710:	a4 cf       	rjmp	.-184    	; 0x565a <settings_store_global_setting+0x1d8>
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
  return(STATUS_OK);
}
    5712:	df 91       	pop	r29
    5714:	cf 91       	pop	r28
    5716:	ff 90       	pop	r15
    5718:	ef 90       	pop	r14
    571a:	df 90       	pop	r13
    571c:	cf 90       	pop	r12
    571e:	08 95       	ret

00005720 <settings_init>:


// Initialize the config subsystem
void settings_init() {
  if(!read_global_settings()) {
    5720:	0e 94 2b 2a 	call	0x5456	; 0x5456 <read_global_settings>
    5724:	81 11       	cpse	r24, r1
    5726:	08 c0       	rjmp	.+16     	; 0x5738 <settings_init+0x18>
    report_status_message(STATUS_SETTING_READ_FAIL);
    5728:	87 e0       	ldi	r24, 0x07	; 7
    572a:	0e 94 3f 22 	call	0x447e	; 0x447e <report_status_message>
    settings_restore(SETTINGS_RESTORE_ALL); // Force restore all EEPROM data.
    572e:	8f ef       	ldi	r24, 0xFF	; 255
    5730:	0e 94 14 29 	call	0x5228	; 0x5228 <settings_restore>
    report_grbl_settings();
    5734:	0e 94 28 23 	call	0x4650	; 0x4650 <report_grbl_settings>
    5738:	08 95       	ret

0000573a <get_step_pin_mask>:


// Returns step pin mask according to Grbl internal axis indexing.
uint8_t get_step_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    573a:	88 23       	and	r24, r24
    573c:	21 f0       	breq	.+8      	; 0x5746 <get_step_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    573e:	81 30       	cpi	r24, 0x01	; 1
    5740:	21 f0       	breq	.+8      	; 0x574a <get_step_pin_mask+0x10>
  return((1<<Z_STEP_BIT));
    5742:	80 e1       	ldi	r24, 0x10	; 16
    5744:	08 95       	ret


// Returns step pin mask according to Grbl internal axis indexing.
uint8_t get_step_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    5746:	84 e0       	ldi	r24, 0x04	; 4
    5748:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    574a:	88 e0       	ldi	r24, 0x08	; 8
  return((1<<Z_STEP_BIT));
}
    574c:	08 95       	ret

0000574e <get_direction_pin_mask>:


// Returns direction pin mask according to Grbl internal axis indexing.
uint8_t get_direction_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    574e:	88 23       	and	r24, r24
    5750:	21 f0       	breq	.+8      	; 0x575a <get_direction_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    5752:	81 30       	cpi	r24, 0x01	; 1
    5754:	21 f0       	breq	.+8      	; 0x575e <get_direction_pin_mask+0x10>
  return((1<<Z_DIRECTION_BIT));
    5756:	80 e8       	ldi	r24, 0x80	; 128
    5758:	08 95       	ret


// Returns direction pin mask according to Grbl internal axis indexing.
uint8_t get_direction_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    575a:	80 e2       	ldi	r24, 0x20	; 32
    575c:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    575e:	80 e4       	ldi	r24, 0x40	; 64
  return((1<<Z_DIRECTION_BIT));
}
    5760:	08 95       	ret

00005762 <get_limit_pin_mask>:


// Returns limit pin mask according to Grbl internal axis indexing.
uint8_t get_limit_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    5762:	88 23       	and	r24, r24
    5764:	21 f0       	breq	.+8      	; 0x576e <get_limit_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    5766:	81 30       	cpi	r24, 0x01	; 1
    5768:	21 f0       	breq	.+8      	; 0x5772 <get_limit_pin_mask+0x10>
  return((1<<Z_LIMIT_BIT));
    576a:	80 e1       	ldi	r24, 0x10	; 16
    576c:	08 95       	ret


// Returns limit pin mask according to Grbl internal axis indexing.
uint8_t get_limit_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    576e:	82 e0       	ldi	r24, 0x02	; 2
    5770:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    5772:	84 e0       	ldi	r24, 0x04	; 4
  return((1<<Z_LIMIT_BIT));
}
    5774:	08 95       	ret

00005776 <spindle_stop>:

void spindle_stop()
{
  // On the Uno, spindle enable and PWM are shared. Other CPUs have seperate enable pin.
  #ifdef VARIABLE_SPINDLE
    TCCRA_REGISTER &= ~(1<<COMB_BIT); // Disable PWM. Output voltage is zero.
    5776:	e0 eb       	ldi	r30, 0xB0	; 176
    5778:	f0 e0       	ldi	r31, 0x00	; 0
    577a:	80 81       	ld	r24, Z
    577c:	8f 77       	andi	r24, 0x7F	; 127
    577e:	80 83       	st	Z, r24
    5780:	08 95       	ret

00005782 <spindle_init>:
void spindle_init()
{    
  // Configure variable spindle PWM and enable pin, if requried. On the Uno, PWM and enable are
  // combined unless configured otherwise.
  #ifdef VARIABLE_SPINDLE
    SPINDLE_PWM_DDR |= (1<<SPINDLE_PWM_BIT); // Configure as PWM output pin.
    5782:	23 9a       	sbi	0x04, 3	; 4
  #else  
    SPINDLE_ENABLE_DDR |= (1<<SPINDLE_ENABLE_BIT); // Configure as output pin.
  #endif
  
  #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
    SPINDLE_DIRECTION_DDR |= (1<<SPINDLE_DIRECTION_BIT); // Configure as output pin.
    5784:	25 9a       	sbi	0x04, 5	; 4
  #endif
  spindle_stop();
    5786:	0e 94 bb 2b 	call	0x5776	; 0x5776 <spindle_stop>
    578a:	08 95       	ret

0000578c <spindle_set_state>:
  #endif  
}


void spindle_set_state(uint8_t state, float rpm)
{
    578c:	cf 92       	push	r12
    578e:	df 92       	push	r13
    5790:	ef 92       	push	r14
    5792:	ff 92       	push	r15
    5794:	6a 01       	movw	r12, r20
    5796:	7b 01       	movw	r14, r22
  // Halt or set spindle direction and rpm. 
  if (state == SPINDLE_DISABLE) {
    5798:	81 11       	cpse	r24, r1
    579a:	03 c0       	rjmp	.+6      	; 0x57a2 <spindle_set_state+0x16>

    spindle_stop();
    579c:	0e 94 bb 2b 	call	0x5776	; 0x5776 <spindle_stop>
    57a0:	4d c0       	rjmp	.+154    	; 0x583c <spindle_set_state+0xb0>

  } else {

    #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
      if (state == SPINDLE_ENABLE_CW) {
    57a2:	81 30       	cpi	r24, 0x01	; 1
    57a4:	11 f4       	brne	.+4      	; 0x57aa <spindle_set_state+0x1e>
        SPINDLE_DIRECTION_PORT &= ~(1<<SPINDLE_DIRECTION_BIT);
    57a6:	2d 98       	cbi	0x05, 5	; 5
    57a8:	01 c0       	rjmp	.+2      	; 0x57ac <spindle_set_state+0x20>
      } else {
        SPINDLE_DIRECTION_PORT |= (1<<SPINDLE_DIRECTION_BIT);
    57aa:	2d 9a       	sbi	0x05, 5	; 5
      	TCCRA_REGISTER = (1<<COMB_BIT) | (1<<WAVE1_REGISTER) | (1<<WAVE0_REGISTER);
        TCCRB_REGISTER = (TCCRB_REGISTER & 0b11111000) | 0x02 | (1<<WAVE2_REGISTER) | (1<<WAVE3_REGISTER); // set to 1/8 Prescaler
        OCR4A = 0xFFFF; // set the top 16bit value
        uint16_t current_pwm;
      #else
        TCCRA_REGISTER = (1<<COMB_BIT) | (1<<WAVE1_REGISTER) | (1<<WAVE0_REGISTER);
    57ac:	83 e8       	ldi	r24, 0x83	; 131
    57ae:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
        TCCRB_REGISTER = (TCCRB_REGISTER & 0b11111000) | 0x02; // set to 1/8 Prescaler
    57b2:	e1 eb       	ldi	r30, 0xB1	; 177
    57b4:	f0 e0       	ldi	r31, 0x00	; 0
    57b6:	80 81       	ld	r24, Z
    57b8:	88 7f       	andi	r24, 0xF8	; 248
    57ba:	82 60       	ori	r24, 0x02	; 2
    57bc:	80 83       	st	Z, r24
        uint8_t current_pwm;
      #endif

      if (rpm <= 0.0) { spindle_stop(); } // RPM should never be negative, but check anyway.
    57be:	20 e0       	ldi	r18, 0x00	; 0
    57c0:	30 e0       	ldi	r19, 0x00	; 0
    57c2:	a9 01       	movw	r20, r18
    57c4:	c7 01       	movw	r24, r14
    57c6:	b6 01       	movw	r22, r12
    57c8:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    57cc:	18 16       	cp	r1, r24
    57ce:	1c f0       	brlt	.+6      	; 0x57d6 <spindle_set_state+0x4a>
    57d0:	0e 94 bb 2b 	call	0x5776	; 0x5776 <spindle_stop>
    57d4:	33 c0       	rjmp	.+102    	; 0x583c <spindle_set_state+0xb0>
      else {
        #define SPINDLE_RPM_RANGE (SPINDLE_MAX_RPM-SPINDLE_MIN_RPM)
        if ( rpm < SPINDLE_MIN_RPM ) { rpm = 0; } 
    57d6:	20 e0       	ldi	r18, 0x00	; 0
    57d8:	30 e0       	ldi	r19, 0x00	; 0
    57da:	a9 01       	movw	r20, r18
    57dc:	c7 01       	movw	r24, r14
    57de:	b6 01       	movw	r22, r12
    57e0:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    57e4:	88 23       	and	r24, r24
    57e6:	9c f0       	brlt	.+38     	; 0x580e <spindle_set_state+0x82>
        else { 
          rpm -= SPINDLE_MIN_RPM; 
          if ( rpm > SPINDLE_RPM_RANGE ) { rpm = SPINDLE_RPM_RANGE; } // Prevent integer overflow
    57e8:	20 e0       	ldi	r18, 0x00	; 0
    57ea:	30 e0       	ldi	r19, 0x00	; 0
    57ec:	4a e7       	ldi	r20, 0x7A	; 122
    57ee:	54 e4       	ldi	r21, 0x44	; 68
    57f0:	c7 01       	movw	r24, r14
    57f2:	b6 01       	movw	r22, r12
    57f4:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    57f8:	18 16       	cp	r1, r24
    57fa:	64 f4       	brge	.+24     	; 0x5814 <spindle_set_state+0x88>
    57fc:	0f 2e       	mov	r0, r31
    57fe:	c1 2c       	mov	r12, r1
    5800:	d1 2c       	mov	r13, r1
    5802:	fa e7       	ldi	r31, 0x7A	; 122
    5804:	ef 2e       	mov	r14, r31
    5806:	f4 e4       	ldi	r31, 0x44	; 68
    5808:	ff 2e       	mov	r15, r31
    580a:	f0 2d       	mov	r31, r0
    580c:	03 c0       	rjmp	.+6      	; 0x5814 <spindle_set_state+0x88>
      #endif

      if (rpm <= 0.0) { spindle_stop(); } // RPM should never be negative, but check anyway.
      else {
        #define SPINDLE_RPM_RANGE (SPINDLE_MAX_RPM-SPINDLE_MIN_RPM)
        if ( rpm < SPINDLE_MIN_RPM ) { rpm = 0; } 
    580e:	c1 2c       	mov	r12, r1
    5810:	d1 2c       	mov	r13, r1
    5812:	76 01       	movw	r14, r12
        else { 
          rpm -= SPINDLE_MIN_RPM; 
          if ( rpm > SPINDLE_RPM_RANGE ) { rpm = SPINDLE_RPM_RANGE; } // Prevent integer overflow
        }
        current_pwm = floor( rpm*(PWM_MAX_VALUE/SPINDLE_RPM_RANGE) + 0.5);
    5814:	2c e5       	ldi	r18, 0x5C	; 92
    5816:	3f e8       	ldi	r19, 0x8F	; 143
    5818:	42 e8       	ldi	r20, 0x82	; 130
    581a:	5e e3       	ldi	r21, 0x3E	; 62
    581c:	c7 01       	movw	r24, r14
    581e:	b6 01       	movw	r22, r12
    5820:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    5824:	20 e0       	ldi	r18, 0x00	; 0
    5826:	30 e0       	ldi	r19, 0x00	; 0
    5828:	40 e0       	ldi	r20, 0x00	; 0
    582a:	5f e3       	ldi	r21, 0x3F	; 63
    582c:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    5830:	0e 94 8e 3a 	call	0x751c	; 0x751c <floor>
    5834:	0e 94 22 3a 	call	0x7444	; 0x7444 <__fixunssfsi>
        #ifdef MINIMUM_SPINDLE_PWM
          if (current_pwm < MINIMUM_SPINDLE_PWM) { current_pwm = MINIMUM_SPINDLE_PWM; }
        #endif
        OCR_REGISTER = current_pwm; // Set PWM pin output
    5838:	60 93 b3 00 	sts	0x00B3, r22	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7e00b3>
        SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
      #endif
    #endif

  }
}
    583c:	ff 90       	pop	r15
    583e:	ef 90       	pop	r14
    5840:	df 90       	pop	r13
    5842:	cf 90       	pop	r12
    5844:	08 95       	ret

00005846 <spindle_run>:


void spindle_run(uint8_t state, float rpm)
{
    5846:	cf 92       	push	r12
    5848:	df 92       	push	r13
    584a:	ef 92       	push	r14
    584c:	ff 92       	push	r15
    584e:	cf 93       	push	r28
  if (sys.state == STATE_CHECK_MODE) { return; }
    5850:	90 91 a1 05 	lds	r25, 0x05A1	; 0x8005a1 <sys+0x1>
    5854:	92 30       	cpi	r25, 0x02	; 2
    5856:	51 f0       	breq	.+20     	; 0x586c <spindle_run+0x26>
    5858:	6a 01       	movw	r12, r20
    585a:	7b 01       	movw	r14, r22
    585c:	c8 2f       	mov	r28, r24
  protocol_buffer_synchronize(); // Empty planner buffer to ensure spindle is set when programmed.  
    585e:	0e 94 2a 22 	call	0x4454	; 0x4454 <protocol_buffer_synchronize>
  spindle_set_state(state, rpm);
    5862:	b7 01       	movw	r22, r14
    5864:	a6 01       	movw	r20, r12
    5866:	8c 2f       	mov	r24, r28
    5868:	0e 94 c6 2b 	call	0x578c	; 0x578c <spindle_set_state>
}
    586c:	cf 91       	pop	r28
    586e:	ff 90       	pop	r15
    5870:	ef 90       	pop	r14
    5872:	df 90       	pop	r13
    5874:	cf 90       	pop	r12
    5876:	08 95       	ret

00005878 <st_wake_up>:
// Stepper state initialization. Cycle should only start if the st.cycle_start flag is
// enabled. Startup init and limits call this function but shouldn't start the cycle.
void st_wake_up() 
{
  // Enable stepper drivers.
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    5878:	80 91 bc 06 	lds	r24, 0x06BC	; 0x8006bc <settings+0x3d>
    587c:	82 ff       	sbrs	r24, 2
    587e:	02 c0       	rjmp	.+4      	; 0x5884 <st_wake_up+0xc>
    5880:	28 9a       	sbi	0x05, 0	; 5
    5882:	01 c0       	rjmp	.+2      	; 0x5886 <st_wake_up+0xe>
  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    5884:	28 98       	cbi	0x05, 0	; 5

  if (sys.state & (STATE_CYCLE | STATE_HOMING)){
    5886:	80 91 a1 05 	lds	r24, 0x05A1	; 0x8005a1 <sys+0x1>
    588a:	8c 70       	andi	r24, 0x0C	; 12
    588c:	99 f0       	breq	.+38     	; 0x58b4 <st_wake_up+0x3c>
    // Initialize stepper output bits
    st.dir_outbits = dir_port_invert_mask; 
    588e:	e9 e8       	ldi	r30, 0x89	; 137
    5890:	f4 e0       	ldi	r31, 0x04	; 4
    5892:	80 91 84 04 	lds	r24, 0x0484	; 0x800484 <dir_port_invert_mask>
    5896:	87 87       	std	Z+15, r24	; 0x0f
    st.step_outbits = step_port_invert_mask;
    5898:	80 91 85 04 	lds	r24, 0x0485	; 0x800485 <step_port_invert_mask>
    589c:	86 87       	std	Z+14, r24	; 0x0e
      st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) >> 3);
      // Set delay between direction pin write and step command.
      OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);
    #else // Normal operation
      // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.
      st.step_pulse_time = -(((settings.pulse_microseconds-2)*TICKS_PER_MICROSECOND) >> 3);
    589e:	80 91 af 06 	lds	r24, 0x06AF	; 0x8006af <settings+0x30>
    58a2:	88 0f       	add	r24, r24
    58a4:	84 50       	subi	r24, 0x04	; 4
    58a6:	81 95       	neg	r24
    58a8:	85 87       	std	Z+13, r24	; 0x0d
    #endif

    // Enable Stepper Driver Interrupt
    TIMSK1 |= (1<<OCIE1A);
    58aa:	ef e6       	ldi	r30, 0x6F	; 111
    58ac:	f0 e0       	ldi	r31, 0x00	; 0
    58ae:	80 81       	ld	r24, Z
    58b0:	82 60       	ori	r24, 0x02	; 2
    58b2:	80 83       	st	Z, r24
    58b4:	08 95       	ret

000058b6 <st_go_idle>:

// Stepper shutdown
void st_go_idle() 
{
  // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.
  TIMSK1 &= ~(1<<OCIE1A); // Disable Timer1 interrupt
    58b6:	ef e6       	ldi	r30, 0x6F	; 111
    58b8:	f0 e0       	ldi	r31, 0x00	; 0
    58ba:	80 81       	ld	r24, Z
    58bc:	8d 7f       	andi	r24, 0xFD	; 253
    58be:	80 83       	st	Z, r24
  TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Reset clock to no prescaling.
    58c0:	e1 e8       	ldi	r30, 0x81	; 129
    58c2:	f0 e0       	ldi	r31, 0x00	; 0
    58c4:	80 81       	ld	r24, Z
    58c6:	88 7f       	andi	r24, 0xF8	; 248
    58c8:	81 60       	ori	r24, 0x01	; 1
    58ca:	80 83       	st	Z, r24
  busy = false;
    58cc:	10 92 83 04 	sts	0x0483, r1	; 0x800483 <busy>
  
  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
  if (((settings.stepper_idle_lock_time != 0xff) || sys_rt_exec_alarm) && sys.state != STATE_HOMING) {
    58d0:	80 91 b2 06 	lds	r24, 0x06B2	; 0x8006b2 <settings+0x33>
    58d4:	8f 3f       	cpi	r24, 0xFF	; 255
    58d6:	21 f4       	brne	.+8      	; 0x58e0 <st_go_idle+0x2a>
    58d8:	90 91 27 05 	lds	r25, 0x0527	; 0x800527 <sys_rt_exec_alarm>
    58dc:	99 23       	and	r25, r25
    58de:	79 f0       	breq	.+30     	; 0x58fe <st_go_idle+0x48>
    58e0:	90 91 a1 05 	lds	r25, 0x05A1	; 0x8005a1 <sys+0x1>
    58e4:	94 30       	cpi	r25, 0x04	; 4
    58e6:	59 f0       	breq	.+22     	; 0x58fe <st_go_idle+0x48>
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    58e8:	90 e0       	ldi	r25, 0x00	; 0
    58ea:	0e 94 2b 19 	call	0x3256	; 0x3256 <delay_ms>
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    58ee:	80 91 bc 06 	lds	r24, 0x06BC	; 0x8006bc <settings+0x3d>
    58f2:	82 fd       	sbrc	r24, 2
    58f4:	02 c0       	rjmp	.+4      	; 0x58fa <st_go_idle+0x44>
  if (pin_state) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    58f6:	28 9a       	sbi	0x05, 0	; 5
    58f8:	08 95       	ret
  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    58fa:	28 98       	cbi	0x05, 0	; 5
}
    58fc:	08 95       	ret
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    58fe:	80 91 bc 06 	lds	r24, 0x06BC	; 0x8006bc <settings+0x3d>
    5902:	82 ff       	sbrs	r24, 2
    5904:	fa cf       	rjmp	.-12     	; 0x58fa <st_go_idle+0x44>
    5906:	f7 cf       	rjmp	.-18     	; 0x58f6 <st_go_idle+0x40>

00005908 <__vector_11>:
*/
// TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use smaller
// int8 variables and update position counters only when a segment completes. This can get complicated 
// with probing and homing cycles that require true real-time positions.
ISR(TIMER1_COMPA_vect)
{        
    5908:	1f 92       	push	r1
    590a:	0f 92       	push	r0
    590c:	0f b6       	in	r0, 0x3f	; 63
    590e:	0f 92       	push	r0
    5910:	11 24       	eor	r1, r1
    5912:	0f 93       	push	r16
    5914:	1f 93       	push	r17
    5916:	2f 93       	push	r18
    5918:	3f 93       	push	r19
    591a:	4f 93       	push	r20
    591c:	5f 93       	push	r21
    591e:	6f 93       	push	r22
    5920:	7f 93       	push	r23
    5922:	8f 93       	push	r24
    5924:	9f 93       	push	r25
    5926:	af 93       	push	r26
    5928:	bf 93       	push	r27
    592a:	cf 93       	push	r28
    592c:	df 93       	push	r29
    592e:	ef 93       	push	r30
    5930:	ff 93       	push	r31
// SPINDLE_ENABLE_PORT ^= 1<<SPINDLE_ENABLE_BIT; // Debug: Used to time ISR
  if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
    5932:	80 91 83 04 	lds	r24, 0x0483	; 0x800483 <busy>
    5936:	81 11       	cpse	r24, r1
    5938:	b5 c1       	rjmp	.+874    	; 0x5ca4 <__vector_11+0x39c>
  
  // Set the direction pins a couple of nanoseconds before we step the steppers
  DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK);
    593a:	8b b1       	in	r24, 0x0b	; 11
    593c:	e9 e8       	ldi	r30, 0x89	; 137
    593e:	f4 e0       	ldi	r31, 0x04	; 4
    5940:	97 85       	ldd	r25, Z+15	; 0x0f
    5942:	90 7e       	andi	r25, 0xE0	; 224
    5944:	8f 71       	andi	r24, 0x1F	; 31
    5946:	89 2b       	or	r24, r25
    5948:	8b b9       	out	0x0b, r24	; 11

  // Then pulse the stepping pins
  #ifdef STEP_PULSE_DELAY
    st.step_bits = (STEP_PORT & ~STEP_MASK) | st.step_outbits; // Store out_bits to prevent overwriting.
  #else  // Normal operation
    STEP_PORT = (STEP_PORT & ~STEP_MASK) | st.step_outbits;
    594a:	8b b1       	in	r24, 0x0b	; 11
    594c:	83 7e       	andi	r24, 0xE3	; 227
    594e:	96 85       	ldd	r25, Z+14	; 0x0e
    5950:	89 2b       	or	r24, r25
    5952:	8b b9       	out	0x0b, r24	; 11
  #endif  

  // Enable step pulse reset timer so that The Stepper Port Reset Interrupt can reset the signal after
  // exactly settings.pulse_microseconds microseconds, independent of the main Timer1 prescaler.
  TCNT0 = st.step_pulse_time; // Reload Timer0 counter
    5954:	85 85       	ldd	r24, Z+13	; 0x0d
    5956:	86 bd       	out	0x26, r24	; 38
  TCCR0B = (1<<CS01); // Begin Timer0. Full speed, 1/8 prescaler
    5958:	82 e0       	ldi	r24, 0x02	; 2
    595a:	85 bd       	out	0x25, r24	; 37

  busy = true;
    595c:	81 e0       	ldi	r24, 0x01	; 1
    595e:	80 93 83 04 	sts	0x0483, r24	; 0x800483 <busy>
  sei(); // Re-enable interrupts to allow Stepper Port Reset Interrupt to fire on-time. 
    5962:	78 94       	sei
         // NOTE: The remaining code in this ISR will finish before returning to main program.
    
  // If there is no step segment, attempt to pop one from the stepper buffer
  if (st.exec_segment == NULL) {
    5964:	81 a1       	ldd	r24, Z+33	; 0x21
    5966:	92 a1       	ldd	r25, Z+34	; 0x22
    5968:	89 2b       	or	r24, r25
    596a:	09 f0       	breq	.+2      	; 0x596e <__vector_11+0x66>
    596c:	92 c0       	rjmp	.+292    	; 0x5a92 <__vector_11+0x18a>
    // Anything in the buffer? If so, load and initialize next step segment.
    if (segment_buffer_head != segment_buffer_tail) {
    596e:	80 91 88 04 	lds	r24, 0x0488	; 0x800488 <segment_buffer_tail>
    5972:	90 91 87 04 	lds	r25, 0x0487	; 0x800487 <segment_buffer_head>
    5976:	98 17       	cp	r25, r24
    5978:	09 f4       	brne	.+2      	; 0x597c <__vector_11+0x74>
    597a:	80 c0       	rjmp	.+256    	; 0x5a7c <__vector_11+0x174>
      // Initialize new step segment and load number of steps to execute
      st.exec_segment = &segment_buffer[segment_buffer_tail];
    597c:	80 91 88 04 	lds	r24, 0x0488	; 0x800488 <segment_buffer_tail>
    5980:	90 e0       	ldi	r25, 0x00	; 0
    5982:	ef 01       	movw	r28, r30
    5984:	fc 01       	movw	r30, r24
    5986:	ee 0f       	add	r30, r30
    5988:	ff 1f       	adc	r31, r31
    598a:	df 01       	movw	r26, r30
    598c:	a8 0f       	add	r26, r24
    598e:	b9 1f       	adc	r27, r25
    5990:	aa 0f       	add	r26, r26
    5992:	bb 1f       	adc	r27, r27
    5994:	a4 55       	subi	r26, 0x54	; 84
    5996:	bb 4f       	sbci	r27, 0xFB	; 251
    5998:	ba a3       	std	Y+34, r27	; 0x22
    599a:	a9 a3       	std	Y+33, r26	; 0x21
        // With AMASS is disabled, set timer prescaler for segments with slow step frequencies (< 250Hz).
        TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (st.exec_segment->prescaler<<CS10);
      #endif

      // Initialize step segment timing per step and load number of steps to execute.
      OCR1A = st.exec_segment->cycles_per_tick;
    599c:	fd 01       	movw	r30, r26
    599e:	83 81       	ldd	r24, Z+3	; 0x03
    59a0:	94 81       	ldd	r25, Z+4	; 0x04
    59a2:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    59a6:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
      st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
    59aa:	8d 91       	ld	r24, X+
    59ac:	9c 91       	ld	r25, X
    59ae:	11 97       	sbiw	r26, 0x01	; 1
    59b0:	9d 8f       	std	Y+29, r25	; 0x1d
    59b2:	8c 8f       	std	Y+28, r24	; 0x1c
      // If the new segment starts a new planner block, initialize stepper variables and counters.
      // NOTE: When the segment data index changes, this indicates a new planner block.
      if ( st.exec_block_index != st.exec_segment->st_block_index ) {
    59b4:	12 96       	adiw	r26, 0x02	; 2
    59b6:	ec 91       	ld	r30, X
    59b8:	12 97       	sbiw	r26, 0x02	; 2
    59ba:	8e 8d       	ldd	r24, Y+30	; 0x1e
    59bc:	8e 17       	cp	r24, r30
    59be:	e9 f0       	breq	.+58     	; 0x59fa <__vector_11+0xf2>
        st.exec_block_index = st.exec_segment->st_block_index;
    59c0:	ee 8f       	std	Y+30, r30	; 0x1e
        st.exec_block = &st_block_buffer[st.exec_block_index];
    59c2:	01 e1       	ldi	r16, 0x11	; 17
    59c4:	e0 9f       	mul	r30, r16
    59c6:	f0 01       	movw	r30, r0
    59c8:	11 24       	eor	r1, r1
    59ca:	e0 53       	subi	r30, 0x30	; 48
    59cc:	fb 4f       	sbci	r31, 0xFB	; 251
    59ce:	f8 a3       	std	Y+32, r31	; 0x20
    59d0:	ef 8f       	std	Y+31, r30	; 0x1f
        
        // Initialize Bresenham line and distance counters
        st.counter_x = st.counter_y = st.counter_z = (st.exec_block->step_event_count >> 1);
    59d2:	45 85       	ldd	r20, Z+13	; 0x0d
    59d4:	56 85       	ldd	r21, Z+14	; 0x0e
    59d6:	67 85       	ldd	r22, Z+15	; 0x0f
    59d8:	70 89       	ldd	r23, Z+16	; 0x10
    59da:	76 95       	lsr	r23
    59dc:	67 95       	ror	r22
    59de:	57 95       	ror	r21
    59e0:	47 95       	ror	r20
    59e2:	48 87       	std	Y+8, r20	; 0x08
    59e4:	59 87       	std	Y+9, r21	; 0x09
    59e6:	6a 87       	std	Y+10, r22	; 0x0a
    59e8:	7b 87       	std	Y+11, r23	; 0x0b
    59ea:	4c 83       	std	Y+4, r20	; 0x04
    59ec:	5d 83       	std	Y+5, r21	; 0x05
    59ee:	6e 83       	std	Y+6, r22	; 0x06
    59f0:	7f 83       	std	Y+7, r23	; 0x07
    59f2:	48 83       	st	Y, r20
    59f4:	59 83       	std	Y+1, r21	; 0x01
    59f6:	6a 83       	std	Y+2, r22	; 0x02
    59f8:	7b 83       	std	Y+3, r23	; 0x03
      }
      st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask; 
    59fa:	e9 e8       	ldi	r30, 0x89	; 137
    59fc:	f4 e0       	ldi	r31, 0x04	; 4
    59fe:	c7 8d       	ldd	r28, Z+31	; 0x1f
    5a00:	d0 a1       	ldd	r29, Z+32	; 0x20
    5a02:	98 81       	ld	r25, Y
    5a04:	80 91 84 04 	lds	r24, 0x0484	; 0x800484 <dir_port_invert_mask>
    5a08:	89 27       	eor	r24, r25
    5a0a:	87 87       	std	Z+15, r24	; 0x0f

      #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
        // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
        st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
    5a0c:	49 81       	ldd	r20, Y+1	; 0x01
    5a0e:	5a 81       	ldd	r21, Y+2	; 0x02
    5a10:	6b 81       	ldd	r22, Y+3	; 0x03
    5a12:	7c 81       	ldd	r23, Y+4	; 0x04
    5a14:	15 96       	adiw	r26, 0x05	; 5
    5a16:	0c 90       	ld	r0, X
    5a18:	15 97       	sbiw	r26, 0x05	; 5
    5a1a:	04 c0       	rjmp	.+8      	; 0x5a24 <__vector_11+0x11c>
    5a1c:	76 95       	lsr	r23
    5a1e:	67 95       	ror	r22
    5a20:	57 95       	ror	r21
    5a22:	47 95       	ror	r20
    5a24:	0a 94       	dec	r0
    5a26:	d2 f7       	brpl	.-12     	; 0x5a1c <__vector_11+0x114>
    5a28:	40 8b       	std	Z+16, r20	; 0x10
    5a2a:	51 8b       	std	Z+17, r21	; 0x11
    5a2c:	62 8b       	std	Z+18, r22	; 0x12
    5a2e:	73 8b       	std	Z+19, r23	; 0x13
        st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
    5a30:	4d 81       	ldd	r20, Y+5	; 0x05
    5a32:	5e 81       	ldd	r21, Y+6	; 0x06
    5a34:	6f 81       	ldd	r22, Y+7	; 0x07
    5a36:	78 85       	ldd	r23, Y+8	; 0x08
    5a38:	15 96       	adiw	r26, 0x05	; 5
    5a3a:	0c 90       	ld	r0, X
    5a3c:	15 97       	sbiw	r26, 0x05	; 5
    5a3e:	04 c0       	rjmp	.+8      	; 0x5a48 <__vector_11+0x140>
    5a40:	76 95       	lsr	r23
    5a42:	67 95       	ror	r22
    5a44:	57 95       	ror	r21
    5a46:	47 95       	ror	r20
    5a48:	0a 94       	dec	r0
    5a4a:	d2 f7       	brpl	.-12     	; 0x5a40 <__vector_11+0x138>
    5a4c:	44 8b       	std	Z+20, r20	; 0x14
    5a4e:	55 8b       	std	Z+21, r21	; 0x15
    5a50:	66 8b       	std	Z+22, r22	; 0x16
    5a52:	77 8b       	std	Z+23, r23	; 0x17
        st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
    5a54:	49 85       	ldd	r20, Y+9	; 0x09
    5a56:	5a 85       	ldd	r21, Y+10	; 0x0a
    5a58:	6b 85       	ldd	r22, Y+11	; 0x0b
    5a5a:	7c 85       	ldd	r23, Y+12	; 0x0c
    5a5c:	8a 01       	movw	r16, r20
    5a5e:	9b 01       	movw	r18, r22
    5a60:	15 96       	adiw	r26, 0x05	; 5
    5a62:	0c 90       	ld	r0, X
    5a64:	04 c0       	rjmp	.+8      	; 0x5a6e <__vector_11+0x166>
    5a66:	36 95       	lsr	r19
    5a68:	27 95       	ror	r18
    5a6a:	17 95       	ror	r17
    5a6c:	07 95       	ror	r16
    5a6e:	0a 94       	dec	r0
    5a70:	d2 f7       	brpl	.-12     	; 0x5a66 <__vector_11+0x15e>
    5a72:	00 8f       	std	Z+24, r16	; 0x18
    5a74:	11 8f       	std	Z+25, r17	; 0x19
    5a76:	22 8f       	std	Z+26, r18	; 0x1a
    5a78:	33 8f       	std	Z+27, r19	; 0x1b
    5a7a:	0b c0       	rjmp	.+22     	; 0x5a92 <__vector_11+0x18a>
      #endif
      
    } else {
      // Segment buffer empty. Shutdown.
      st_go_idle();
    5a7c:	0e 94 5b 2c 	call	0x58b6	; 0x58b6 <st_go_idle>
      bit_true_atomic(sys_rt_exec_state,EXEC_CYCLE_STOP); // Flag main program for cycle end
    5a80:	9f b7       	in	r25, 0x3f	; 63
    5a82:	f8 94       	cli
    5a84:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    5a88:	84 60       	ori	r24, 0x04	; 4
    5a8a:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <sys_rt_exec_state>
    5a8e:	9f bf       	out	0x3f, r25	; 63
      return; // Nothing to do but exit.
    5a90:	09 c1       	rjmp	.+530    	; 0x5ca4 <__vector_11+0x39c>
    }  
  }
  
  
  // Check probing state.
  probe_state_monitor();
    5a92:	0e 94 2d 20 	call	0x405a	; 0x405a <probe_state_monitor>
   
  // Reset step out bits.
  st.step_outbits = 0; 
    5a96:	e9 e8       	ldi	r30, 0x89	; 137
    5a98:	f4 e0       	ldi	r31, 0x04	; 4
    5a9a:	16 86       	std	Z+14, r1	; 0x0e

  // Execute step displacement profile by Bresenham line algorithm
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_x += st.steps[X_AXIS];
    5a9c:	40 81       	ld	r20, Z
    5a9e:	51 81       	ldd	r21, Z+1	; 0x01
    5aa0:	62 81       	ldd	r22, Z+2	; 0x02
    5aa2:	73 81       	ldd	r23, Z+3	; 0x03
    5aa4:	80 89       	ldd	r24, Z+16	; 0x10
    5aa6:	91 89       	ldd	r25, Z+17	; 0x11
    5aa8:	a2 89       	ldd	r26, Z+18	; 0x12
    5aaa:	b3 89       	ldd	r27, Z+19	; 0x13
    5aac:	84 0f       	add	r24, r20
    5aae:	95 1f       	adc	r25, r21
    5ab0:	a6 1f       	adc	r26, r22
    5ab2:	b7 1f       	adc	r27, r23
    5ab4:	80 83       	st	Z, r24
    5ab6:	91 83       	std	Z+1, r25	; 0x01
    5ab8:	a2 83       	std	Z+2, r26	; 0x02
    5aba:	b3 83       	std	Z+3, r27	; 0x03
  #else
    st.counter_x += st.exec_block->steps[X_AXIS];
  #endif  
  if (st.counter_x > st.exec_block->step_event_count) {
    5abc:	07 8c       	ldd	r0, Z+31	; 0x1f
    5abe:	f0 a1       	ldd	r31, Z+32	; 0x20
    5ac0:	e0 2d       	mov	r30, r0
    5ac2:	45 85       	ldd	r20, Z+13	; 0x0d
    5ac4:	56 85       	ldd	r21, Z+14	; 0x0e
    5ac6:	67 85       	ldd	r22, Z+15	; 0x0f
    5ac8:	70 89       	ldd	r23, Z+16	; 0x10
    5aca:	48 17       	cp	r20, r24
    5acc:	59 07       	cpc	r21, r25
    5ace:	6a 07       	cpc	r22, r26
    5ad0:	7b 07       	cpc	r23, r27
    5ad2:	70 f5       	brcc	.+92     	; 0x5b30 <__vector_11+0x228>
    st.step_outbits |= (1<<X_STEP_BIT);
    5ad4:	c9 e8       	ldi	r28, 0x89	; 137
    5ad6:	d4 e0       	ldi	r29, 0x04	; 4
    5ad8:	24 e0       	ldi	r18, 0x04	; 4
    5ada:	2e 87       	std	Y+14, r18	; 0x0e
    st.counter_x -= st.exec_block->step_event_count;
    5adc:	45 85       	ldd	r20, Z+13	; 0x0d
    5ade:	56 85       	ldd	r21, Z+14	; 0x0e
    5ae0:	67 85       	ldd	r22, Z+15	; 0x0f
    5ae2:	70 89       	ldd	r23, Z+16	; 0x10
    5ae4:	84 1b       	sub	r24, r20
    5ae6:	95 0b       	sbc	r25, r21
    5ae8:	a6 0b       	sbc	r26, r22
    5aea:	b7 0b       	sbc	r27, r23
    5aec:	88 83       	st	Y, r24
    5aee:	99 83       	std	Y+1, r25	; 0x01
    5af0:	aa 83       	std	Y+2, r26	; 0x02
    5af2:	bb 83       	std	Y+3, r27	; 0x03
    if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys.position[X_AXIS]--; }
    5af4:	80 81       	ld	r24, Z
    5af6:	85 ff       	sbrs	r24, 5
    5af8:	0e c0       	rjmp	.+28     	; 0x5b16 <__vector_11+0x20e>
    5afa:	c0 ea       	ldi	r28, 0xA0	; 160
    5afc:	d5 e0       	ldi	r29, 0x05	; 5
    5afe:	8c 81       	ldd	r24, Y+4	; 0x04
    5b00:	9d 81       	ldd	r25, Y+5	; 0x05
    5b02:	ae 81       	ldd	r26, Y+6	; 0x06
    5b04:	bf 81       	ldd	r27, Y+7	; 0x07
    5b06:	01 97       	sbiw	r24, 0x01	; 1
    5b08:	a1 09       	sbc	r26, r1
    5b0a:	b1 09       	sbc	r27, r1
    5b0c:	8c 83       	std	Y+4, r24	; 0x04
    5b0e:	9d 83       	std	Y+5, r25	; 0x05
    5b10:	ae 83       	std	Y+6, r26	; 0x06
    5b12:	bf 83       	std	Y+7, r27	; 0x07
    5b14:	0d c0       	rjmp	.+26     	; 0x5b30 <__vector_11+0x228>
    else { sys.position[X_AXIS]++; }
    5b16:	c0 ea       	ldi	r28, 0xA0	; 160
    5b18:	d5 e0       	ldi	r29, 0x05	; 5
    5b1a:	8c 81       	ldd	r24, Y+4	; 0x04
    5b1c:	9d 81       	ldd	r25, Y+5	; 0x05
    5b1e:	ae 81       	ldd	r26, Y+6	; 0x06
    5b20:	bf 81       	ldd	r27, Y+7	; 0x07
    5b22:	01 96       	adiw	r24, 0x01	; 1
    5b24:	a1 1d       	adc	r26, r1
    5b26:	b1 1d       	adc	r27, r1
    5b28:	8c 83       	std	Y+4, r24	; 0x04
    5b2a:	9d 83       	std	Y+5, r25	; 0x05
    5b2c:	ae 83       	std	Y+6, r26	; 0x06
    5b2e:	bf 83       	std	Y+7, r27	; 0x07
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_y += st.steps[Y_AXIS];
    5b30:	c9 e8       	ldi	r28, 0x89	; 137
    5b32:	d4 e0       	ldi	r29, 0x04	; 4
    5b34:	4c 81       	ldd	r20, Y+4	; 0x04
    5b36:	5d 81       	ldd	r21, Y+5	; 0x05
    5b38:	6e 81       	ldd	r22, Y+6	; 0x06
    5b3a:	7f 81       	ldd	r23, Y+7	; 0x07
    5b3c:	8c 89       	ldd	r24, Y+20	; 0x14
    5b3e:	9d 89       	ldd	r25, Y+21	; 0x15
    5b40:	ae 89       	ldd	r26, Y+22	; 0x16
    5b42:	bf 89       	ldd	r27, Y+23	; 0x17
    5b44:	84 0f       	add	r24, r20
    5b46:	95 1f       	adc	r25, r21
    5b48:	a6 1f       	adc	r26, r22
    5b4a:	b7 1f       	adc	r27, r23
    5b4c:	8c 83       	std	Y+4, r24	; 0x04
    5b4e:	9d 83       	std	Y+5, r25	; 0x05
    5b50:	ae 83       	std	Y+6, r26	; 0x06
    5b52:	bf 83       	std	Y+7, r27	; 0x07
  #else
    st.counter_y += st.exec_block->steps[Y_AXIS];
  #endif    
  if (st.counter_y > st.exec_block->step_event_count) {
    5b54:	45 85       	ldd	r20, Z+13	; 0x0d
    5b56:	56 85       	ldd	r21, Z+14	; 0x0e
    5b58:	67 85       	ldd	r22, Z+15	; 0x0f
    5b5a:	70 89       	ldd	r23, Z+16	; 0x10
    5b5c:	48 17       	cp	r20, r24
    5b5e:	59 07       	cpc	r21, r25
    5b60:	6a 07       	cpc	r22, r26
    5b62:	7b 07       	cpc	r23, r27
    5b64:	68 f5       	brcc	.+90     	; 0x5bc0 <__vector_11+0x2b8>
    st.step_outbits |= (1<<Y_STEP_BIT);
    5b66:	2e 85       	ldd	r18, Y+14	; 0x0e
    5b68:	28 60       	ori	r18, 0x08	; 8
    5b6a:	2e 87       	std	Y+14, r18	; 0x0e
    st.counter_y -= st.exec_block->step_event_count;
    5b6c:	45 85       	ldd	r20, Z+13	; 0x0d
    5b6e:	56 85       	ldd	r21, Z+14	; 0x0e
    5b70:	67 85       	ldd	r22, Z+15	; 0x0f
    5b72:	70 89       	ldd	r23, Z+16	; 0x10
    5b74:	84 1b       	sub	r24, r20
    5b76:	95 0b       	sbc	r25, r21
    5b78:	a6 0b       	sbc	r26, r22
    5b7a:	b7 0b       	sbc	r27, r23
    5b7c:	8c 83       	std	Y+4, r24	; 0x04
    5b7e:	9d 83       	std	Y+5, r25	; 0x05
    5b80:	ae 83       	std	Y+6, r26	; 0x06
    5b82:	bf 83       	std	Y+7, r27	; 0x07
    if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys.position[Y_AXIS]--; }
    5b84:	80 81       	ld	r24, Z
    5b86:	86 ff       	sbrs	r24, 6
    5b88:	0e c0       	rjmp	.+28     	; 0x5ba6 <__vector_11+0x29e>
    5b8a:	c0 ea       	ldi	r28, 0xA0	; 160
    5b8c:	d5 e0       	ldi	r29, 0x05	; 5
    5b8e:	88 85       	ldd	r24, Y+8	; 0x08
    5b90:	99 85       	ldd	r25, Y+9	; 0x09
    5b92:	aa 85       	ldd	r26, Y+10	; 0x0a
    5b94:	bb 85       	ldd	r27, Y+11	; 0x0b
    5b96:	01 97       	sbiw	r24, 0x01	; 1
    5b98:	a1 09       	sbc	r26, r1
    5b9a:	b1 09       	sbc	r27, r1
    5b9c:	88 87       	std	Y+8, r24	; 0x08
    5b9e:	99 87       	std	Y+9, r25	; 0x09
    5ba0:	aa 87       	std	Y+10, r26	; 0x0a
    5ba2:	bb 87       	std	Y+11, r27	; 0x0b
    5ba4:	0d c0       	rjmp	.+26     	; 0x5bc0 <__vector_11+0x2b8>
    else { sys.position[Y_AXIS]++; }
    5ba6:	c0 ea       	ldi	r28, 0xA0	; 160
    5ba8:	d5 e0       	ldi	r29, 0x05	; 5
    5baa:	88 85       	ldd	r24, Y+8	; 0x08
    5bac:	99 85       	ldd	r25, Y+9	; 0x09
    5bae:	aa 85       	ldd	r26, Y+10	; 0x0a
    5bb0:	bb 85       	ldd	r27, Y+11	; 0x0b
    5bb2:	01 96       	adiw	r24, 0x01	; 1
    5bb4:	a1 1d       	adc	r26, r1
    5bb6:	b1 1d       	adc	r27, r1
    5bb8:	88 87       	std	Y+8, r24	; 0x08
    5bba:	99 87       	std	Y+9, r25	; 0x09
    5bbc:	aa 87       	std	Y+10, r26	; 0x0a
    5bbe:	bb 87       	std	Y+11, r27	; 0x0b
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_z += st.steps[Z_AXIS];
    5bc0:	c9 e8       	ldi	r28, 0x89	; 137
    5bc2:	d4 e0       	ldi	r29, 0x04	; 4
    5bc4:	48 85       	ldd	r20, Y+8	; 0x08
    5bc6:	59 85       	ldd	r21, Y+9	; 0x09
    5bc8:	6a 85       	ldd	r22, Y+10	; 0x0a
    5bca:	7b 85       	ldd	r23, Y+11	; 0x0b
    5bcc:	88 8d       	ldd	r24, Y+24	; 0x18
    5bce:	99 8d       	ldd	r25, Y+25	; 0x19
    5bd0:	aa 8d       	ldd	r26, Y+26	; 0x1a
    5bd2:	bb 8d       	ldd	r27, Y+27	; 0x1b
    5bd4:	84 0f       	add	r24, r20
    5bd6:	95 1f       	adc	r25, r21
    5bd8:	a6 1f       	adc	r26, r22
    5bda:	b7 1f       	adc	r27, r23
    5bdc:	88 87       	std	Y+8, r24	; 0x08
    5bde:	99 87       	std	Y+9, r25	; 0x09
    5be0:	aa 87       	std	Y+10, r26	; 0x0a
    5be2:	bb 87       	std	Y+11, r27	; 0x0b
  #else
    st.counter_z += st.exec_block->steps[Z_AXIS];
  #endif  
  if (st.counter_z > st.exec_block->step_event_count) {
    5be4:	45 85       	ldd	r20, Z+13	; 0x0d
    5be6:	56 85       	ldd	r21, Z+14	; 0x0e
    5be8:	67 85       	ldd	r22, Z+15	; 0x0f
    5bea:	70 89       	ldd	r23, Z+16	; 0x10
    5bec:	48 17       	cp	r20, r24
    5bee:	59 07       	cpc	r21, r25
    5bf0:	6a 07       	cpc	r22, r26
    5bf2:	7b 07       	cpc	r23, r27
    5bf4:	68 f5       	brcc	.+90     	; 0x5c50 <__vector_11+0x348>
    st.step_outbits |= (1<<Z_STEP_BIT);
    5bf6:	2e 85       	ldd	r18, Y+14	; 0x0e
    5bf8:	20 61       	ori	r18, 0x10	; 16
    5bfa:	2e 87       	std	Y+14, r18	; 0x0e
    st.counter_z -= st.exec_block->step_event_count;
    5bfc:	45 85       	ldd	r20, Z+13	; 0x0d
    5bfe:	56 85       	ldd	r21, Z+14	; 0x0e
    5c00:	67 85       	ldd	r22, Z+15	; 0x0f
    5c02:	70 89       	ldd	r23, Z+16	; 0x10
    5c04:	84 1b       	sub	r24, r20
    5c06:	95 0b       	sbc	r25, r21
    5c08:	a6 0b       	sbc	r26, r22
    5c0a:	b7 0b       	sbc	r27, r23
    5c0c:	88 87       	std	Y+8, r24	; 0x08
    5c0e:	99 87       	std	Y+9, r25	; 0x09
    5c10:	aa 87       	std	Y+10, r26	; 0x0a
    5c12:	bb 87       	std	Y+11, r27	; 0x0b
    if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys.position[Z_AXIS]--; }
    5c14:	80 81       	ld	r24, Z
    5c16:	88 23       	and	r24, r24
    5c18:	74 f4       	brge	.+28     	; 0x5c36 <__vector_11+0x32e>
    5c1a:	e0 ea       	ldi	r30, 0xA0	; 160
    5c1c:	f5 e0       	ldi	r31, 0x05	; 5
    5c1e:	84 85       	ldd	r24, Z+12	; 0x0c
    5c20:	95 85       	ldd	r25, Z+13	; 0x0d
    5c22:	a6 85       	ldd	r26, Z+14	; 0x0e
    5c24:	b7 85       	ldd	r27, Z+15	; 0x0f
    5c26:	01 97       	sbiw	r24, 0x01	; 1
    5c28:	a1 09       	sbc	r26, r1
    5c2a:	b1 09       	sbc	r27, r1
    5c2c:	84 87       	std	Z+12, r24	; 0x0c
    5c2e:	95 87       	std	Z+13, r25	; 0x0d
    5c30:	a6 87       	std	Z+14, r26	; 0x0e
    5c32:	b7 87       	std	Z+15, r27	; 0x0f
    5c34:	0d c0       	rjmp	.+26     	; 0x5c50 <__vector_11+0x348>
    else { sys.position[Z_AXIS]++; }
    5c36:	e0 ea       	ldi	r30, 0xA0	; 160
    5c38:	f5 e0       	ldi	r31, 0x05	; 5
    5c3a:	84 85       	ldd	r24, Z+12	; 0x0c
    5c3c:	95 85       	ldd	r25, Z+13	; 0x0d
    5c3e:	a6 85       	ldd	r26, Z+14	; 0x0e
    5c40:	b7 85       	ldd	r27, Z+15	; 0x0f
    5c42:	01 96       	adiw	r24, 0x01	; 1
    5c44:	a1 1d       	adc	r26, r1
    5c46:	b1 1d       	adc	r27, r1
    5c48:	84 87       	std	Z+12, r24	; 0x0c
    5c4a:	95 87       	std	Z+13, r25	; 0x0d
    5c4c:	a6 87       	std	Z+14, r26	; 0x0e
    5c4e:	b7 87       	std	Z+15, r27	; 0x0f
  }  

  // During a homing cycle, lock out and prevent desired axes from moving.
  if (sys.state == STATE_HOMING) { st.step_outbits &= sys.homing_axis_lock; }   
    5c50:	80 91 a1 05 	lds	r24, 0x05A1	; 0x8005a1 <sys+0x1>
    5c54:	84 30       	cpi	r24, 0x04	; 4
    5c56:	39 f4       	brne	.+14     	; 0x5c66 <__vector_11+0x35e>
    5c58:	e9 e8       	ldi	r30, 0x89	; 137
    5c5a:	f4 e0       	ldi	r31, 0x04	; 4
    5c5c:	96 85       	ldd	r25, Z+14	; 0x0e
    5c5e:	80 91 bd 05 	lds	r24, 0x05BD	; 0x8005bd <sys+0x1d>
    5c62:	89 23       	and	r24, r25
    5c64:	86 87       	std	Z+14, r24	; 0x0e

  st.step_count--; // Decrement step events count 
    5c66:	e9 e8       	ldi	r30, 0x89	; 137
    5c68:	f4 e0       	ldi	r31, 0x04	; 4
    5c6a:	84 8d       	ldd	r24, Z+28	; 0x1c
    5c6c:	95 8d       	ldd	r25, Z+29	; 0x1d
    5c6e:	01 97       	sbiw	r24, 0x01	; 1
    5c70:	95 8f       	std	Z+29, r25	; 0x1d
    5c72:	84 8f       	std	Z+28, r24	; 0x1c
  if (st.step_count == 0) {
    5c74:	89 2b       	or	r24, r25
    5c76:	69 f4       	brne	.+26     	; 0x5c92 <__vector_11+0x38a>
    // Segment is complete. Discard current segment and advance segment indexing.
    st.exec_segment = NULL;
    5c78:	10 92 ab 04 	sts	0x04AB, r1	; 0x8004ab <st+0x22>
    5c7c:	10 92 aa 04 	sts	0x04AA, r1	; 0x8004aa <st+0x21>
    if ( ++segment_buffer_tail == SEGMENT_BUFFER_SIZE) { segment_buffer_tail = 0; }
    5c80:	80 91 88 04 	lds	r24, 0x0488	; 0x800488 <segment_buffer_tail>
    5c84:	8f 5f       	subi	r24, 0xFF	; 255
    5c86:	80 93 88 04 	sts	0x0488, r24	; 0x800488 <segment_buffer_tail>
    5c8a:	86 30       	cpi	r24, 0x06	; 6
    5c8c:	11 f4       	brne	.+4      	; 0x5c92 <__vector_11+0x38a>
    5c8e:	10 92 88 04 	sts	0x0488, r1	; 0x800488 <segment_buffer_tail>
  }

  st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask    
    5c92:	e9 e8       	ldi	r30, 0x89	; 137
    5c94:	f4 e0       	ldi	r31, 0x04	; 4
    5c96:	96 85       	ldd	r25, Z+14	; 0x0e
    5c98:	80 91 85 04 	lds	r24, 0x0485	; 0x800485 <step_port_invert_mask>
    5c9c:	89 27       	eor	r24, r25
    5c9e:	86 87       	std	Z+14, r24	; 0x0e
  busy = false;
    5ca0:	10 92 83 04 	sts	0x0483, r1	; 0x800483 <busy>
// SPINDLE_ENABLE_PORT ^= 1<<SPINDLE_ENABLE_BIT; // Debug: Used to time ISR
}
    5ca4:	ff 91       	pop	r31
    5ca6:	ef 91       	pop	r30
    5ca8:	df 91       	pop	r29
    5caa:	cf 91       	pop	r28
    5cac:	bf 91       	pop	r27
    5cae:	af 91       	pop	r26
    5cb0:	9f 91       	pop	r25
    5cb2:	8f 91       	pop	r24
    5cb4:	7f 91       	pop	r23
    5cb6:	6f 91       	pop	r22
    5cb8:	5f 91       	pop	r21
    5cba:	4f 91       	pop	r20
    5cbc:	3f 91       	pop	r19
    5cbe:	2f 91       	pop	r18
    5cc0:	1f 91       	pop	r17
    5cc2:	0f 91       	pop	r16
    5cc4:	0f 90       	pop	r0
    5cc6:	0f be       	out	0x3f, r0	; 63
    5cc8:	0f 90       	pop	r0
    5cca:	1f 90       	pop	r1
    5ccc:	18 95       	reti

00005cce <__vector_16>:
*/
// This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute
// a step. This ISR resets the motor port after a short period (settings.pulse_microseconds) 
// completing one step cycle.
ISR(TIMER0_OVF_vect)
{
    5cce:	1f 92       	push	r1
    5cd0:	0f 92       	push	r0
    5cd2:	0f b6       	in	r0, 0x3f	; 63
    5cd4:	0f 92       	push	r0
    5cd6:	11 24       	eor	r1, r1
    5cd8:	8f 93       	push	r24
    5cda:	9f 93       	push	r25
  // Reset stepping pins (leave the direction pins)
  STEP_PORT = (STEP_PORT & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK); 
    5cdc:	8b b1       	in	r24, 0x0b	; 11
    5cde:	90 91 85 04 	lds	r25, 0x0485	; 0x800485 <step_port_invert_mask>
    5ce2:	9c 71       	andi	r25, 0x1C	; 28
    5ce4:	83 7e       	andi	r24, 0xE3	; 227
    5ce6:	89 2b       	or	r24, r25
    5ce8:	8b b9       	out	0x0b, r24	; 11
  TCCR0B = 0; // Disable Timer0 to prevent re-entering this interrupt when it's not needed. 
    5cea:	15 bc       	out	0x25, r1	; 37
}
    5cec:	9f 91       	pop	r25
    5cee:	8f 91       	pop	r24
    5cf0:	0f 90       	pop	r0
    5cf2:	0f be       	out	0x3f, r0	; 63
    5cf4:	0f 90       	pop	r0
    5cf6:	1f 90       	pop	r1
    5cf8:	18 95       	reti

00005cfa <st_generate_step_dir_invert_masks>:
#endif


// Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
void st_generate_step_dir_invert_masks()
{  
    5cfa:	ef 92       	push	r14
    5cfc:	ff 92       	push	r15
    5cfe:	0f 93       	push	r16
    5d00:	1f 93       	push	r17
    5d02:	cf 93       	push	r28
    5d04:	df 93       	push	r29
  uint8_t idx;
  step_port_invert_mask = 0;
    5d06:	10 92 85 04 	sts	0x0485, r1	; 0x800485 <step_port_invert_mask>
  dir_port_invert_mask = 0;
    5d0a:	10 92 84 04 	sts	0x0484, r1	; 0x800484 <dir_port_invert_mask>
    5d0e:	c0 e0       	ldi	r28, 0x00	; 0
    5d10:	d0 e0       	ldi	r29, 0x00	; 0
  for (idx=0; idx<N_AXIS; idx++) {
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    5d12:	0f e7       	ldi	r16, 0x7F	; 127
    5d14:	16 e0       	ldi	r17, 0x06	; 6
    5d16:	ec 2e       	mov	r14, r28
    5d18:	fc 2e       	mov	r15, r28
    5d1a:	f8 01       	movw	r30, r16
    5d1c:	81 a9       	ldd	r24, Z+49	; 0x31
    5d1e:	90 e0       	ldi	r25, 0x00	; 0
    5d20:	0c 2e       	mov	r0, r28
    5d22:	02 c0       	rjmp	.+4      	; 0x5d28 <st_generate_step_dir_invert_masks+0x2e>
    5d24:	95 95       	asr	r25
    5d26:	87 95       	ror	r24
    5d28:	0a 94       	dec	r0
    5d2a:	e2 f7       	brpl	.-8      	; 0x5d24 <st_generate_step_dir_invert_masks+0x2a>
    5d2c:	80 ff       	sbrs	r24, 0
    5d2e:	08 c0       	rjmp	.+16     	; 0x5d40 <st_generate_step_dir_invert_masks+0x46>
    5d30:	8c 2f       	mov	r24, r28
    5d32:	0e 94 9d 2b 	call	0x573a	; 0x573a <get_step_pin_mask>
    5d36:	90 91 85 04 	lds	r25, 0x0485	; 0x800485 <step_port_invert_mask>
    5d3a:	89 2b       	or	r24, r25
    5d3c:	80 93 85 04 	sts	0x0485, r24	; 0x800485 <step_port_invert_mask>
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    5d40:	f8 01       	movw	r30, r16
    5d42:	82 a9       	ldd	r24, Z+50	; 0x32
    5d44:	90 e0       	ldi	r25, 0x00	; 0
    5d46:	02 c0       	rjmp	.+4      	; 0x5d4c <st_generate_step_dir_invert_masks+0x52>
    5d48:	95 95       	asr	r25
    5d4a:	87 95       	ror	r24
    5d4c:	fa 94       	dec	r15
    5d4e:	e2 f7       	brpl	.-8      	; 0x5d48 <st_generate_step_dir_invert_masks+0x4e>
    5d50:	80 ff       	sbrs	r24, 0
    5d52:	08 c0       	rjmp	.+16     	; 0x5d64 <st_generate_step_dir_invert_masks+0x6a>
    5d54:	8e 2d       	mov	r24, r14
    5d56:	0e 94 a7 2b 	call	0x574e	; 0x574e <get_direction_pin_mask>
    5d5a:	90 91 84 04 	lds	r25, 0x0484	; 0x800484 <dir_port_invert_mask>
    5d5e:	89 2b       	or	r24, r25
    5d60:	80 93 84 04 	sts	0x0484, r24	; 0x800484 <dir_port_invert_mask>
    5d64:	21 96       	adiw	r28, 0x01	; 1
void st_generate_step_dir_invert_masks()
{  
  uint8_t idx;
  step_port_invert_mask = 0;
  dir_port_invert_mask = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    5d66:	c3 30       	cpi	r28, 0x03	; 3
    5d68:	d1 05       	cpc	r29, r1
    5d6a:	a9 f6       	brne	.-86     	; 0x5d16 <st_generate_step_dir_invert_masks+0x1c>
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
  }
}
    5d6c:	df 91       	pop	r29
    5d6e:	cf 91       	pop	r28
    5d70:	1f 91       	pop	r17
    5d72:	0f 91       	pop	r16
    5d74:	ff 90       	pop	r15
    5d76:	ef 90       	pop	r14
    5d78:	08 95       	ret

00005d7a <st_reset>:

// Reset and clear stepper subsystem variables
void st_reset()
{
  // Initialize stepper driver idle state.
  st_go_idle();
    5d7a:	0e 94 5b 2c 	call	0x58b6	; 0x58b6 <st_go_idle>
  
  // Initialize stepper algorithm variables.
  memset(&prep, 0, sizeof(st_prep_t));
    5d7e:	8b e2       	ldi	r24, 0x2B	; 43
    5d80:	e6 e5       	ldi	r30, 0x56	; 86
    5d82:	f4 e0       	ldi	r31, 0x04	; 4
    5d84:	df 01       	movw	r26, r30
    5d86:	1d 92       	st	X+, r1
    5d88:	8a 95       	dec	r24
    5d8a:	e9 f7       	brne	.-6      	; 0x5d86 <st_reset+0xc>
  memset(&st, 0, sizeof(stepper_t));
    5d8c:	83 e2       	ldi	r24, 0x23	; 35
    5d8e:	e9 e8       	ldi	r30, 0x89	; 137
    5d90:	f4 e0       	ldi	r31, 0x04	; 4
    5d92:	df 01       	movw	r26, r30
    5d94:	1d 92       	st	X+, r1
    5d96:	8a 95       	dec	r24
    5d98:	e9 f7       	brne	.-6      	; 0x5d94 <st_reset+0x1a>
  st.exec_segment = NULL;
  pl_block = NULL;  // Planner block pointer used by segment buffer
    5d9a:	10 92 82 04 	sts	0x0482, r1	; 0x800482 <pl_block+0x1>
    5d9e:	10 92 81 04 	sts	0x0481, r1	; 0x800481 <pl_block>
  segment_buffer_tail = 0;
    5da2:	10 92 88 04 	sts	0x0488, r1	; 0x800488 <segment_buffer_tail>
  segment_buffer_head = 0; // empty = tail
    5da6:	10 92 87 04 	sts	0x0487, r1	; 0x800487 <segment_buffer_head>
  segment_next_head = 1;
    5daa:	81 e0       	ldi	r24, 0x01	; 1
    5dac:	80 93 86 04 	sts	0x0486, r24	; 0x800486 <segment_next_head>
  busy = false;
    5db0:	10 92 83 04 	sts	0x0483, r1	; 0x800483 <busy>
  
  st_generate_step_dir_invert_masks();
    5db4:	0e 94 7d 2e 	call	0x5cfa	; 0x5cfa <st_generate_step_dir_invert_masks>
      
  // Initialize step and direction port pins.
  STEP_PORT = (STEP_PORT & ~STEP_MASK) | step_port_invert_mask;
    5db8:	8b b1       	in	r24, 0x0b	; 11
    5dba:	83 7e       	andi	r24, 0xE3	; 227
    5dbc:	90 91 85 04 	lds	r25, 0x0485	; 0x800485 <step_port_invert_mask>
    5dc0:	89 2b       	or	r24, r25
    5dc2:	8b b9       	out	0x0b, r24	; 11
  DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | dir_port_invert_mask;
    5dc4:	8b b1       	in	r24, 0x0b	; 11
    5dc6:	8f 71       	andi	r24, 0x1F	; 31
    5dc8:	90 91 84 04 	lds	r25, 0x0484	; 0x800484 <dir_port_invert_mask>
    5dcc:	89 2b       	or	r24, r25
    5dce:	8b b9       	out	0x0b, r24	; 11
    5dd0:	08 95       	ret

00005dd2 <stepper_init>:

// Initialize and start the stepper motor subsystem
void stepper_init()
{
  // Configure step and direction interface pins
  STEP_DDR |= STEP_MASK;
    5dd2:	8a b1       	in	r24, 0x0a	; 10
    5dd4:	8c 61       	ori	r24, 0x1C	; 28
    5dd6:	8a b9       	out	0x0a, r24	; 10
  STEPPERS_DISABLE_DDR |= 1<<STEPPERS_DISABLE_BIT;
    5dd8:	20 9a       	sbi	0x04, 0	; 4
  DIRECTION_DDR |= DIRECTION_MASK;
    5dda:	8a b1       	in	r24, 0x0a	; 10
    5ddc:	80 6e       	ori	r24, 0xE0	; 224
    5dde:	8a b9       	out	0x0a, r24	; 10

  // Configure Timer 1: Stepper Driver Interrupt
  TCCR1B &= ~(1<<WGM13); // waveform generation = 0100 = CTC
    5de0:	e1 e8       	ldi	r30, 0x81	; 129
    5de2:	f0 e0       	ldi	r31, 0x00	; 0
    5de4:	80 81       	ld	r24, Z
    5de6:	8f 7e       	andi	r24, 0xEF	; 239
    5de8:	80 83       	st	Z, r24
  TCCR1B |=  (1<<WGM12);
    5dea:	80 81       	ld	r24, Z
    5dec:	88 60       	ori	r24, 0x08	; 8
    5dee:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<WGM11) | (1<<WGM10)); 
    5df0:	e0 e8       	ldi	r30, 0x80	; 128
    5df2:	f0 e0       	ldi	r31, 0x00	; 0
    5df4:	80 81       	ld	r24, Z
    5df6:	8c 7f       	andi	r24, 0xFC	; 252
    5df8:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<COM1A1) | (1<<COM1A0) | (1<<COM1B1) | (1<<COM1B0)); // Disconnect OC1 output
    5dfa:	80 81       	ld	r24, Z
    5dfc:	8f 70       	andi	r24, 0x0F	; 15
    5dfe:	80 83       	st	Z, r24
  // TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Set in st_go_idle().
  // TIMSK1 &= ~(1<<OCIE1A);  // Set in st_go_idle().
  
  // Configure Timer 0: Stepper Port Reset Interrupt
  TIMSK0 &= ~((1<<OCIE0B) | (1<<OCIE0A) | (1<<TOIE0)); // Disconnect OC0 outputs and OVF interrupt.
    5e00:	ee e6       	ldi	r30, 0x6E	; 110
    5e02:	f0 e0       	ldi	r31, 0x00	; 0
    5e04:	80 81       	ld	r24, Z
    5e06:	88 7f       	andi	r24, 0xF8	; 248
    5e08:	80 83       	st	Z, r24
  TCCR0A = 0; // Normal operation
    5e0a:	14 bc       	out	0x24, r1	; 36
  TCCR0B = 0; // Disable Timer0 until needed
    5e0c:	15 bc       	out	0x25, r1	; 37
  TIMSK0 |= (1<<TOIE0); // Enable Timer0 overflow interrupt
    5e0e:	80 81       	ld	r24, Z
    5e10:	81 60       	ori	r24, 0x01	; 1
    5e12:	80 83       	st	Z, r24
    5e14:	08 95       	ret

00005e16 <st_update_plan_block_parameters>:
}
  

// Called by planner_recalculate() when the executing block is updated by the new plan.
void st_update_plan_block_parameters()
{ 
    5e16:	cf 93       	push	r28
    5e18:	df 93       	push	r29
  if (pl_block != NULL) { // Ignore if at start of a new block.
    5e1a:	c0 91 81 04 	lds	r28, 0x0481	; 0x800481 <pl_block>
    5e1e:	d0 91 82 04 	lds	r29, 0x0482	; 0x800482 <pl_block+0x1>
    5e22:	20 97       	sbiw	r28, 0x00	; 0
    5e24:	a1 f0       	breq	.+40     	; 0x5e4e <st_update_plan_block_parameters+0x38>
    prep.flag_partial_block = true;
    5e26:	e6 e5       	ldi	r30, 0x56	; 86
    5e28:	f4 e0       	ldi	r31, 0x04	; 4
    5e2a:	81 e0       	ldi	r24, 0x01	; 1
    5e2c:	81 83       	std	Z+1, r24	; 0x01
    pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
    5e2e:	67 89       	ldd	r22, Z+23	; 0x17
    5e30:	70 8d       	ldd	r23, Z+24	; 0x18
    5e32:	81 8d       	ldd	r24, Z+25	; 0x19
    5e34:	92 8d       	ldd	r25, Z+26	; 0x1a
    5e36:	9b 01       	movw	r18, r22
    5e38:	ac 01       	movw	r20, r24
    5e3a:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    5e3e:	69 8b       	std	Y+17, r22	; 0x11
    5e40:	7a 8b       	std	Y+18, r23	; 0x12
    5e42:	8b 8b       	std	Y+19, r24	; 0x13
    5e44:	9c 8b       	std	Y+20, r25	; 0x14
    pl_block = NULL; // Flag st_prep_segment() to load new velocity profile.
    5e46:	10 92 82 04 	sts	0x0482, r1	; 0x800482 <pl_block+0x1>
    5e4a:	10 92 81 04 	sts	0x0481, r1	; 0x800481 <pl_block>
  }
}
    5e4e:	df 91       	pop	r29
    5e50:	cf 91       	pop	r28
    5e52:	08 95       	ret

00005e54 <st_prep_buffer>:
   longer than the time it takes the stepper algorithm to empty it before refilling it. 
   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer()
{
    5e54:	2f 92       	push	r2
    5e56:	3f 92       	push	r3
    5e58:	4f 92       	push	r4
    5e5a:	5f 92       	push	r5
    5e5c:	6f 92       	push	r6
    5e5e:	7f 92       	push	r7
    5e60:	8f 92       	push	r8
    5e62:	9f 92       	push	r9
    5e64:	af 92       	push	r10
    5e66:	bf 92       	push	r11
    5e68:	cf 92       	push	r12
    5e6a:	df 92       	push	r13
    5e6c:	ef 92       	push	r14
    5e6e:	ff 92       	push	r15
    5e70:	0f 93       	push	r16
    5e72:	1f 93       	push	r17
    5e74:	cf 93       	push	r28
    5e76:	df 93       	push	r29
    5e78:	cd b7       	in	r28, 0x3d	; 61
    5e7a:	de b7       	in	r29, 0x3e	; 62
    5e7c:	ed 97       	sbiw	r28, 0x3d	; 61
    5e7e:	0f b6       	in	r0, 0x3f	; 63
    5e80:	f8 94       	cli
    5e82:	de bf       	out	0x3e, r29	; 62
    5e84:	0f be       	out	0x3f, r0	; 63
    5e86:	cd bf       	out	0x3d, r28	; 61

  if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { 
    5e88:	80 91 a1 05 	lds	r24, 0x05A1	; 0x8005a1 <sys+0x1>
    5e8c:	80 77       	andi	r24, 0x70	; 112
    5e8e:	09 f4       	brne	.+2      	; 0x5e92 <st_prep_buffer+0x3e>
    5e90:	a2 c6       	rjmp	.+3396   	; 0x6bd6 <st_prep_buffer+0xd82>
    // Check if we still need to generate more segments for a motion suspend.
    if (prep.current_speed == 0.0) { return; } // Nothing to do. Bail.
    5e92:	20 e0       	ldi	r18, 0x00	; 0
    5e94:	30 e0       	ldi	r19, 0x00	; 0
    5e96:	a9 01       	movw	r20, r18
    5e98:	60 91 6d 04 	lds	r22, 0x046D	; 0x80046d <prep+0x17>
    5e9c:	70 91 6e 04 	lds	r23, 0x046E	; 0x80046e <prep+0x18>
    5ea0:	80 91 6f 04 	lds	r24, 0x046F	; 0x80046f <prep+0x19>
    5ea4:	90 91 70 04 	lds	r25, 0x0470	; 0x800470 <prep+0x1a>
    5ea8:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    5eac:	81 11       	cpse	r24, r1
    5eae:	93 c6       	rjmp	.+3366   	; 0x6bd6 <st_prep_buffer+0xd82>
    5eb0:	a0 c6       	rjmp	.+3392   	; 0x6bf2 <st_prep_buffer+0xd9e>
  }
  
  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.

    // Determine if we need to load a new planner block or if the block has been replanned. 
    if (pl_block == NULL) {
    5eb2:	80 91 81 04 	lds	r24, 0x0481	; 0x800481 <pl_block>
    5eb6:	90 91 82 04 	lds	r25, 0x0482	; 0x800482 <pl_block+0x1>
    5eba:	89 2b       	or	r24, r25
    5ebc:	09 f0       	breq	.+2      	; 0x5ec0 <st_prep_buffer+0x6c>
    5ebe:	53 c2       	rjmp	.+1190   	; 0x6366 <st_prep_buffer+0x512>
      pl_block = plan_get_current_block(); // Query planner for a queued block
    5ec0:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <plan_get_current_block>
    5ec4:	8c 01       	movw	r16, r24
    5ec6:	90 93 82 04 	sts	0x0482, r25	; 0x800482 <pl_block+0x1>
    5eca:	80 93 81 04 	sts	0x0481, r24	; 0x800481 <pl_block>
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
    5ece:	89 2b       	or	r24, r25
    5ed0:	09 f4       	brne	.+2      	; 0x5ed4 <st_prep_buffer+0x80>
    5ed2:	8f c6       	rjmp	.+3358   	; 0x6bf2 <st_prep_buffer+0xd9e>
                      
      // Check if the segment buffer completed the last planner block. If so, load the Bresenham
      // data for the block. If not, we are still mid-block and the velocity profile was updated. 
      if (prep.flag_partial_block) {
    5ed4:	d3 01       	movw	r26, r6
    5ed6:	11 96       	adiw	r26, 0x01	; 1
    5ed8:	8c 91       	ld	r24, X
    5eda:	11 97       	sbiw	r26, 0x01	; 1
    5edc:	88 23       	and	r24, r24
    5ede:	19 f0       	breq	.+6      	; 0x5ee6 <st_prep_buffer+0x92>
        prep.flag_partial_block = false; // Reset flag
    5ee0:	11 96       	adiw	r26, 0x01	; 1
    5ee2:	1c 92       	st	X, r1
    5ee4:	ca c0       	rjmp	.+404    	; 0x607a <st_prep_buffer+0x226>
      } else {
        // Increment stepper common data index to store new planner block data. 
        if ( ++prep.st_block_index == (SEGMENT_BUFFER_SIZE-1) ) { prep.st_block_index = 0; }
    5ee6:	f3 01       	movw	r30, r6
    5ee8:	80 81       	ld	r24, Z
    5eea:	8f 5f       	subi	r24, 0xFF	; 255
    5eec:	85 30       	cpi	r24, 0x05	; 5
    5eee:	11 f0       	breq	.+4      	; 0x5ef4 <st_prep_buffer+0xa0>
    5ef0:	80 83       	st	Z, r24
    5ef2:	01 c0       	rjmp	.+2      	; 0x5ef6 <st_prep_buffer+0xa2>
    5ef4:	10 82       	st	Z, r1
        
        // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
        // when the segment buffer completes the planner block, it may be discarded when the 
        // segment buffer finishes the prepped block, but the stepper ISR is still executing it. 
        st_prep_block = &st_block_buffer[prep.st_block_index];
    5ef6:	d3 01       	movw	r26, r6
    5ef8:	ec 91       	ld	r30, X
        st_prep_block->direction_bits = pl_block->direction_bits;
    5efa:	d8 01       	movw	r26, r16
    5efc:	8c 91       	ld	r24, X
    5efe:	b1 e1       	ldi	r27, 0x11	; 17
    5f00:	be 9f       	mul	r27, r30
    5f02:	f0 01       	movw	r30, r0
    5f04:	11 24       	eor	r1, r1
    5f06:	e0 53       	subi	r30, 0x30	; 48
    5f08:	fb 4f       	sbci	r31, 0xFB	; 251
    5f0a:	80 83       	st	Z, r24
          st_prep_block->step_event_count = pl_block->step_event_count;
        #else
          // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS 
          // level, such that we never divide beyond the original data anywhere in the algorithm.
          // If the original data is divided, we can lose a step from integer roundoff.
          st_prep_block->steps[X_AXIS] = pl_block->steps[X_AXIS] << MAX_AMASS_LEVEL;
    5f0c:	d8 01       	movw	r26, r16
    5f0e:	11 96       	adiw	r26, 0x01	; 1
    5f10:	4d 91       	ld	r20, X+
    5f12:	5d 91       	ld	r21, X+
    5f14:	6d 91       	ld	r22, X+
    5f16:	7c 91       	ld	r23, X
    5f18:	14 97       	sbiw	r26, 0x04	; 4
    5f1a:	db 01       	movw	r26, r22
    5f1c:	ca 01       	movw	r24, r20
    5f1e:	88 0f       	add	r24, r24
    5f20:	99 1f       	adc	r25, r25
    5f22:	aa 1f       	adc	r26, r26
    5f24:	bb 1f       	adc	r27, r27
    5f26:	88 0f       	add	r24, r24
    5f28:	99 1f       	adc	r25, r25
    5f2a:	aa 1f       	adc	r26, r26
    5f2c:	bb 1f       	adc	r27, r27
    5f2e:	88 0f       	add	r24, r24
    5f30:	99 1f       	adc	r25, r25
    5f32:	aa 1f       	adc	r26, r26
    5f34:	bb 1f       	adc	r27, r27
    5f36:	81 83       	std	Z+1, r24	; 0x01
    5f38:	92 83       	std	Z+2, r25	; 0x02
    5f3a:	a3 83       	std	Z+3, r26	; 0x03
    5f3c:	b4 83       	std	Z+4, r27	; 0x04
          st_prep_block->steps[Y_AXIS] = pl_block->steps[Y_AXIS] << MAX_AMASS_LEVEL;
    5f3e:	d8 01       	movw	r26, r16
    5f40:	15 96       	adiw	r26, 0x05	; 5
    5f42:	4d 91       	ld	r20, X+
    5f44:	5d 91       	ld	r21, X+
    5f46:	6d 91       	ld	r22, X+
    5f48:	7c 91       	ld	r23, X
    5f4a:	18 97       	sbiw	r26, 0x08	; 8
    5f4c:	db 01       	movw	r26, r22
    5f4e:	ca 01       	movw	r24, r20
    5f50:	88 0f       	add	r24, r24
    5f52:	99 1f       	adc	r25, r25
    5f54:	aa 1f       	adc	r26, r26
    5f56:	bb 1f       	adc	r27, r27
    5f58:	88 0f       	add	r24, r24
    5f5a:	99 1f       	adc	r25, r25
    5f5c:	aa 1f       	adc	r26, r26
    5f5e:	bb 1f       	adc	r27, r27
    5f60:	88 0f       	add	r24, r24
    5f62:	99 1f       	adc	r25, r25
    5f64:	aa 1f       	adc	r26, r26
    5f66:	bb 1f       	adc	r27, r27
    5f68:	85 83       	std	Z+5, r24	; 0x05
    5f6a:	96 83       	std	Z+6, r25	; 0x06
    5f6c:	a7 83       	std	Z+7, r26	; 0x07
    5f6e:	b0 87       	std	Z+8, r27	; 0x08
          st_prep_block->steps[Z_AXIS] = pl_block->steps[Z_AXIS] << MAX_AMASS_LEVEL;
    5f70:	d8 01       	movw	r26, r16
    5f72:	19 96       	adiw	r26, 0x09	; 9
    5f74:	4d 91       	ld	r20, X+
    5f76:	5d 91       	ld	r21, X+
    5f78:	6d 91       	ld	r22, X+
    5f7a:	7c 91       	ld	r23, X
    5f7c:	1c 97       	sbiw	r26, 0x0c	; 12
    5f7e:	db 01       	movw	r26, r22
    5f80:	ca 01       	movw	r24, r20
    5f82:	88 0f       	add	r24, r24
    5f84:	99 1f       	adc	r25, r25
    5f86:	aa 1f       	adc	r26, r26
    5f88:	bb 1f       	adc	r27, r27
    5f8a:	88 0f       	add	r24, r24
    5f8c:	99 1f       	adc	r25, r25
    5f8e:	aa 1f       	adc	r26, r26
    5f90:	bb 1f       	adc	r27, r27
    5f92:	88 0f       	add	r24, r24
    5f94:	99 1f       	adc	r25, r25
    5f96:	aa 1f       	adc	r26, r26
    5f98:	bb 1f       	adc	r27, r27
    5f9a:	81 87       	std	Z+9, r24	; 0x09
    5f9c:	92 87       	std	Z+10, r25	; 0x0a
    5f9e:	a3 87       	std	Z+11, r26	; 0x0b
    5fa0:	b4 87       	std	Z+12, r27	; 0x0c
          st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
    5fa2:	d8 01       	movw	r26, r16
    5fa4:	1d 96       	adiw	r26, 0x0d	; 13
    5fa6:	4d 91       	ld	r20, X+
    5fa8:	5d 91       	ld	r21, X+
    5faa:	6d 91       	ld	r22, X+
    5fac:	7c 91       	ld	r23, X
    5fae:	50 97       	sbiw	r26, 0x10	; 16
    5fb0:	db 01       	movw	r26, r22
    5fb2:	ca 01       	movw	r24, r20
    5fb4:	88 0f       	add	r24, r24
    5fb6:	99 1f       	adc	r25, r25
    5fb8:	aa 1f       	adc	r26, r26
    5fba:	bb 1f       	adc	r27, r27
    5fbc:	88 0f       	add	r24, r24
    5fbe:	99 1f       	adc	r25, r25
    5fc0:	aa 1f       	adc	r26, r26
    5fc2:	bb 1f       	adc	r27, r27
    5fc4:	88 0f       	add	r24, r24
    5fc6:	99 1f       	adc	r25, r25
    5fc8:	aa 1f       	adc	r26, r26
    5fca:	bb 1f       	adc	r27, r27
    5fcc:	85 87       	std	Z+13, r24	; 0x0d
    5fce:	96 87       	std	Z+14, r25	; 0x0e
    5fd0:	a7 87       	std	Z+15, r26	; 0x0f
    5fd2:	b0 8b       	std	Z+16, r27	; 0x10
        #endif
        
        // Initialize segment buffer data for generating the segments.
        prep.steps_remaining = pl_block->step_event_count;
    5fd4:	f8 01       	movw	r30, r16
    5fd6:	65 85       	ldd	r22, Z+13	; 0x0d
    5fd8:	76 85       	ldd	r23, Z+14	; 0x0e
    5fda:	87 85       	ldd	r24, Z+15	; 0x0f
    5fdc:	90 89       	ldd	r25, Z+16	; 0x10
    5fde:	0e 94 51 3a 	call	0x74a2	; 0x74a2 <__floatunsisf>
    5fe2:	d3 01       	movw	r26, r6
    5fe4:	12 96       	adiw	r26, 0x02	; 2
    5fe6:	6d 93       	st	X+, r22
    5fe8:	7d 93       	st	X+, r23
    5fea:	8d 93       	st	X+, r24
    5fec:	9c 93       	st	X, r25
    5fee:	15 97       	sbiw	r26, 0x05	; 5
        prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
    5ff0:	f8 01       	movw	r30, r16
    5ff2:	25 a1       	ldd	r18, Z+37	; 0x25
    5ff4:	36 a1       	ldd	r19, Z+38	; 0x26
    5ff6:	47 a1       	ldd	r20, Z+39	; 0x27
    5ff8:	50 a5       	ldd	r21, Z+40	; 0x28
    5ffa:	0e 94 a9 39 	call	0x7352	; 0x7352 <__divsf3>
    5ffe:	9b 01       	movw	r18, r22
    6000:	ac 01       	movw	r20, r24
    6002:	d3 01       	movw	r26, r6
    6004:	16 96       	adiw	r26, 0x06	; 6
    6006:	6d 93       	st	X+, r22
    6008:	7d 93       	st	X+, r23
    600a:	8d 93       	st	X+, r24
    600c:	9c 93       	st	X, r25
    600e:	19 97       	sbiw	r26, 0x09	; 9
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
    6010:	60 e0       	ldi	r22, 0x00	; 0
    6012:	70 e0       	ldi	r23, 0x00	; 0
    6014:	80 ea       	ldi	r24, 0xA0	; 160
    6016:	9f e3       	ldi	r25, 0x3F	; 63
    6018:	0e 94 a9 39 	call	0x7352	; 0x7352 <__divsf3>
    601c:	f3 01       	movw	r30, r6
    601e:	62 87       	std	Z+10, r22	; 0x0a
    6020:	73 87       	std	Z+11, r23	; 0x0b
    6022:	84 87       	std	Z+12, r24	; 0x0c
    6024:	95 87       	std	Z+13, r25	; 0x0d
        
        prep.dt_remainder = 0.0; // Reset for new planner block
    6026:	16 86       	std	Z+14, r1	; 0x0e
    6028:	17 86       	std	Z+15, r1	; 0x0f
    602a:	10 8a       	std	Z+16, r1	; 0x10
    602c:	11 8a       	std	Z+17, r1	; 0x11

        if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) {
    602e:	80 91 a1 05 	lds	r24, 0x05A1	; 0x8005a1 <sys+0x1>
    6032:	80 77       	andi	r24, 0x70	; 112
    6034:	a1 f0       	breq	.+40     	; 0x605e <st_prep_buffer+0x20a>
          // Override planner block entry speed and enforce deceleration during feed hold.
          prep.current_speed = prep.exit_speed; 
    6036:	67 8d       	ldd	r22, Z+31	; 0x1f
    6038:	70 a1       	ldd	r23, Z+32	; 0x20
    603a:	81 a1       	ldd	r24, Z+33	; 0x21
    603c:	92 a1       	ldd	r25, Z+34	; 0x22
    603e:	67 8b       	std	Z+23, r22	; 0x17
    6040:	70 8f       	std	Z+24, r23	; 0x18
    6042:	81 8f       	std	Z+25, r24	; 0x19
    6044:	92 8f       	std	Z+26, r25	; 0x1a
          pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed; 
    6046:	9b 01       	movw	r18, r22
    6048:	ac 01       	movw	r20, r24
    604a:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    604e:	d8 01       	movw	r26, r16
    6050:	51 96       	adiw	r26, 0x11	; 17
    6052:	6d 93       	st	X+, r22
    6054:	7d 93       	st	X+, r23
    6056:	8d 93       	st	X+, r24
    6058:	9c 93       	st	X, r25
    605a:	54 97       	sbiw	r26, 0x14	; 20
    605c:	0e c0       	rjmp	.+28     	; 0x607a <st_prep_buffer+0x226>
        }
        else { prep.current_speed = sqrt(pl_block->entry_speed_sqr); }
    605e:	f8 01       	movw	r30, r16
    6060:	61 89       	ldd	r22, Z+17	; 0x11
    6062:	72 89       	ldd	r23, Z+18	; 0x12
    6064:	83 89       	ldd	r24, Z+19	; 0x13
    6066:	94 89       	ldd	r25, Z+20	; 0x14
    6068:	0e 94 a0 3c 	call	0x7940	; 0x7940 <sqrt>
    606c:	d3 01       	movw	r26, r6
    606e:	57 96       	adiw	r26, 0x17	; 23
    6070:	6d 93       	st	X+, r22
    6072:	7d 93       	st	X+, r23
    6074:	8d 93       	st	X+, r24
    6076:	9c 93       	st	X, r25
    6078:	5a 97       	sbiw	r26, 0x1a	; 26
         Compute the velocity profile of a new planner block based on its entry and exit
         speeds, or recompute the profile of a partially-completed planner block if the 
         planner has updated it. For a commanded forced-deceleration, such as from a feed 
         hold, override the planner velocities and decelerate to the target exit speed.
      */
      prep.mm_complete = 0.0; // Default velocity profile complete at 0.0mm from end of block.
    607a:	f3 01       	movw	r30, r6
    607c:	13 8a       	std	Z+19, r1	; 0x13
    607e:	14 8a       	std	Z+20, r1	; 0x14
    6080:	15 8a       	std	Z+21, r1	; 0x15
    6082:	16 8a       	std	Z+22, r1	; 0x16
      float inv_2_accel = 0.5/pl_block->acceleration;
    6084:	20 91 81 04 	lds	r18, 0x0481	; 0x800481 <pl_block>
    6088:	30 91 82 04 	lds	r19, 0x0482	; 0x800482 <pl_block+0x1>
    608c:	3a 83       	std	Y+2, r19	; 0x02
    608e:	29 83       	std	Y+1, r18	; 0x01
    6090:	d9 01       	movw	r26, r18
    6092:	91 96       	adiw	r26, 0x21	; 33
    6094:	cd 90       	ld	r12, X+
    6096:	dd 90       	ld	r13, X+
    6098:	ed 90       	ld	r14, X+
    609a:	fc 90       	ld	r15, X
    609c:	94 97       	sbiw	r26, 0x24	; 36
    609e:	a7 01       	movw	r20, r14
    60a0:	96 01       	movw	r18, r12
    60a2:	60 e0       	ldi	r22, 0x00	; 0
    60a4:	70 e0       	ldi	r23, 0x00	; 0
    60a6:	80 e0       	ldi	r24, 0x00	; 0
    60a8:	9f e3       	ldi	r25, 0x3F	; 63
    60aa:	0e 94 a9 39 	call	0x7352	; 0x7352 <__divsf3>
    60ae:	4b 01       	movw	r8, r22
    60b0:	5c 01       	movw	r10, r24
      if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { // [Forced Deceleration to Zero Velocity]
    60b2:	80 91 a1 05 	lds	r24, 0x05A1	; 0x8005a1 <sys+0x1>
    60b6:	80 77       	andi	r24, 0x70	; 112
    60b8:	09 f4       	brne	.+2      	; 0x60bc <st_prep_buffer+0x268>
    60ba:	4f c0       	rjmp	.+158    	; 0x615a <st_prep_buffer+0x306>
        // Compute velocity profile parameters for a feed hold in-progress. This profile overrides
        // the planner block profile, enforcing a deceleration to zero speed.
        prep.ramp_type = RAMP_DECEL;
    60bc:	22 e0       	ldi	r18, 0x02	; 2
    60be:	f3 01       	movw	r30, r6
    60c0:	22 8b       	std	Z+18, r18	; 0x12
        // Compute decelerate distance relative to end of block.
        float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
    60c2:	a9 81       	ldd	r26, Y+1	; 0x01
    60c4:	ba 81       	ldd	r27, Y+2	; 0x02
    60c6:	95 96       	adiw	r26, 0x25	; 37
    60c8:	2d 90       	ld	r2, X+
    60ca:	3d 90       	ld	r3, X+
    60cc:	4d 90       	ld	r4, X+
    60ce:	5c 90       	ld	r5, X
    60d0:	98 97       	sbiw	r26, 0x28	; 40
    60d2:	51 96       	adiw	r26, 0x11	; 17
    60d4:	2d 91       	ld	r18, X+
    60d6:	3d 91       	ld	r19, X+
    60d8:	4d 91       	ld	r20, X+
    60da:	5c 91       	ld	r21, X
    60dc:	54 97       	sbiw	r26, 0x14	; 20
    60de:	29 83       	std	Y+1, r18	; 0x01
    60e0:	3a 83       	std	Y+2, r19	; 0x02
    60e2:	4b 83       	std	Y+3, r20	; 0x03
    60e4:	5c 83       	std	Y+4, r21	; 0x04
    60e6:	c5 01       	movw	r24, r10
    60e8:	b4 01       	movw	r22, r8
    60ea:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    60ee:	9b 01       	movw	r18, r22
    60f0:	ac 01       	movw	r20, r24
    60f2:	c2 01       	movw	r24, r4
    60f4:	b1 01       	movw	r22, r2
    60f6:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    60fa:	4b 01       	movw	r8, r22
    60fc:	5c 01       	movw	r10, r24
        if (decel_dist < 0.0) {
    60fe:	20 e0       	ldi	r18, 0x00	; 0
    6100:	30 e0       	ldi	r19, 0x00	; 0
    6102:	a9 01       	movw	r20, r18
    6104:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    6108:	88 23       	and	r24, r24
    610a:	d4 f4       	brge	.+52     	; 0x6140 <st_prep_buffer+0x2ec>
          // Deceleration through entire planner block. End of feed hold is not in this block.
          prep.exit_speed = sqrt(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
    610c:	a7 01       	movw	r20, r14
    610e:	96 01       	movw	r18, r12
    6110:	c7 01       	movw	r24, r14
    6112:	b6 01       	movw	r22, r12
    6114:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    6118:	a2 01       	movw	r20, r4
    611a:	91 01       	movw	r18, r2
    611c:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    6120:	9b 01       	movw	r18, r22
    6122:	ac 01       	movw	r20, r24
    6124:	69 81       	ldd	r22, Y+1	; 0x01
    6126:	7a 81       	ldd	r23, Y+2	; 0x02
    6128:	8b 81       	ldd	r24, Y+3	; 0x03
    612a:	9c 81       	ldd	r25, Y+4	; 0x04
    612c:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    6130:	0e 94 a0 3c 	call	0x7940	; 0x7940 <sqrt>
    6134:	f3 01       	movw	r30, r6
    6136:	67 8f       	std	Z+31, r22	; 0x1f
    6138:	70 a3       	std	Z+32, r23	; 0x20
    613a:	81 a3       	std	Z+33, r24	; 0x21
    613c:	92 a3       	std	Z+34, r25	; 0x22
    613e:	13 c1       	rjmp	.+550    	; 0x6366 <st_prep_buffer+0x512>
        } else {
          prep.mm_complete = decel_dist; // End of feed hold.
    6140:	d3 01       	movw	r26, r6
    6142:	53 96       	adiw	r26, 0x13	; 19
    6144:	8d 92       	st	X+, r8
    6146:	9d 92       	st	X+, r9
    6148:	ad 92       	st	X+, r10
    614a:	bc 92       	st	X, r11
    614c:	56 97       	sbiw	r26, 0x16	; 22
          prep.exit_speed = 0.0;
    614e:	f3 01       	movw	r30, r6
    6150:	17 8e       	std	Z+31, r1	; 0x1f
    6152:	10 a2       	std	Z+32, r1	; 0x20
    6154:	11 a2       	std	Z+33, r1	; 0x21
    6156:	12 a2       	std	Z+34, r1	; 0x22
    6158:	06 c1       	rjmp	.+524    	; 0x6366 <st_prep_buffer+0x512>
        }
      } else { // [Normal Operation]
        // Compute or recompute velocity profile parameters of the prepped planner block.
        prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
    615a:	d3 01       	movw	r26, r6
    615c:	52 96       	adiw	r26, 0x12	; 18
    615e:	1c 92       	st	X, r1
        prep.accelerate_until = pl_block->millimeters; 
    6160:	e9 81       	ldd	r30, Y+1	; 0x01
    6162:	fa 81       	ldd	r31, Y+2	; 0x02
    6164:	85 a1       	ldd	r24, Z+37	; 0x25
    6166:	96 a1       	ldd	r25, Z+38	; 0x26
    6168:	a7 a1       	ldd	r26, Z+39	; 0x27
    616a:	b0 a5       	ldd	r27, Z+40	; 0x28
    616c:	f3 01       	movw	r30, r6
    616e:	83 a3       	std	Z+35, r24	; 0x23
    6170:	94 a3       	std	Z+36, r25	; 0x24
    6172:	a5 a3       	std	Z+37, r26	; 0x25
    6174:	b6 a3       	std	Z+38, r27	; 0x26
        prep.exit_speed = plan_get_exec_block_exit_speed();   
    6176:	0e 94 04 1b 	call	0x3608	; 0x3608 <plan_get_exec_block_exit_speed>
    617a:	1b 01       	movw	r2, r22
    617c:	2c 01       	movw	r4, r24
    617e:	d3 01       	movw	r26, r6
    6180:	5f 96       	adiw	r26, 0x1f	; 31
    6182:	6d 93       	st	X+, r22
    6184:	7d 93       	st	X+, r23
    6186:	8d 93       	st	X+, r24
    6188:	9c 93       	st	X, r25
    618a:	92 97       	sbiw	r26, 0x22	; 34
        float exit_speed_sqr = prep.exit_speed*prep.exit_speed;
    618c:	9b 01       	movw	r18, r22
    618e:	ac 01       	movw	r20, r24
    6190:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    6194:	69 83       	std	Y+1, r22	; 0x01
    6196:	7a 83       	std	Y+2, r23	; 0x02
    6198:	8b 83       	std	Y+3, r24	; 0x03
    619a:	9c 83       	std	Y+4, r25	; 0x04
        float intersect_distance =
                0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
    619c:	e0 91 81 04 	lds	r30, 0x0481	; 0x800481 <pl_block>
    61a0:	f0 91 82 04 	lds	r31, 0x0482	; 0x800482 <pl_block+0x1>
    61a4:	fe 83       	std	Y+6, r31	; 0x06
    61a6:	ed 83       	std	Y+5, r30	; 0x05
    61a8:	25 a1       	ldd	r18, Z+37	; 0x25
    61aa:	36 a1       	ldd	r19, Z+38	; 0x26
    61ac:	47 a1       	ldd	r20, Z+39	; 0x27
    61ae:	50 a5       	ldd	r21, Z+40	; 0x28
    61b0:	29 87       	std	Y+9, r18	; 0x09
    61b2:	3a 87       	std	Y+10, r19	; 0x0a
    61b4:	4b 87       	std	Y+11, r20	; 0x0b
    61b6:	5c 87       	std	Y+12, r21	; 0x0c
        // Compute or recompute velocity profile parameters of the prepped planner block.
        prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
        prep.accelerate_until = pl_block->millimeters; 
        prep.exit_speed = plan_get_exec_block_exit_speed();   
        float exit_speed_sqr = prep.exit_speed*prep.exit_speed;
        float intersect_distance =
    61b8:	9b 01       	movw	r18, r22
    61ba:	ac 01       	movw	r20, r24
    61bc:	61 89       	ldd	r22, Z+17	; 0x11
    61be:	72 89       	ldd	r23, Z+18	; 0x12
    61c0:	83 89       	ldd	r24, Z+19	; 0x13
    61c2:	94 89       	ldd	r25, Z+20	; 0x14
    61c4:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    61c8:	a5 01       	movw	r20, r10
    61ca:	94 01       	movw	r18, r8
    61cc:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    61d0:	29 85       	ldd	r18, Y+9	; 0x09
    61d2:	3a 85       	ldd	r19, Y+10	; 0x0a
    61d4:	4b 85       	ldd	r20, Y+11	; 0x0b
    61d6:	5c 85       	ldd	r21, Y+12	; 0x0c
    61d8:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    61dc:	20 e0       	ldi	r18, 0x00	; 0
    61de:	30 e0       	ldi	r19, 0x00	; 0
    61e0:	40 e0       	ldi	r20, 0x00	; 0
    61e2:	5f e3       	ldi	r21, 0x3F	; 63
    61e4:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    61e8:	6b 01       	movw	r12, r22
    61ea:	7c 01       	movw	r14, r24
                0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
        if (intersect_distance > 0.0) {
    61ec:	20 e0       	ldi	r18, 0x00	; 0
    61ee:	30 e0       	ldi	r19, 0x00	; 0
    61f0:	a9 01       	movw	r20, r18
    61f2:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    61f6:	18 16       	cp	r1, r24
    61f8:	0c f0       	brlt	.+2      	; 0x61fc <st_prep_buffer+0x3a8>
    61fa:	a9 c0       	rjmp	.+338    	; 0x634e <st_prep_buffer+0x4fa>
          if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
    61fc:	a7 01       	movw	r20, r14
    61fe:	96 01       	movw	r18, r12
    6200:	69 85       	ldd	r22, Y+9	; 0x09
    6202:	7a 85       	ldd	r23, Y+10	; 0x0a
    6204:	8b 85       	ldd	r24, Y+11	; 0x0b
    6206:	9c 85       	ldd	r25, Y+12	; 0x0c
    6208:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    620c:	18 16       	cp	r1, r24
    620e:	0c f0       	brlt	.+2      	; 0x6212 <st_prep_buffer+0x3be>
    6210:	8d c0       	rjmp	.+282    	; 0x632c <st_prep_buffer+0x4d8>
            // NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
            prep.decelerate_after = inv_2_accel*(pl_block->nominal_speed_sqr-exit_speed_sqr);
    6212:	29 81       	ldd	r18, Y+1	; 0x01
    6214:	3a 81       	ldd	r19, Y+2	; 0x02
    6216:	4b 81       	ldd	r20, Y+3	; 0x03
    6218:	5c 81       	ldd	r21, Y+4	; 0x04
    621a:	ed 81       	ldd	r30, Y+5	; 0x05
    621c:	fe 81       	ldd	r31, Y+6	; 0x06
    621e:	65 8d       	ldd	r22, Z+29	; 0x1d
    6220:	76 8d       	ldd	r23, Z+30	; 0x1e
    6222:	87 8d       	ldd	r24, Z+31	; 0x1f
    6224:	90 a1       	ldd	r25, Z+32	; 0x20
    6226:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    622a:	a5 01       	movw	r20, r10
    622c:	94 01       	movw	r18, r8
    622e:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    6232:	9b 01       	movw	r18, r22
    6234:	ac 01       	movw	r20, r24
    6236:	d3 01       	movw	r26, r6
    6238:	97 96       	adiw	r26, 0x27	; 39
    623a:	6d 93       	st	X+, r22
    623c:	7d 93       	st	X+, r23
    623e:	8d 93       	st	X+, r24
    6240:	9c 93       	st	X, r25
    6242:	9a 97       	sbiw	r26, 0x2a	; 42
            if (prep.decelerate_after < intersect_distance) { // Trapezoid type
    6244:	c7 01       	movw	r24, r14
    6246:	b6 01       	movw	r22, r12
    6248:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    624c:	18 16       	cp	r1, r24
    624e:	0c f0       	brlt	.+2      	; 0x6252 <st_prep_buffer+0x3fe>
    6250:	41 c0       	rjmp	.+130    	; 0x62d4 <st_prep_buffer+0x480>
              prep.maximum_speed = sqrt(pl_block->nominal_speed_sqr);
    6252:	ed 81       	ldd	r30, Y+5	; 0x05
    6254:	fe 81       	ldd	r31, Y+6	; 0x06
    6256:	65 8d       	ldd	r22, Z+29	; 0x1d
    6258:	76 8d       	ldd	r23, Z+30	; 0x1e
    625a:	87 8d       	ldd	r24, Z+31	; 0x1f
    625c:	90 a1       	ldd	r25, Z+32	; 0x20
    625e:	0e 94 a0 3c 	call	0x7940	; 0x7940 <sqrt>
    6262:	d3 01       	movw	r26, r6
    6264:	5b 96       	adiw	r26, 0x1b	; 27
    6266:	6d 93       	st	X+, r22
    6268:	7d 93       	st	X+, r23
    626a:	8d 93       	st	X+, r24
    626c:	9c 93       	st	X, r25
    626e:	5e 97       	sbiw	r26, 0x1e	; 30
              if (pl_block->entry_speed_sqr == pl_block->nominal_speed_sqr) { 
    6270:	ed 81       	ldd	r30, Y+5	; 0x05
    6272:	fe 81       	ldd	r31, Y+6	; 0x06
    6274:	c1 88       	ldd	r12, Z+17	; 0x11
    6276:	d2 88       	ldd	r13, Z+18	; 0x12
    6278:	e3 88       	ldd	r14, Z+19	; 0x13
    627a:	f4 88       	ldd	r15, Z+20	; 0x14
    627c:	25 8c       	ldd	r2, Z+29	; 0x1d
    627e:	36 8c       	ldd	r3, Z+30	; 0x1e
    6280:	47 8c       	ldd	r4, Z+31	; 0x1f
    6282:	50 a0       	ldd	r5, Z+32	; 0x20
    6284:	a2 01       	movw	r20, r4
    6286:	91 01       	movw	r18, r2
    6288:	c7 01       	movw	r24, r14
    628a:	b6 01       	movw	r22, r12
    628c:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    6290:	81 11       	cpse	r24, r1
    6292:	05 c0       	rjmp	.+10     	; 0x629e <st_prep_buffer+0x44a>
                // Cruise-deceleration or cruise-only type.
                prep.ramp_type = RAMP_CRUISE;
    6294:	e1 e0       	ldi	r30, 0x01	; 1
    6296:	d3 01       	movw	r26, r6
    6298:	52 96       	adiw	r26, 0x12	; 18
    629a:	ec 93       	st	X, r30
    629c:	64 c0       	rjmp	.+200    	; 0x6366 <st_prep_buffer+0x512>
              } else {
                // Full-trapezoid or acceleration-cruise types
                prep.accelerate_until -= inv_2_accel*(pl_block->nominal_speed_sqr-pl_block->entry_speed_sqr); 
    629e:	a7 01       	movw	r20, r14
    62a0:	96 01       	movw	r18, r12
    62a2:	c2 01       	movw	r24, r4
    62a4:	b1 01       	movw	r22, r2
    62a6:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    62aa:	a5 01       	movw	r20, r10
    62ac:	94 01       	movw	r18, r8
    62ae:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    62b2:	9b 01       	movw	r18, r22
    62b4:	ac 01       	movw	r20, r24
    62b6:	d3 01       	movw	r26, r6
    62b8:	93 96       	adiw	r26, 0x23	; 35
    62ba:	6d 91       	ld	r22, X+
    62bc:	7d 91       	ld	r23, X+
    62be:	8d 91       	ld	r24, X+
    62c0:	9c 91       	ld	r25, X
    62c2:	96 97       	sbiw	r26, 0x26	; 38
    62c4:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    62c8:	f3 01       	movw	r30, r6
    62ca:	63 a3       	std	Z+35, r22	; 0x23
    62cc:	74 a3       	std	Z+36, r23	; 0x24
    62ce:	85 a3       	std	Z+37, r24	; 0x25
    62d0:	96 a3       	std	Z+38, r25	; 0x26
    62d2:	49 c0       	rjmp	.+146    	; 0x6366 <st_prep_buffer+0x512>
              }
            } else { // Triangle type
              prep.accelerate_until = intersect_distance;
    62d4:	d3 01       	movw	r26, r6
    62d6:	93 96       	adiw	r26, 0x23	; 35
    62d8:	cd 92       	st	X+, r12
    62da:	dd 92       	st	X+, r13
    62dc:	ed 92       	st	X+, r14
    62de:	fc 92       	st	X, r15
    62e0:	96 97       	sbiw	r26, 0x26	; 38
              prep.decelerate_after = intersect_distance;
    62e2:	f3 01       	movw	r30, r6
    62e4:	c7 a2       	std	Z+39, r12	; 0x27
    62e6:	d0 a6       	std	Z+40, r13	; 0x28
    62e8:	e1 a6       	std	Z+41, r14	; 0x29
    62ea:	f2 a6       	std	Z+42, r15	; 0x2a
              prep.maximum_speed = sqrt(2.0*pl_block->acceleration*intersect_distance+exit_speed_sqr);
    62ec:	ad 81       	ldd	r26, Y+5	; 0x05
    62ee:	be 81       	ldd	r27, Y+6	; 0x06
    62f0:	91 96       	adiw	r26, 0x21	; 33
    62f2:	8d 90       	ld	r8, X+
    62f4:	9d 90       	ld	r9, X+
    62f6:	ad 90       	ld	r10, X+
    62f8:	bc 90       	ld	r11, X
    62fa:	94 97       	sbiw	r26, 0x24	; 36
    62fc:	a5 01       	movw	r20, r10
    62fe:	94 01       	movw	r18, r8
    6300:	c5 01       	movw	r24, r10
    6302:	b4 01       	movw	r22, r8
    6304:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    6308:	a7 01       	movw	r20, r14
    630a:	96 01       	movw	r18, r12
    630c:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    6310:	29 81       	ldd	r18, Y+1	; 0x01
    6312:	3a 81       	ldd	r19, Y+2	; 0x02
    6314:	4b 81       	ldd	r20, Y+3	; 0x03
    6316:	5c 81       	ldd	r21, Y+4	; 0x04
    6318:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    631c:	0e 94 a0 3c 	call	0x7940	; 0x7940 <sqrt>
    6320:	f3 01       	movw	r30, r6
    6322:	63 8f       	std	Z+27, r22	; 0x1b
    6324:	74 8f       	std	Z+28, r23	; 0x1c
    6326:	85 8f       	std	Z+29, r24	; 0x1d
    6328:	96 8f       	std	Z+30, r25	; 0x1e
    632a:	1d c0       	rjmp	.+58     	; 0x6366 <st_prep_buffer+0x512>
            }          
          } else { // Deceleration-only type
            prep.ramp_type = RAMP_DECEL;
    632c:	e2 e0       	ldi	r30, 0x02	; 2
    632e:	d3 01       	movw	r26, r6
    6330:	52 96       	adiw	r26, 0x12	; 18
    6332:	ec 93       	st	X, r30
    6334:	52 97       	sbiw	r26, 0x12	; 18
            // prep.decelerate_after = pl_block->millimeters;
            prep.maximum_speed = prep.current_speed;
    6336:	57 96       	adiw	r26, 0x17	; 23
    6338:	8d 91       	ld	r24, X+
    633a:	9d 91       	ld	r25, X+
    633c:	0d 90       	ld	r0, X+
    633e:	bc 91       	ld	r27, X
    6340:	a0 2d       	mov	r26, r0
    6342:	f3 01       	movw	r30, r6
    6344:	83 8f       	std	Z+27, r24	; 0x1b
    6346:	94 8f       	std	Z+28, r25	; 0x1c
    6348:	a5 8f       	std	Z+29, r26	; 0x1d
    634a:	b6 8f       	std	Z+30, r27	; 0x1e
    634c:	0c c0       	rjmp	.+24     	; 0x6366 <st_prep_buffer+0x512>
          }
        } else { // Acceleration-only type
          prep.accelerate_until = 0.0;
    634e:	d3 01       	movw	r26, r6
    6350:	93 96       	adiw	r26, 0x23	; 35
    6352:	1d 92       	st	X+, r1
    6354:	1d 92       	st	X+, r1
    6356:	1d 92       	st	X+, r1
    6358:	1c 92       	st	X, r1
    635a:	96 97       	sbiw	r26, 0x26	; 38
          // prep.decelerate_after = 0.0;
          prep.maximum_speed = prep.exit_speed;
    635c:	f3 01       	movw	r30, r6
    635e:	23 8e       	std	Z+27, r2	; 0x1b
    6360:	34 8e       	std	Z+28, r3	; 0x1c
    6362:	45 8e       	std	Z+29, r4	; 0x1d
    6364:	56 8e       	std	Z+30, r5	; 0x1e
        }
      }  
    }

    // Initialize new segment
    segment_t *prep_segment = &segment_buffer[segment_buffer_head];
    6366:	e0 91 87 04 	lds	r30, 0x0487	; 0x800487 <segment_buffer_head>
    636a:	2e 2f       	mov	r18, r30
    636c:	30 e0       	ldi	r19, 0x00	; 0
    636e:	3a a7       	std	Y+42, r19	; 0x2a
    6370:	29 a7       	std	Y+41, r18	; 0x29

    // Set new segment to point to the current segment data block.
    prep_segment->st_block_index = prep.st_block_index;
    6372:	f9 01       	movw	r30, r18
    6374:	ee 0f       	add	r30, r30
    6376:	ff 1f       	adc	r31, r31
    6378:	e2 0f       	add	r30, r18
    637a:	f3 1f       	adc	r31, r19
    637c:	ee 0f       	add	r30, r30
    637e:	ff 1f       	adc	r31, r31
    6380:	e4 55       	subi	r30, 0x54	; 84
    6382:	fb 4f       	sbci	r31, 0xFB	; 251
    6384:	d3 01       	movw	r26, r6
    6386:	8c 91       	ld	r24, X
    6388:	82 83       	std	Z+2, r24	; 0x02
    float dt_max = DT_SEGMENT; // Maximum segment time
    float dt = 0.0; // Initialize segment time
    float time_var = dt_max; // Time worker variable
    float mm_var; // mm-Distance worker variable
    float speed_var; // Speed worker variable   
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    638a:	e0 91 81 04 	lds	r30, 0x0481	; 0x800481 <pl_block>
    638e:	f0 91 82 04 	lds	r31, 0x0482	; 0x800482 <pl_block+0x1>
    6392:	f8 a3       	std	Y+32, r31	; 0x20
    6394:	ef 8f       	std	Y+31, r30	; 0x1f
    6396:	f5 a1       	ldd	r31, Z+37	; 0x25
    6398:	f8 ab       	std	Y+48, r31	; 0x30
    639a:	af 8d       	ldd	r26, Y+31	; 0x1f
    639c:	b8 a1       	ldd	r27, Y+32	; 0x20
    639e:	96 96       	adiw	r26, 0x26	; 38
    63a0:	bc 91       	ld	r27, X
    63a2:	b9 ab       	std	Y+49, r27	; 0x31
    63a4:	ef 8d       	ldd	r30, Y+31	; 0x1f
    63a6:	f8 a1       	ldd	r31, Y+32	; 0x20
    63a8:	f7 a1       	ldd	r31, Z+39	; 0x27
    63aa:	fa ab       	std	Y+50, r31	; 0x32
    63ac:	af 8d       	ldd	r26, Y+31	; 0x1f
    63ae:	b8 a1       	ldd	r27, Y+32	; 0x20
    63b0:	98 96       	adiw	r26, 0x28	; 40
    63b2:	bc 91       	ld	r27, X
    63b4:	bb ab       	std	Y+51, r27	; 0x33
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    63b6:	f3 01       	movw	r30, r6
    63b8:	22 85       	ldd	r18, Z+10	; 0x0a
    63ba:	33 85       	ldd	r19, Z+11	; 0x0b
    63bc:	44 85       	ldd	r20, Z+12	; 0x0c
    63be:	55 85       	ldd	r21, Z+13	; 0x0d
    63c0:	68 a9       	ldd	r22, Y+48	; 0x30
    63c2:	79 a9       	ldd	r23, Y+49	; 0x31
    63c4:	8a a9       	ldd	r24, Y+50	; 0x32
    63c6:	9b 2f       	mov	r25, r27
    63c8:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    63cc:	6b a7       	std	Y+43, r22	; 0x2b
    63ce:	7c a7       	std	Y+44, r23	; 0x2c
    63d0:	8d a7       	std	Y+45, r24	; 0x2d
    63d2:	9e a7       	std	Y+46, r25	; 0x2e
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }
    63d4:	20 e0       	ldi	r18, 0x00	; 0
    63d6:	30 e0       	ldi	r19, 0x00	; 0
    63d8:	a9 01       	movw	r20, r18
    63da:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    63de:	88 23       	and	r24, r24
    63e0:	24 f4       	brge	.+8      	; 0x63ea <st_prep_buffer+0x596>
    63e2:	1b a6       	std	Y+43, r1	; 0x2b
    63e4:	1c a6       	std	Y+44, r1	; 0x2c
    63e6:	1d a6       	std	Y+45, r1	; 0x2d
    63e8:	1e a6       	std	Y+46, r1	; 0x2e
    63ea:	d3 01       	movw	r26, r6
    63ec:	57 96       	adiw	r26, 0x17	; 23
    63ee:	bc 91       	ld	r27, X
    63f0:	b9 87       	std	Y+9, r27	; 0x09
    63f2:	f3 01       	movw	r30, r6
    63f4:	f0 8d       	ldd	r31, Z+24	; 0x18
    63f6:	fd 87       	std	Y+13, r31	; 0x0d
    63f8:	d3 01       	movw	r26, r6
    63fa:	59 96       	adiw	r26, 0x19	; 25
    63fc:	bc 91       	ld	r27, X
    63fe:	b9 8b       	std	Y+17, r27	; 0x11
    6400:	f3 01       	movw	r30, r6
    6402:	f2 8d       	ldd	r31, Z+26	; 0x1a
    6404:	fd 8b       	std	Y+21, r31	; 0x15
      switch (prep.ramp_type) {
        case RAMP_ACCEL: 
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    6406:	d3 01       	movw	r26, r6
    6408:	93 96       	adiw	r26, 0x23	; 35
    640a:	bc 91       	ld	r27, X
    640c:	b9 a3       	std	Y+33, r27	; 0x21
    640e:	f3 01       	movw	r30, r6
    6410:	f4 a1       	ldd	r31, Z+36	; 0x24
    6412:	fa a3       	std	Y+34, r31	; 0x22
    6414:	d3 01       	movw	r26, r6
    6416:	95 96       	adiw	r26, 0x25	; 37
    6418:	bc 91       	ld	r27, X
    641a:	bb a3       	std	Y+35, r27	; 0x23
    641c:	f3 01       	movw	r30, r6
    641e:	f6 a1       	ldd	r31, Z+38	; 0x26
    6420:	fc a3       	std	Y+36, r31	; 0x24
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    6422:	d3 01       	movw	r26, r6
    6424:	5b 96       	adiw	r26, 0x1b	; 27
    6426:	bc 91       	ld	r27, X
    6428:	bb 8f       	std	Y+27, r27	; 0x1b
    642a:	f3 01       	movw	r30, r6
    642c:	f4 8d       	ldd	r31, Z+28	; 0x1c
    642e:	fc 8f       	std	Y+28, r31	; 0x1c
    6430:	d3 01       	movw	r26, r6
    6432:	5d 96       	adiw	r26, 0x1d	; 29
    6434:	bc 91       	ld	r27, X
    6436:	bd 8f       	std	Y+29, r27	; 0x1d
    6438:	f3 01       	movw	r30, r6
    643a:	f6 8d       	ldd	r31, Z+30	; 0x1e
    643c:	fe 8f       	std	Y+30, r31	; 0x1e
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    643e:	d3 01       	movw	r26, r6
    6440:	97 96       	adiw	r26, 0x27	; 39
    6442:	bc 91       	ld	r27, X
    6444:	bd a3       	std	Y+37, r27	; 0x25
    6446:	f3 01       	movw	r30, r6
    6448:	f0 a5       	ldd	r31, Z+40	; 0x28
    644a:	fe a3       	std	Y+38, r31	; 0x26
    644c:	d3 01       	movw	r26, r6
    644e:	99 96       	adiw	r26, 0x29	; 41
    6450:	bc 91       	ld	r27, X
    6452:	bf a3       	std	Y+39, r27	; 0x27
    6454:	f3 01       	movw	r30, r6
    6456:	f2 a5       	ldd	r31, Z+42	; 0x2a
    6458:	f8 a7       	std	Y+40, r31	; 0x28
    645a:	d3 01       	movw	r26, r6
    645c:	52 96       	adiw	r26, 0x12	; 18
    645e:	bc 91       	ld	r27, X
    6460:	bd 83       	std	Y+5, r27	; 0x05
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Deceleration only.
    6462:	f3 01       	movw	r30, r6
    6464:	f3 89       	ldd	r31, Z+19	; 0x13
    6466:	fe 8b       	std	Y+22, r31	; 0x16
    6468:	d3 01       	movw	r26, r6
    646a:	54 96       	adiw	r26, 0x14	; 20
    646c:	bc 91       	ld	r27, X
    646e:	bf 8b       	std	Y+23, r27	; 0x17
    6470:	f3 01       	movw	r30, r6
    6472:	f5 89       	ldd	r31, Z+21	; 0x15
    6474:	f8 8f       	std	Y+24, r31	; 0x18
    6476:	d3 01       	movw	r26, r6
    6478:	56 96       	adiw	r26, 0x16	; 22
    647a:	bc 91       	ld	r27, X
    647c:	b9 8f       	std	Y+25, r27	; 0x19
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    647e:	d3 01       	movw	r26, r6
    6480:	5f 96       	adiw	r26, 0x1f	; 31
    6482:	2d 91       	ld	r18, X+
    6484:	3d 91       	ld	r19, X+
    6486:	4d 91       	ld	r20, X+
    6488:	5c 91       	ld	r21, X
    648a:	92 97       	sbiw	r26, 0x22	; 34
    648c:	2c ab       	std	Y+52, r18	; 0x34
    648e:	3d ab       	std	Y+53, r19	; 0x35
    6490:	4e ab       	std	Y+54, r20	; 0x36
    6492:	5f ab       	std	Y+55, r21	; 0x37
    6494:	2d a1       	ldd	r18, Y+37	; 0x25
    6496:	3e a1       	ldd	r19, Y+38	; 0x26
    6498:	4f a1       	ldd	r20, Y+39	; 0x27
    649a:	58 a5       	ldd	r21, Y+40	; 0x28
    649c:	69 a1       	ldd	r22, Y+33	; 0x21
    649e:	7a a1       	ldd	r23, Y+34	; 0x22
    64a0:	8b a1       	ldd	r24, Y+35	; 0x23
    64a2:	9c a1       	ldd	r25, Y+36	; 0x24
    64a4:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    64a8:	81 11       	cpse	r24, r1
    64aa:	02 c0       	rjmp	.+4      	; 0x64b0 <st_prep_buffer+0x65c>
    64ac:	82 e0       	ldi	r24, 0x02	; 2
    64ae:	01 c0       	rjmp	.+2      	; 0x64b2 <st_prep_buffer+0x65e>
    64b0:	81 e0       	ldi	r24, 0x01	; 1
    64b2:	e8 a8       	ldd	r14, Y+48	; 0x30
    64b4:	f9 a8       	ldd	r15, Y+49	; 0x31
    64b6:	0a a9       	ldd	r16, Y+50	; 0x32
    64b8:	1b a9       	ldd	r17, Y+51	; 0x33
    64ba:	0f 2e       	mov	r0, r31
    64bc:	fe e3       	ldi	r31, 0x3E	; 62
    64be:	5f 2e       	mov	r5, r31
    64c0:	f0 2d       	mov	r31, r0
    64c2:	0f 2e       	mov	r0, r31
    64c4:	f3 ec       	ldi	r31, 0xC3	; 195
    64c6:	4f 2e       	mov	r4, r31
    64c8:	f0 2d       	mov	r31, r0
    64ca:	0f 2e       	mov	r0, r31
    64cc:	fe e2       	ldi	r31, 0x2E	; 46
    64ce:	3f 2e       	mov	r3, r31
    64d0:	f0 2d       	mov	r31, r0
    64d2:	0f 2e       	mov	r0, r31
    64d4:	f9 e3       	ldi	r31, 0x39	; 57
    64d6:	2f 2e       	mov	r2, r31
    64d8:	f0 2d       	mov	r31, r0
    64da:	81 2c       	mov	r8, r1
    64dc:	91 2c       	mov	r9, r1
    64de:	54 01       	movw	r10, r8
    64e0:	be e3       	ldi	r27, 0x3E	; 62
    64e2:	ba 8f       	std	Y+26, r27	; 0x1a
    64e4:	e3 ec       	ldi	r30, 0xC3	; 195
    64e6:	e9 83       	std	Y+1, r30	; 0x01
    64e8:	0f 2e       	mov	r0, r31
    64ea:	fe e2       	ldi	r31, 0x2E	; 46
    64ec:	cf 2e       	mov	r12, r31
    64ee:	f0 2d       	mov	r31, r0
    64f0:	0f 2e       	mov	r0, r31
    64f2:	f9 e3       	ldi	r31, 0x39	; 57
    64f4:	df 2e       	mov	r13, r31
    64f6:	f0 2d       	mov	r31, r0
    64f8:	88 af       	std	Y+56, r24	; 0x38
    64fa:	7b ae       	std	Y+59, r7	; 0x3b
    64fc:	6a ae       	std	Y+58, r6	; 0x3a
    64fe:	0f 2e       	mov	r0, r31
    6500:	fe e3       	ldi	r31, 0x3E	; 62
    6502:	7f 2e       	mov	r7, r31
    6504:	f0 2d       	mov	r31, r0
    6506:	8d 2d       	mov	r24, r13
    6508:	dc 2c       	mov	r13, r12
    650a:	9f 2d       	mov	r25, r15
    650c:	fe 2c       	mov	r15, r14
    650e:	0d af       	std	Y+61, r16	; 0x3d
    6510:	01 2f       	mov	r16, r17
    6512:	1d 81       	ldd	r17, Y+5	; 0x05
    6514:	e9 2e       	mov	r14, r25
    6516:	c8 2e       	mov	r12, r24
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }

    do {
      switch (prep.ramp_type) {
    6518:	11 23       	and	r17, r17
    651a:	21 f0       	breq	.+8      	; 0x6524 <st_prep_buffer+0x6d0>
    651c:	11 30       	cpi	r17, 0x01	; 1
    651e:	09 f4       	brne	.+2      	; 0x6522 <st_prep_buffer+0x6ce>
    6520:	7b c0       	rjmp	.+246    	; 0x6618 <st_prep_buffer+0x7c4>
    6522:	b8 c0       	rjmp	.+368    	; 0x6694 <st_prep_buffer+0x840>
        case RAMP_ACCEL: 
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
    6524:	af 8d       	ldd	r26, Y+31	; 0x1f
    6526:	b8 a1       	ldd	r27, Y+32	; 0x20
    6528:	91 96       	adiw	r26, 0x21	; 33
    652a:	2d 91       	ld	r18, X+
    652c:	3d 91       	ld	r19, X+
    652e:	4d 91       	ld	r20, X+
    6530:	5c 91       	ld	r21, X
    6532:	94 97       	sbiw	r26, 0x24	; 36
    6534:	65 2d       	mov	r22, r5
    6536:	74 2d       	mov	r23, r4
    6538:	83 2d       	mov	r24, r3
    653a:	92 2d       	mov	r25, r2
    653c:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    6540:	6d 83       	std	Y+5, r22	; 0x05
    6542:	7e 83       	std	Y+6, r23	; 0x06
    6544:	8f 83       	std	Y+7, r24	; 0x07
    6546:	98 87       	std	Y+8, r25	; 0x08
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
    6548:	20 e0       	ldi	r18, 0x00	; 0
    654a:	30 e0       	ldi	r19, 0x00	; 0
    654c:	40 e0       	ldi	r20, 0x00	; 0
    654e:	5f e3       	ldi	r21, 0x3F	; 63
    6550:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    6554:	29 85       	ldd	r18, Y+9	; 0x09
    6556:	3d 85       	ldd	r19, Y+13	; 0x0d
    6558:	49 89       	ldd	r20, Y+17	; 0x11
    655a:	5d 89       	ldd	r21, Y+21	; 0x15
    655c:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    6560:	25 2d       	mov	r18, r5
    6562:	34 2d       	mov	r19, r4
    6564:	43 2d       	mov	r20, r3
    6566:	52 2d       	mov	r21, r2
    6568:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    656c:	9b 01       	movw	r18, r22
    656e:	ac 01       	movw	r20, r24
    6570:	6f 2d       	mov	r22, r15
    6572:	7e 2d       	mov	r23, r14
    6574:	8d ad       	ldd	r24, Y+61	; 0x3d
    6576:	90 2f       	mov	r25, r16
    6578:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    657c:	f6 2e       	mov	r15, r22
    657e:	e7 2e       	mov	r14, r23
    6580:	8d af       	std	Y+61, r24	; 0x3d
    6582:	09 2f       	mov	r16, r25
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    6584:	29 a1       	ldd	r18, Y+33	; 0x21
    6586:	3a a1       	ldd	r19, Y+34	; 0x22
    6588:	4b a1       	ldd	r20, Y+35	; 0x23
    658a:	5c a1       	ldd	r21, Y+36	; 0x24
    658c:	0e 94 9f 39 	call	0x733e	; 0x733e <__cmpsf2>
    6590:	88 23       	and	r24, r24
    6592:	9c f5       	brge	.+102    	; 0x65fa <st_prep_buffer+0x7a6>
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    6594:	29 a1       	ldd	r18, Y+33	; 0x21
    6596:	3a a1       	ldd	r19, Y+34	; 0x22
    6598:	4b a1       	ldd	r20, Y+35	; 0x23
    659a:	5c a1       	ldd	r21, Y+36	; 0x24
    659c:	68 a9       	ldd	r22, Y+48	; 0x30
    659e:	79 a9       	ldd	r23, Y+49	; 0x31
    65a0:	8a a9       	ldd	r24, Y+50	; 0x32
    65a2:	9b a9       	ldd	r25, Y+51	; 0x33
    65a4:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    65a8:	9b 01       	movw	r18, r22
    65aa:	ac 01       	movw	r20, r24
    65ac:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    65b0:	1b 01       	movw	r2, r22
    65b2:	2c 01       	movw	r4, r24
    65b4:	29 85       	ldd	r18, Y+9	; 0x09
    65b6:	3d 85       	ldd	r19, Y+13	; 0x0d
    65b8:	49 89       	ldd	r20, Y+17	; 0x11
    65ba:	5d 89       	ldd	r21, Y+21	; 0x15
    65bc:	6b 8d       	ldd	r22, Y+27	; 0x1b
    65be:	7c 8d       	ldd	r23, Y+28	; 0x1c
    65c0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    65c2:	9e 8d       	ldd	r25, Y+30	; 0x1e
    65c4:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    65c8:	9b 01       	movw	r18, r22
    65ca:	ac 01       	movw	r20, r24
    65cc:	c2 01       	movw	r24, r4
    65ce:	b1 01       	movw	r22, r2
    65d0:	0e 94 a9 39 	call	0x7352	; 0x7352 <__divsf3>
    65d4:	56 2e       	mov	r5, r22
    65d6:	47 2e       	mov	r4, r23
    65d8:	38 2e       	mov	r3, r24
    65da:	29 2e       	mov	r2, r25
    65dc:	18 ad       	ldd	r17, Y+56	; 0x38
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
    65de:	bb 8d       	ldd	r27, Y+27	; 0x1b
    65e0:	b9 87       	std	Y+9, r27	; 0x09
    65e2:	ec 8d       	ldd	r30, Y+28	; 0x1c
    65e4:	ed 87       	std	Y+13, r30	; 0x0d
    65e6:	fd 8d       	ldd	r31, Y+29	; 0x1d
    65e8:	f9 8b       	std	Y+17, r31	; 0x11
    65ea:	2e 8d       	ldd	r18, Y+30	; 0x1e
    65ec:	2d 8b       	std	Y+21, r18	; 0x15
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
    65ee:	f9 a0       	ldd	r15, Y+33	; 0x21
    65f0:	ea a0       	ldd	r14, Y+34	; 0x22
    65f2:	3b a1       	ldd	r19, Y+35	; 0x23
    65f4:	3d af       	std	Y+61, r19	; 0x3d
    65f6:	0c a1       	ldd	r16, Y+36	; 0x24
    65f8:	d7 c0       	rjmp	.+430    	; 0x67a8 <st_prep_buffer+0x954>
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
          } else { // Acceleration only. 
            prep.current_speed += speed_var;
    65fa:	2d 81       	ldd	r18, Y+5	; 0x05
    65fc:	3e 81       	ldd	r19, Y+6	; 0x06
    65fe:	4f 81       	ldd	r20, Y+7	; 0x07
    6600:	58 85       	ldd	r21, Y+8	; 0x08
    6602:	69 85       	ldd	r22, Y+9	; 0x09
    6604:	7d 85       	ldd	r23, Y+13	; 0x0d
    6606:	89 89       	ldd	r24, Y+17	; 0x11
    6608:	9d 89       	ldd	r25, Y+21	; 0x15
    660a:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    660e:	69 87       	std	Y+9, r22	; 0x09
    6610:	7d 87       	std	Y+13, r23	; 0x0d
    6612:	89 8b       	std	Y+17, r24	; 0x11
    6614:	9d 8b       	std	Y+21, r25	; 0x15
    6616:	c8 c0       	rjmp	.+400    	; 0x67a8 <st_prep_buffer+0x954>
          break;
        case RAMP_CRUISE: 
          // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
          // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To 
          //   prevent this, simply enforce a minimum speed threshold in the planner.
          mm_var = mm_remaining - prep.maximum_speed*time_var;
    6618:	2b 8d       	ldd	r18, Y+27	; 0x1b
    661a:	3c 8d       	ldd	r19, Y+28	; 0x1c
    661c:	4d 8d       	ldd	r20, Y+29	; 0x1d
    661e:	5e 8d       	ldd	r21, Y+30	; 0x1e
    6620:	65 2d       	mov	r22, r5
    6622:	74 2d       	mov	r23, r4
    6624:	83 2d       	mov	r24, r3
    6626:	92 2d       	mov	r25, r2
    6628:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    662c:	9b 01       	movw	r18, r22
    662e:	ac 01       	movw	r20, r24
    6630:	6f 2d       	mov	r22, r15
    6632:	7e 2d       	mov	r23, r14
    6634:	8d ad       	ldd	r24, Y+61	; 0x3d
    6636:	90 2f       	mov	r25, r16
    6638:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    663c:	6d 83       	std	Y+5, r22	; 0x05
    663e:	7a 8f       	std	Y+26, r23	; 0x1a
    6640:	68 2e       	mov	r6, r24
    6642:	9f a7       	std	Y+47, r25	; 0x2f
          if (mm_var < prep.decelerate_after) { // End of cruise. 
    6644:	26 2f       	mov	r18, r22
    6646:	37 2f       	mov	r19, r23
    6648:	48 2f       	mov	r20, r24
    664a:	59 2f       	mov	r21, r25
    664c:	6d a1       	ldd	r22, Y+37	; 0x25
    664e:	7e a1       	ldd	r23, Y+38	; 0x26
    6650:	8f a1       	ldd	r24, Y+39	; 0x27
    6652:	98 a5       	ldd	r25, Y+40	; 0x28
    6654:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    6658:	18 16       	cp	r1, r24
    665a:	0c f0       	brlt	.+2      	; 0x665e <st_prep_buffer+0x80a>
    665c:	a1 c0       	rjmp	.+322    	; 0x67a0 <st_prep_buffer+0x94c>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
    665e:	2d a1       	ldd	r18, Y+37	; 0x25
    6660:	3e a1       	ldd	r19, Y+38	; 0x26
    6662:	4f a1       	ldd	r20, Y+39	; 0x27
    6664:	58 a5       	ldd	r21, Y+40	; 0x28
    6666:	6f 2d       	mov	r22, r15
    6668:	7e 2d       	mov	r23, r14
    666a:	8d ad       	ldd	r24, Y+61	; 0x3d
    666c:	90 2f       	mov	r25, r16
    666e:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    6672:	2b 8d       	ldd	r18, Y+27	; 0x1b
    6674:	3c 8d       	ldd	r19, Y+28	; 0x1c
    6676:	4d 8d       	ldd	r20, Y+29	; 0x1d
    6678:	5e 8d       	ldd	r21, Y+30	; 0x1e
    667a:	0e 94 a9 39 	call	0x7352	; 0x7352 <__divsf3>
    667e:	56 2e       	mov	r5, r22
    6680:	47 2e       	mov	r4, r23
    6682:	38 2e       	mov	r3, r24
    6684:	29 2e       	mov	r2, r25
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
    6686:	fd a0       	ldd	r15, Y+37	; 0x25
    6688:	ee a0       	ldd	r14, Y+38	; 0x26
    668a:	4f a1       	ldd	r20, Y+39	; 0x27
    668c:	4d af       	std	Y+61, r20	; 0x3d
    668e:	08 a5       	ldd	r16, Y+40	; 0x28
            prep.ramp_type = RAMP_DECEL;
    6690:	19 ad       	ldd	r17, Y+57	; 0x39
    6692:	8a c0       	rjmp	.+276    	; 0x67a8 <st_prep_buffer+0x954>
            mm_remaining = mm_var; 
          } 
          break;
        default: // case RAMP_DECEL:
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
    6694:	af 8d       	ldd	r26, Y+31	; 0x1f
    6696:	b8 a1       	ldd	r27, Y+32	; 0x20
    6698:	91 96       	adiw	r26, 0x21	; 33
    669a:	2d 91       	ld	r18, X+
    669c:	3d 91       	ld	r19, X+
    669e:	4d 91       	ld	r20, X+
    66a0:	5c 91       	ld	r21, X
    66a2:	94 97       	sbiw	r26, 0x24	; 36
    66a4:	65 2d       	mov	r22, r5
    66a6:	74 2d       	mov	r23, r4
    66a8:	83 2d       	mov	r24, r3
    66aa:	92 2d       	mov	r25, r2
    66ac:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    66b0:	6d 83       	std	Y+5, r22	; 0x05
    66b2:	7e 83       	std	Y+6, r23	; 0x06
    66b4:	8f 83       	std	Y+7, r24	; 0x07
    66b6:	98 87       	std	Y+8, r25	; 0x08
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
    66b8:	9b 01       	movw	r18, r22
    66ba:	ac 01       	movw	r20, r24
    66bc:	69 85       	ldd	r22, Y+9	; 0x09
    66be:	7d 85       	ldd	r23, Y+13	; 0x0d
    66c0:	89 89       	ldd	r24, Y+17	; 0x11
    66c2:	9d 89       	ldd	r25, Y+21	; 0x15
    66c4:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    66c8:	18 16       	cp	r1, r24
    66ca:	0c f0       	brlt	.+2      	; 0x66ce <st_prep_buffer+0x87a>
    66cc:	3f c0       	rjmp	.+126    	; 0x674c <st_prep_buffer+0x8f8>
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
    66ce:	20 e0       	ldi	r18, 0x00	; 0
    66d0:	30 e0       	ldi	r19, 0x00	; 0
    66d2:	40 e0       	ldi	r20, 0x00	; 0
    66d4:	5f e3       	ldi	r21, 0x3F	; 63
    66d6:	6d 81       	ldd	r22, Y+5	; 0x05
    66d8:	7e 81       	ldd	r23, Y+6	; 0x06
    66da:	8f 81       	ldd	r24, Y+7	; 0x07
    66dc:	98 85       	ldd	r25, Y+8	; 0x08
    66de:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    66e2:	9b 01       	movw	r18, r22
    66e4:	ac 01       	movw	r20, r24
    66e6:	69 85       	ldd	r22, Y+9	; 0x09
    66e8:	7d 85       	ldd	r23, Y+13	; 0x0d
    66ea:	89 89       	ldd	r24, Y+17	; 0x11
    66ec:	9d 89       	ldd	r25, Y+21	; 0x15
    66ee:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    66f2:	25 2d       	mov	r18, r5
    66f4:	34 2d       	mov	r19, r4
    66f6:	43 2d       	mov	r20, r3
    66f8:	52 2d       	mov	r21, r2
    66fa:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    66fe:	9b 01       	movw	r18, r22
    6700:	ac 01       	movw	r20, r24
    6702:	6f 2d       	mov	r22, r15
    6704:	7e 2d       	mov	r23, r14
    6706:	8d ad       	ldd	r24, Y+61	; 0x3d
    6708:	90 2f       	mov	r25, r16
    670a:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    670e:	6a 8f       	std	Y+26, r22	; 0x1a
    6710:	7f a7       	std	Y+47, r23	; 0x2f
    6712:	68 2e       	mov	r6, r24
    6714:	9c af       	std	Y+60, r25	; 0x3c
            if (mm_var > prep.mm_complete) { // Deceleration only.
    6716:	2e 89       	ldd	r18, Y+22	; 0x16
    6718:	3f 89       	ldd	r19, Y+23	; 0x17
    671a:	48 8d       	ldd	r20, Y+24	; 0x18
    671c:	59 8d       	ldd	r21, Y+25	; 0x19
    671e:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    6722:	18 16       	cp	r1, r24
    6724:	9c f4       	brge	.+38     	; 0x674c <st_prep_buffer+0x8f8>
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
    6726:	2d 81       	ldd	r18, Y+5	; 0x05
    6728:	3e 81       	ldd	r19, Y+6	; 0x06
    672a:	4f 81       	ldd	r20, Y+7	; 0x07
    672c:	58 85       	ldd	r21, Y+8	; 0x08
    672e:	69 85       	ldd	r22, Y+9	; 0x09
    6730:	7d 85       	ldd	r23, Y+13	; 0x0d
    6732:	89 89       	ldd	r24, Y+17	; 0x11
    6734:	9d 89       	ldd	r25, Y+21	; 0x15
    6736:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    673a:	69 87       	std	Y+9, r22	; 0x09
    673c:	7d 87       	std	Y+13, r23	; 0x0d
    673e:	89 8b       	std	Y+17, r24	; 0x11
    6740:	9d 8b       	std	Y+21, r25	; 0x15
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Deceleration only.
              mm_remaining = mm_var;
    6742:	fa 8c       	ldd	r15, Y+26	; 0x1a
    6744:	ef a4       	ldd	r14, Y+47	; 0x2f
    6746:	6d ae       	std	Y+61, r6	; 0x3d
    6748:	0c ad       	ldd	r16, Y+60	; 0x3c
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
    674a:	2e c0       	rjmp	.+92     	; 0x67a8 <st_prep_buffer+0x954>
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    674c:	2e 89       	ldd	r18, Y+22	; 0x16
    674e:	3f 89       	ldd	r19, Y+23	; 0x17
    6750:	48 8d       	ldd	r20, Y+24	; 0x18
    6752:	59 8d       	ldd	r21, Y+25	; 0x19
    6754:	6f 2d       	mov	r22, r15
    6756:	7e 2d       	mov	r23, r14
    6758:	8d ad       	ldd	r24, Y+61	; 0x3d
    675a:	90 2f       	mov	r25, r16
    675c:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    6760:	9b 01       	movw	r18, r22
    6762:	ac 01       	movw	r20, r24
    6764:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    6768:	1b 01       	movw	r2, r22
    676a:	2c 01       	movw	r4, r24
    676c:	2c a9       	ldd	r18, Y+52	; 0x34
    676e:	3d a9       	ldd	r19, Y+53	; 0x35
    6770:	4e a9       	ldd	r20, Y+54	; 0x36
    6772:	5f a9       	ldd	r21, Y+55	; 0x37
    6774:	69 85       	ldd	r22, Y+9	; 0x09
    6776:	7d 85       	ldd	r23, Y+13	; 0x0d
    6778:	89 89       	ldd	r24, Y+17	; 0x11
    677a:	9d 89       	ldd	r25, Y+21	; 0x15
    677c:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    6780:	9b 01       	movw	r18, r22
    6782:	ac 01       	movw	r20, r24
    6784:	c2 01       	movw	r24, r4
    6786:	b1 01       	movw	r22, r2
    6788:	0e 94 a9 39 	call	0x7352	; 0x7352 <__divsf3>
    678c:	56 2e       	mov	r5, r22
    678e:	47 2e       	mov	r4, r23
    6790:	38 2e       	mov	r3, r24
    6792:	29 2e       	mov	r2, r25
          mm_remaining = prep.mm_complete; 
    6794:	fe 88       	ldd	r15, Y+22	; 0x16
    6796:	ef 88       	ldd	r14, Y+23	; 0x17
    6798:	b8 8d       	ldd	r27, Y+24	; 0x18
    679a:	bd af       	std	Y+61, r27	; 0x3d
    679c:	09 8d       	ldd	r16, Y+25	; 0x19
    679e:	04 c0       	rjmp	.+8      	; 0x67a8 <st_prep_buffer+0x954>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
          } else { // Cruising only.         
            mm_remaining = mm_var; 
    67a0:	fd 80       	ldd	r15, Y+5	; 0x05
    67a2:	ea 8c       	ldd	r14, Y+26	; 0x1a
    67a4:	6d ae       	std	Y+61, r6	; 0x3d
    67a6:	0f a5       	ldd	r16, Y+47	; 0x2f
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete; 
      }
      dt += time_var; // Add computed ramp time to total segment time.
    67a8:	25 2d       	mov	r18, r5
    67aa:	34 2d       	mov	r19, r4
    67ac:	43 2d       	mov	r20, r3
    67ae:	52 2d       	mov	r21, r2
    67b0:	c5 01       	movw	r24, r10
    67b2:	b4 01       	movw	r22, r8
    67b4:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    67b8:	4b 01       	movw	r8, r22
    67ba:	5c 01       	movw	r10, r24
      if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
    67bc:	9b 01       	movw	r18, r22
    67be:	ac 01       	movw	r20, r24
    67c0:	67 2d       	mov	r22, r7
    67c2:	79 81       	ldd	r23, Y+1	; 0x01
    67c4:	8d 2d       	mov	r24, r13
    67c6:	9c 2d       	mov	r25, r12
    67c8:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    67cc:	18 16       	cp	r1, r24
    67ce:	6c f4       	brge	.+26     	; 0x67ea <st_prep_buffer+0x996>
    67d0:	a5 01       	movw	r20, r10
    67d2:	94 01       	movw	r18, r8
    67d4:	67 2d       	mov	r22, r7
    67d6:	79 81       	ldd	r23, Y+1	; 0x01
    67d8:	8d 2d       	mov	r24, r13
    67da:	9c 2d       	mov	r25, r12
    67dc:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    67e0:	56 2e       	mov	r5, r22
    67e2:	47 2e       	mov	r4, r23
    67e4:	38 2e       	mov	r3, r24
    67e6:	29 2e       	mov	r2, r25
    67e8:	36 c0       	rjmp	.+108    	; 0x6856 <st_prep_buffer+0xa02>
      else {
        if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
    67ea:	2b a5       	ldd	r18, Y+43	; 0x2b
    67ec:	3c a5       	ldd	r19, Y+44	; 0x2c
    67ee:	4d a5       	ldd	r20, Y+45	; 0x2d
    67f0:	5e a5       	ldd	r21, Y+46	; 0x2e
    67f2:	6f 2d       	mov	r22, r15
    67f4:	7e 2d       	mov	r23, r14
    67f6:	8d ad       	ldd	r24, Y+61	; 0x3d
    67f8:	90 2f       	mov	r25, r16
    67fa:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    67fe:	18 16       	cp	r1, r24
    6800:	a4 f0       	brlt	.+40     	; 0x682a <st_prep_buffer+0x9d6>
    6802:	1d 83       	std	Y+5, r17	; 0x05
    6804:	6a ac       	ldd	r6, Y+58	; 0x3a
    6806:	7b ac       	ldd	r7, Y+59	; 0x3b
    6808:	8e 2d       	mov	r24, r14
    680a:	ef 2c       	mov	r14, r15
    680c:	10 2f       	mov	r17, r16
    680e:	0d ad       	ldd	r16, Y+61	; 0x3d
    6810:	f8 2e       	mov	r15, r24
    6812:	89 85       	ldd	r24, Y+9	; 0x09
    6814:	9d 85       	ldd	r25, Y+13	; 0x0d
    6816:	a9 89       	ldd	r26, Y+17	; 0x11
    6818:	bd 89       	ldd	r27, Y+21	; 0x15
    681a:	f3 01       	movw	r30, r6
    681c:	87 8b       	std	Z+23, r24	; 0x17
    681e:	90 8f       	std	Z+24, r25	; 0x18
    6820:	a1 8f       	std	Z+25, r26	; 0x19
    6822:	b2 8f       	std	Z+26, r27	; 0x1a
    6824:	2d 81       	ldd	r18, Y+5	; 0x05
    6826:	22 8b       	std	Z+18, r18	; 0x12
    6828:	36 c0       	rjmp	.+108    	; 0x6896 <st_prep_buffer+0xa42>
          // Increase segment time to ensure at least one step in segment. Override and loop
          // through distance calculations until minimum_mm or mm_complete.
          dt_max += DT_SEGMENT;
    682a:	2e e3       	ldi	r18, 0x3E	; 62
    682c:	33 ec       	ldi	r19, 0xC3	; 195
    682e:	4e e2       	ldi	r20, 0x2E	; 46
    6830:	59 e3       	ldi	r21, 0x39	; 57
    6832:	67 2d       	mov	r22, r7
    6834:	79 81       	ldd	r23, Y+1	; 0x01
    6836:	8d 2d       	mov	r24, r13
    6838:	9c 2d       	mov	r25, r12
    683a:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    683e:	76 2e       	mov	r7, r22
    6840:	79 83       	std	Y+1, r23	; 0x01
    6842:	d8 2e       	mov	r13, r24
    6844:	c9 2e       	mov	r12, r25
          time_var = dt_max - dt;
    6846:	a5 01       	movw	r20, r10
    6848:	94 01       	movw	r18, r8
    684a:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    684e:	56 2e       	mov	r5, r22
    6850:	47 2e       	mov	r4, r23
    6852:	38 2e       	mov	r3, r24
    6854:	29 2e       	mov	r2, r25
        } else { 
          break; // **Complete** Exit loop. Segment execution time maxed.
        }
      }
    } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
    6856:	2e 89       	ldd	r18, Y+22	; 0x16
    6858:	3f 89       	ldd	r19, Y+23	; 0x17
    685a:	48 8d       	ldd	r20, Y+24	; 0x18
    685c:	59 8d       	ldd	r21, Y+25	; 0x19
    685e:	6f 2d       	mov	r22, r15
    6860:	7e 2d       	mov	r23, r14
    6862:	8d ad       	ldd	r24, Y+61	; 0x3d
    6864:	90 2f       	mov	r25, r16
    6866:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    686a:	18 16       	cp	r1, r24
    686c:	0c f4       	brge	.+2      	; 0x6870 <st_prep_buffer+0xa1c>
    686e:	54 ce       	rjmp	.-856    	; 0x6518 <st_prep_buffer+0x6c4>
    6870:	1d 83       	std	Y+5, r17	; 0x05
    6872:	6a ac       	ldd	r6, Y+58	; 0x3a
    6874:	7b ac       	ldd	r7, Y+59	; 0x3b
    6876:	8e 2d       	mov	r24, r14
    6878:	ef 2c       	mov	r14, r15
    687a:	10 2f       	mov	r17, r16
    687c:	0d ad       	ldd	r16, Y+61	; 0x3d
    687e:	f8 2e       	mov	r15, r24
    6880:	89 85       	ldd	r24, Y+9	; 0x09
    6882:	9d 85       	ldd	r25, Y+13	; 0x0d
    6884:	a9 89       	ldd	r26, Y+17	; 0x11
    6886:	bd 89       	ldd	r27, Y+21	; 0x15
    6888:	f3 01       	movw	r30, r6
    688a:	87 8b       	std	Z+23, r24	; 0x17
    688c:	90 8f       	std	Z+24, r25	; 0x18
    688e:	a1 8f       	std	Z+25, r26	; 0x19
    6890:	b2 8f       	std	Z+26, r27	; 0x1a
    6892:	2d 81       	ldd	r18, Y+5	; 0x05
    6894:	22 8b       	std	Z+18, r18	; 0x12
       However, since floats have only 7.2 significant digits, long moves with extremely 
       high step counts can exceed the precision of floats, which can lead to lost steps.
       Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
       supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    */
    float steps_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
    6896:	d3 01       	movw	r26, r6
    6898:	16 96       	adiw	r26, 0x06	; 6
    689a:	8d 91       	ld	r24, X+
    689c:	9d 91       	ld	r25, X+
    689e:	0d 90       	ld	r0, X+
    68a0:	bc 91       	ld	r27, X
    68a2:	a0 2d       	mov	r26, r0
    68a4:	89 8b       	std	Y+17, r24	; 0x11
    68a6:	9a 8b       	std	Y+18, r25	; 0x12
    68a8:	ab 8b       	std	Y+19, r26	; 0x13
    68aa:	bc 8b       	std	Y+20, r27	; 0x14
    68ac:	9c 01       	movw	r18, r24
    68ae:	ad 01       	movw	r20, r26
    68b0:	6e 2d       	mov	r22, r14
    68b2:	7f 2d       	mov	r23, r15
    68b4:	80 2f       	mov	r24, r16
    68b6:	91 2f       	mov	r25, r17
    68b8:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    68bc:	69 83       	std	Y+1, r22	; 0x01
    68be:	7a 83       	std	Y+2, r23	; 0x02
    68c0:	8b 83       	std	Y+3, r24	; 0x03
    68c2:	9c 83       	std	Y+4, r25	; 0x04
    float n_steps_remaining = ceil(steps_remaining); // Round-up current steps remaining
    68c4:	0e 94 88 39 	call	0x7310	; 0x7310 <ceil>
    68c8:	1b 01       	movw	r2, r22
    68ca:	2c 01       	movw	r4, r24
    float last_n_steps_remaining = ceil(prep.steps_remaining); // Round-up last steps remaining
    68cc:	f3 01       	movw	r30, r6
    68ce:	62 81       	ldd	r22, Z+2	; 0x02
    68d0:	73 81       	ldd	r23, Z+3	; 0x03
    68d2:	84 81       	ldd	r24, Z+4	; 0x04
    68d4:	95 81       	ldd	r25, Z+5	; 0x05
    68d6:	0e 94 88 39 	call	0x7310	; 0x7310 <ceil>
    68da:	6d 87       	std	Y+13, r22	; 0x0d
    68dc:	7e 87       	std	Y+14, r23	; 0x0e
    68de:	8f 87       	std	Y+15, r24	; 0x0f
    68e0:	98 8b       	std	Y+16, r25	; 0x10
    prep_segment->n_step = last_n_steps_remaining-n_steps_remaining; // Compute number of steps to execute.
    68e2:	a2 01       	movw	r20, r4
    68e4:	91 01       	movw	r18, r2
    68e6:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    68ea:	0e 94 22 3a 	call	0x7444	; 0x7444 <__fixunssfsi>
    68ee:	69 87       	std	Y+9, r22	; 0x09
    68f0:	7a 87       	std	Y+10, r23	; 0x0a
    68f2:	8b 87       	std	Y+11, r24	; 0x0b
    68f4:	9c 87       	std	Y+12, r25	; 0x0c
    68f6:	e9 a5       	ldd	r30, Y+41	; 0x29
    68f8:	fa a5       	ldd	r31, Y+42	; 0x2a
    68fa:	ee 0f       	add	r30, r30
    68fc:	ff 1f       	adc	r31, r31
    68fe:	29 a5       	ldd	r18, Y+41	; 0x29
    6900:	3a a5       	ldd	r19, Y+42	; 0x2a
    6902:	e2 0f       	add	r30, r18
    6904:	f3 1f       	adc	r31, r19
    6906:	ee 0f       	add	r30, r30
    6908:	ff 1f       	adc	r31, r31
    690a:	e4 55       	subi	r30, 0x54	; 84
    690c:	fb 4f       	sbci	r31, 0xFB	; 251
    690e:	49 85       	ldd	r20, Y+9	; 0x09
    6910:	5a 85       	ldd	r21, Y+10	; 0x0a
    6912:	51 83       	std	Z+1, r21	; 0x01
    6914:	40 83       	st	Z, r20
    
    // Bail if we are at the end of a feed hold and don't have a step to execute.
    if (prep_segment->n_step == 0) {
    6916:	ca 01       	movw	r24, r20
    6918:	89 2b       	or	r24, r25
    691a:	31 f5       	brne	.+76     	; 0x6968 <st_prep_buffer+0xb14>
      if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) {
    691c:	80 91 a1 05 	lds	r24, 0x05A1	; 0x8005a1 <sys+0x1>
    6920:	80 77       	andi	r24, 0x70	; 112
    6922:	11 f1       	breq	.+68     	; 0x6968 <st_prep_buffer+0xb14>
    6924:	0f 8d       	ldd	r16, Y+31	; 0x1f
    6926:	18 a1       	ldd	r17, Y+32	; 0x20
        // Less than one step to decelerate to zero speed, but already very close. AMASS 
        // requires full steps to execute. So, just bail.
        prep.current_speed = 0.0; // NOTE: (=0.0) Used to indicate completed segment calcs for hold.
    6928:	e6 e5       	ldi	r30, 0x56	; 86
    692a:	f4 e0       	ldi	r31, 0x04	; 4
    692c:	17 8a       	std	Z+23, r1	; 0x17
    692e:	10 8e       	std	Z+24, r1	; 0x18
    6930:	11 8e       	std	Z+25, r1	; 0x19
    6932:	12 8e       	std	Z+26, r1	; 0x1a
        prep.dt_remainder = 0.0;
    6934:	16 86       	std	Z+14, r1	; 0x0e
    6936:	17 86       	std	Z+15, r1	; 0x0f
    6938:	10 8a       	std	Z+16, r1	; 0x10
    693a:	11 8a       	std	Z+17, r1	; 0x11
        prep.steps_remaining = n_steps_remaining;
    693c:	22 82       	std	Z+2, r2	; 0x02
    693e:	33 82       	std	Z+3, r3	; 0x03
    6940:	44 82       	std	Z+4, r4	; 0x04
    6942:	55 82       	std	Z+5, r5	; 0x05
        pl_block->millimeters = prep.steps_remaining/prep.step_per_mm; // Update with full steps.
    6944:	29 89       	ldd	r18, Y+17	; 0x11
    6946:	3a 89       	ldd	r19, Y+18	; 0x12
    6948:	4b 89       	ldd	r20, Y+19	; 0x13
    694a:	5c 89       	ldd	r21, Y+20	; 0x14
    694c:	c2 01       	movw	r24, r4
    694e:	b1 01       	movw	r22, r2
    6950:	0e 94 a9 39 	call	0x7352	; 0x7352 <__divsf3>
    6954:	d8 01       	movw	r26, r16
    6956:	95 96       	adiw	r26, 0x25	; 37
    6958:	6d 93       	st	X+, r22
    695a:	7d 93       	st	X+, r23
    695c:	8d 93       	st	X+, r24
    695e:	9c 93       	st	X, r25
    6960:	98 97       	sbiw	r26, 0x28	; 40
        plan_cycle_reinitialize();         
    6962:	0e 94 b3 1e 	call	0x3d66	; 0x3d66 <plan_cycle_reinitialize>
        return; // Segment not generated, but current step data still retained.
    6966:	45 c1       	rjmp	.+650    	; 0x6bf2 <st_prep_buffer+0xd9e>
    // apply it with the partial step distance to the current segment, so that it minutely
    // adjusts the whole segment rate to keep step output exact. These rate adjustments are 
    // typically very small and do not adversely effect performance, but ensures that Grbl
    // outputs the exact acceleration and velocity profiles as computed by the planner.
    dt += prep.dt_remainder; // Apply previous segment partial step execute time
    float inv_rate = dt/(last_n_steps_remaining - steps_remaining); // Compute adjusted step rate inverse
    6968:	f3 01       	movw	r30, r6
    696a:	26 85       	ldd	r18, Z+14	; 0x0e
    696c:	37 85       	ldd	r19, Z+15	; 0x0f
    696e:	40 89       	ldd	r20, Z+16	; 0x10
    6970:	51 89       	ldd	r21, Z+17	; 0x11
    6972:	c5 01       	movw	r24, r10
    6974:	b4 01       	movw	r22, r8
    6976:	0e 94 aa 38 	call	0x7154	; 0x7154 <__addsf3>
    697a:	4b 01       	movw	r8, r22
    697c:	5c 01       	movw	r10, r24
    697e:	29 81       	ldd	r18, Y+1	; 0x01
    6980:	3a 81       	ldd	r19, Y+2	; 0x02
    6982:	4b 81       	ldd	r20, Y+3	; 0x03
    6984:	5c 81       	ldd	r21, Y+4	; 0x04
    6986:	6d 85       	ldd	r22, Y+13	; 0x0d
    6988:	7e 85       	ldd	r23, Y+14	; 0x0e
    698a:	8f 85       	ldd	r24, Y+15	; 0x0f
    698c:	98 89       	ldd	r25, Y+16	; 0x10
    698e:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    6992:	9b 01       	movw	r18, r22
    6994:	ac 01       	movw	r20, r24
    6996:	c5 01       	movw	r24, r10
    6998:	b4 01       	movw	r22, r8
    699a:	0e 94 a9 39 	call	0x7352	; 0x7352 <__divsf3>
    699e:	4b 01       	movw	r8, r22
    69a0:	5c 01       	movw	r10, r24
    prep.dt_remainder = (n_steps_remaining - steps_remaining)*inv_rate; // Update segment partial step time
    69a2:	29 81       	ldd	r18, Y+1	; 0x01
    69a4:	3a 81       	ldd	r19, Y+2	; 0x02
    69a6:	4b 81       	ldd	r20, Y+3	; 0x03
    69a8:	5c 81       	ldd	r21, Y+4	; 0x04
    69aa:	c2 01       	movw	r24, r4
    69ac:	b1 01       	movw	r22, r2
    69ae:	0e 94 a9 38 	call	0x7152	; 0x7152 <__subsf3>
    69b2:	a5 01       	movw	r20, r10
    69b4:	94 01       	movw	r18, r8
    69b6:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    69ba:	d3 01       	movw	r26, r6
    69bc:	1e 96       	adiw	r26, 0x0e	; 14
    69be:	6d 93       	st	X+, r22
    69c0:	7d 93       	st	X+, r23
    69c2:	8d 93       	st	X+, r24
    69c4:	9c 93       	st	X, r25
    69c6:	51 97       	sbiw	r26, 0x11	; 17

    // Compute CPU cycles per step for the prepped segment.
    uint32_t cycles = ceil( (TICKS_PER_MICROSECOND*1000000*60)*inv_rate ); // (cycles/step)    
    69c8:	20 ec       	ldi	r18, 0xC0	; 192
    69ca:	31 ee       	ldi	r19, 0xE1	; 225
    69cc:	44 e6       	ldi	r20, 0x64	; 100
    69ce:	5e e4       	ldi	r21, 0x4E	; 78
    69d0:	c5 01       	movw	r24, r10
    69d2:	b4 01       	movw	r22, r8
    69d4:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    69d8:	0e 94 88 39 	call	0x7310	; 0x7310 <ceil>
    69dc:	0e 94 22 3a 	call	0x7444	; 0x7444 <__fixunssfsi>

    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING        
      // Compute step timing and multi-axis smoothing level.
      // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
      if (cycles < AMASS_LEVEL1) { prep_segment->amass_level = 0; }
    69e0:	60 3d       	cpi	r22, 0xD0	; 208
    69e2:	b7 e0       	ldi	r27, 0x07	; 7
    69e4:	7b 07       	cpc	r23, r27
    69e6:	81 05       	cpc	r24, r1
    69e8:	91 05       	cpc	r25, r1
    69ea:	70 f4       	brcc	.+28     	; 0x6a08 <st_prep_buffer+0xbb4>
    69ec:	e9 a5       	ldd	r30, Y+41	; 0x29
    69ee:	fa a5       	ldd	r31, Y+42	; 0x2a
    69f0:	ee 0f       	add	r30, r30
    69f2:	ff 1f       	adc	r31, r31
    69f4:	29 a5       	ldd	r18, Y+41	; 0x29
    69f6:	3a a5       	ldd	r19, Y+42	; 0x2a
    69f8:	e2 0f       	add	r30, r18
    69fa:	f3 1f       	adc	r31, r19
    69fc:	ee 0f       	add	r30, r30
    69fe:	ff 1f       	adc	r31, r31
    6a00:	e4 55       	subi	r30, 0x54	; 84
    6a02:	fb 4f       	sbci	r31, 0xFB	; 251
    6a04:	15 82       	std	Z+5, r1	; 0x05
    6a06:	56 c0       	rjmp	.+172    	; 0x6ab4 <st_prep_buffer+0xc60>
      else {
        if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
    6a08:	60 3a       	cpi	r22, 0xA0	; 160
    6a0a:	3f e0       	ldi	r19, 0x0F	; 15
    6a0c:	73 07       	cpc	r23, r19
    6a0e:	81 05       	cpc	r24, r1
    6a10:	91 05       	cpc	r25, r1
    6a12:	78 f4       	brcc	.+30     	; 0x6a32 <st_prep_buffer+0xbde>
    6a14:	e9 a5       	ldd	r30, Y+41	; 0x29
    6a16:	fa a5       	ldd	r31, Y+42	; 0x2a
    6a18:	ee 0f       	add	r30, r30
    6a1a:	ff 1f       	adc	r31, r31
    6a1c:	49 a5       	ldd	r20, Y+41	; 0x29
    6a1e:	5a a5       	ldd	r21, Y+42	; 0x2a
    6a20:	e4 0f       	add	r30, r20
    6a22:	f5 1f       	adc	r31, r21
    6a24:	ee 0f       	add	r30, r30
    6a26:	ff 1f       	adc	r31, r31
    6a28:	e4 55       	subi	r30, 0x54	; 84
    6a2a:	fb 4f       	sbci	r31, 0xFB	; 251
    6a2c:	51 e0       	ldi	r21, 0x01	; 1
    6a2e:	55 83       	std	Z+5, r21	; 0x05
    6a30:	23 c0       	rjmp	.+70     	; 0x6a78 <st_prep_buffer+0xc24>
        else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
    6a32:	60 34       	cpi	r22, 0x40	; 64
    6a34:	af e1       	ldi	r26, 0x1F	; 31
    6a36:	7a 07       	cpc	r23, r26
    6a38:	81 05       	cpc	r24, r1
    6a3a:	91 05       	cpc	r25, r1
    6a3c:	78 f4       	brcc	.+30     	; 0x6a5c <st_prep_buffer+0xc08>
    6a3e:	e9 a5       	ldd	r30, Y+41	; 0x29
    6a40:	fa a5       	ldd	r31, Y+42	; 0x2a
    6a42:	ee 0f       	add	r30, r30
    6a44:	ff 1f       	adc	r31, r31
    6a46:	29 a5       	ldd	r18, Y+41	; 0x29
    6a48:	3a a5       	ldd	r19, Y+42	; 0x2a
    6a4a:	e2 0f       	add	r30, r18
    6a4c:	f3 1f       	adc	r31, r19
    6a4e:	ee 0f       	add	r30, r30
    6a50:	ff 1f       	adc	r31, r31
    6a52:	e4 55       	subi	r30, 0x54	; 84
    6a54:	fb 4f       	sbci	r31, 0xFB	; 251
    6a56:	32 e0       	ldi	r19, 0x02	; 2
    6a58:	35 83       	std	Z+5, r19	; 0x05
    6a5a:	0e c0       	rjmp	.+28     	; 0x6a78 <st_prep_buffer+0xc24>
        else { prep_segment->amass_level = 3; }    
    6a5c:	e9 a5       	ldd	r30, Y+41	; 0x29
    6a5e:	fa a5       	ldd	r31, Y+42	; 0x2a
    6a60:	ee 0f       	add	r30, r30
    6a62:	ff 1f       	adc	r31, r31
    6a64:	49 a5       	ldd	r20, Y+41	; 0x29
    6a66:	5a a5       	ldd	r21, Y+42	; 0x2a
    6a68:	e4 0f       	add	r30, r20
    6a6a:	f5 1f       	adc	r31, r21
    6a6c:	ee 0f       	add	r30, r30
    6a6e:	ff 1f       	adc	r31, r31
    6a70:	e4 55       	subi	r30, 0x54	; 84
    6a72:	fb 4f       	sbci	r31, 0xFB	; 251
    6a74:	53 e0       	ldi	r21, 0x03	; 3
    6a76:	55 83       	std	Z+5, r21	; 0x05
        cycles >>= prep_segment->amass_level; 
    6a78:	e9 a5       	ldd	r30, Y+41	; 0x29
    6a7a:	fa a5       	ldd	r31, Y+42	; 0x2a
    6a7c:	ee 0f       	add	r30, r30
    6a7e:	ff 1f       	adc	r31, r31
    6a80:	a9 a5       	ldd	r26, Y+41	; 0x29
    6a82:	ba a5       	ldd	r27, Y+42	; 0x2a
    6a84:	ea 0f       	add	r30, r26
    6a86:	fb 1f       	adc	r31, r27
    6a88:	ee 0f       	add	r30, r30
    6a8a:	ff 1f       	adc	r31, r31
    6a8c:	e4 55       	subi	r30, 0x54	; 84
    6a8e:	fb 4f       	sbci	r31, 0xFB	; 251
    6a90:	25 81       	ldd	r18, Z+5	; 0x05
    6a92:	02 2e       	mov	r0, r18
    6a94:	04 c0       	rjmp	.+8      	; 0x6a9e <st_prep_buffer+0xc4a>
    6a96:	96 95       	lsr	r25
    6a98:	87 95       	ror	r24
    6a9a:	77 95       	ror	r23
    6a9c:	67 95       	ror	r22
    6a9e:	0a 94       	dec	r0
    6aa0:	d2 f7       	brpl	.-12     	; 0x6a96 <st_prep_buffer+0xc42>
        prep_segment->n_step <<= prep_segment->amass_level;
    6aa2:	49 85       	ldd	r20, Y+9	; 0x09
    6aa4:	5a 85       	ldd	r21, Y+10	; 0x0a
    6aa6:	02 c0       	rjmp	.+4      	; 0x6aac <st_prep_buffer+0xc58>
    6aa8:	44 0f       	add	r20, r20
    6aaa:	55 1f       	adc	r21, r21
    6aac:	2a 95       	dec	r18
    6aae:	e2 f7       	brpl	.-8      	; 0x6aa8 <st_prep_buffer+0xc54>
    6ab0:	51 83       	std	Z+1, r21	; 0x01
    6ab2:	40 83       	st	Z, r20
      }
      if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
    6ab4:	61 15       	cp	r22, r1
    6ab6:	71 05       	cpc	r23, r1
    6ab8:	51 e0       	ldi	r21, 0x01	; 1
    6aba:	85 07       	cpc	r24, r21
    6abc:	91 05       	cpc	r25, r1
    6abe:	78 f4       	brcc	.+30     	; 0x6ade <st_prep_buffer+0xc8a>
    6ac0:	e9 a5       	ldd	r30, Y+41	; 0x29
    6ac2:	fa a5       	ldd	r31, Y+42	; 0x2a
    6ac4:	ee 0f       	add	r30, r30
    6ac6:	ff 1f       	adc	r31, r31
    6ac8:	a9 a5       	ldd	r26, Y+41	; 0x29
    6aca:	ba a5       	ldd	r27, Y+42	; 0x2a
    6acc:	ea 0f       	add	r30, r26
    6ace:	fb 1f       	adc	r31, r27
    6ad0:	ee 0f       	add	r30, r30
    6ad2:	ff 1f       	adc	r31, r31
    6ad4:	e4 55       	subi	r30, 0x54	; 84
    6ad6:	fb 4f       	sbci	r31, 0xFB	; 251
    6ad8:	74 83       	std	Z+4, r23	; 0x04
    6ada:	63 83       	std	Z+3, r22	; 0x03
    6adc:	10 c0       	rjmp	.+32     	; 0x6afe <st_prep_buffer+0xcaa>
      else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
    6ade:	e9 a5       	ldd	r30, Y+41	; 0x29
    6ae0:	fa a5       	ldd	r31, Y+42	; 0x2a
    6ae2:	ee 0f       	add	r30, r30
    6ae4:	ff 1f       	adc	r31, r31
    6ae6:	29 a5       	ldd	r18, Y+41	; 0x29
    6ae8:	3a a5       	ldd	r19, Y+42	; 0x2a
    6aea:	e2 0f       	add	r30, r18
    6aec:	f3 1f       	adc	r31, r19
    6aee:	ee 0f       	add	r30, r30
    6af0:	ff 1f       	adc	r31, r31
    6af2:	e4 55       	subi	r30, 0x54	; 84
    6af4:	fb 4f       	sbci	r31, 0xFB	; 251
    6af6:	4f ef       	ldi	r20, 0xFF	; 255
    6af8:	5f ef       	ldi	r21, 0xFF	; 255
    6afa:	54 83       	std	Z+4, r21	; 0x04
    6afc:	43 83       	std	Z+3, r20	; 0x03
        }
      }
    #endif

    // Segment complete! Increment segment buffer indices.
    segment_buffer_head = segment_next_head;
    6afe:	80 91 86 04 	lds	r24, 0x0486	; 0x800486 <segment_next_head>
    6b02:	80 93 87 04 	sts	0x0487, r24	; 0x800487 <segment_buffer_head>
    if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
    6b06:	8f 5f       	subi	r24, 0xFF	; 255
    6b08:	86 30       	cpi	r24, 0x06	; 6
    6b0a:	19 f0       	breq	.+6      	; 0x6b12 <st_prep_buffer+0xcbe>
    6b0c:	80 93 86 04 	sts	0x0486, r24	; 0x800486 <segment_next_head>
    6b10:	02 c0       	rjmp	.+4      	; 0x6b16 <st_prep_buffer+0xcc2>
    6b12:	10 92 86 04 	sts	0x0486, r1	; 0x800486 <segment_next_head>

    // Setup initial conditions for next segment.
    if (mm_remaining > prep.mm_complete) { 
    6b16:	d3 01       	movw	r26, r6
    6b18:	53 96       	adiw	r26, 0x13	; 19
    6b1a:	2d 91       	ld	r18, X+
    6b1c:	3d 91       	ld	r19, X+
    6b1e:	4d 91       	ld	r20, X+
    6b20:	5c 91       	ld	r21, X
    6b22:	56 97       	sbiw	r26, 0x16	; 22
    6b24:	6e 2d       	mov	r22, r14
    6b26:	7f 2d       	mov	r23, r15
    6b28:	80 2f       	mov	r24, r16
    6b2a:	91 2f       	mov	r25, r17
    6b2c:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    6b30:	18 16       	cp	r1, r24
    6b32:	c4 f4       	brge	.+48     	; 0x6b64 <st_prep_buffer+0xd10>
      // Normal operation. Block incomplete. Distance remaining in block to be executed.
      pl_block->millimeters = mm_remaining;      
    6b34:	e0 91 81 04 	lds	r30, 0x0481	; 0x800481 <pl_block>
    6b38:	f0 91 82 04 	lds	r31, 0x0482	; 0x800482 <pl_block+0x1>
    6b3c:	8e 2d       	mov	r24, r14
    6b3e:	9f 2d       	mov	r25, r15
    6b40:	a0 2f       	mov	r26, r16
    6b42:	b1 2f       	mov	r27, r17
    6b44:	85 a3       	std	Z+37, r24	; 0x25
    6b46:	96 a3       	std	Z+38, r25	; 0x26
    6b48:	a7 a3       	std	Z+39, r26	; 0x27
    6b4a:	b0 a7       	std	Z+40, r27	; 0x28
      prep.steps_remaining = steps_remaining;  
    6b4c:	29 81       	ldd	r18, Y+1	; 0x01
    6b4e:	3a 81       	ldd	r19, Y+2	; 0x02
    6b50:	4b 81       	ldd	r20, Y+3	; 0x03
    6b52:	5c 81       	ldd	r21, Y+4	; 0x04
    6b54:	d3 01       	movw	r26, r6
    6b56:	12 96       	adiw	r26, 0x02	; 2
    6b58:	2d 93       	st	X+, r18
    6b5a:	3d 93       	st	X+, r19
    6b5c:	4d 93       	st	X+, r20
    6b5e:	5c 93       	st	X, r21
    6b60:	15 97       	sbiw	r26, 0x05	; 5
    6b62:	41 c0       	rjmp	.+130    	; 0x6be6 <st_prep_buffer+0xd92>
    } else { 
      // End of planner block or forced-termination. No more distance to be executed.
      if (mm_remaining > 0.0) { // At end of forced-termination.
    6b64:	20 e0       	ldi	r18, 0x00	; 0
    6b66:	30 e0       	ldi	r19, 0x00	; 0
    6b68:	a9 01       	movw	r20, r18
    6b6a:	6e 2d       	mov	r22, r14
    6b6c:	7f 2d       	mov	r23, r15
    6b6e:	80 2f       	mov	r24, r16
    6b70:	91 2f       	mov	r25, r17
    6b72:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    6b76:	18 16       	cp	r1, r24
    6b78:	3c f5       	brge	.+78     	; 0x6bc8 <st_prep_buffer+0xd74>
        // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
        // the segment queue, where realtime protocol will set new state upon receiving the 
        // cycle stop flag from the ISR. Prep_segment is blocked until then.
        prep.current_speed = 0.0; // NOTE: (=0.0) Used to indicate completed segment calcs for hold.
    6b7a:	e6 e5       	ldi	r30, 0x56	; 86
    6b7c:	f4 e0       	ldi	r31, 0x04	; 4
    6b7e:	17 8a       	std	Z+23, r1	; 0x17
    6b80:	10 8e       	std	Z+24, r1	; 0x18
    6b82:	11 8e       	std	Z+25, r1	; 0x19
    6b84:	12 8e       	std	Z+26, r1	; 0x1a
        prep.dt_remainder = 0.0;
    6b86:	16 86       	std	Z+14, r1	; 0x0e
    6b88:	17 86       	std	Z+15, r1	; 0x0f
    6b8a:	10 8a       	std	Z+16, r1	; 0x10
    6b8c:	11 8a       	std	Z+17, r1	; 0x11
        prep.steps_remaining = ceil(steps_remaining);
    6b8e:	22 82       	std	Z+2, r2	; 0x02
    6b90:	33 82       	std	Z+3, r3	; 0x03
    6b92:	44 82       	std	Z+4, r4	; 0x04
    6b94:	55 82       	std	Z+5, r5	; 0x05
        pl_block->millimeters = prep.steps_remaining/prep.step_per_mm; // Update with full steps.
    6b96:	20 91 81 04 	lds	r18, 0x0481	; 0x800481 <pl_block>
    6b9a:	30 91 82 04 	lds	r19, 0x0482	; 0x800482 <pl_block+0x1>
    6b9e:	3a 83       	std	Y+2, r19	; 0x02
    6ba0:	29 83       	std	Y+1, r18	; 0x01
    6ba2:	26 81       	ldd	r18, Z+6	; 0x06
    6ba4:	37 81       	ldd	r19, Z+7	; 0x07
    6ba6:	40 85       	ldd	r20, Z+8	; 0x08
    6ba8:	51 85       	ldd	r21, Z+9	; 0x09
    6baa:	c2 01       	movw	r24, r4
    6bac:	b1 01       	movw	r22, r2
    6bae:	0e 94 a9 39 	call	0x7352	; 0x7352 <__divsf3>
    6bb2:	a9 81       	ldd	r26, Y+1	; 0x01
    6bb4:	ba 81       	ldd	r27, Y+2	; 0x02
    6bb6:	95 96       	adiw	r26, 0x25	; 37
    6bb8:	6d 93       	st	X+, r22
    6bba:	7d 93       	st	X+, r23
    6bbc:	8d 93       	st	X+, r24
    6bbe:	9c 93       	st	X, r25
    6bc0:	98 97       	sbiw	r26, 0x28	; 40
        plan_cycle_reinitialize(); 
    6bc2:	0e 94 b3 1e 	call	0x3d66	; 0x3d66 <plan_cycle_reinitialize>
        return; // Bail!
    6bc6:	15 c0       	rjmp	.+42     	; 0x6bf2 <st_prep_buffer+0xd9e>
      } else { // End of planner block
        // The planner block is complete. All steps are set to be executed in the segment buffer.
        pl_block = NULL; // Set pointer to indicate check and load next planner block.
    6bc8:	10 92 82 04 	sts	0x0482, r1	; 0x800482 <pl_block+0x1>
    6bcc:	10 92 81 04 	sts	0x0481, r1	; 0x800481 <pl_block>
        plan_discard_current_block();
    6bd0:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <plan_discard_current_block>
    6bd4:	08 c0       	rjmp	.+16     	; 0x6be6 <st_prep_buffer+0xd92>
      pl_block = plan_get_current_block(); // Query planner for a queued block
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
                      
      // Check if the segment buffer completed the last planner block. If so, load the Bresenham
      // data for the block. If not, we are still mid-block and the velocity profile was updated. 
      if (prep.flag_partial_block) {
    6bd6:	0f 2e       	mov	r0, r31
    6bd8:	f6 e5       	ldi	r31, 0x56	; 86
    6bda:	6f 2e       	mov	r6, r31
    6bdc:	f4 e0       	ldi	r31, 0x04	; 4
    6bde:	7f 2e       	mov	r7, r31
    6be0:	f0 2d       	mov	r31, r0
          mm_var = mm_remaining - prep.maximum_speed*time_var;
          if (mm_var < prep.decelerate_after) { // End of cruise. 
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
    6be2:	b2 e0       	ldi	r27, 0x02	; 2
    6be4:	b9 af       	std	Y+57, r27	; 0x39
  if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { 
    // Check if we still need to generate more segments for a motion suspend.
    if (prep.current_speed == 0.0) { return; } // Nothing to do. Bail.
  }
  
  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
    6be6:	90 91 88 04 	lds	r25, 0x0488	; 0x800488 <segment_buffer_tail>
    6bea:	80 91 86 04 	lds	r24, 0x0486	; 0x800486 <segment_next_head>
    6bee:	98 13       	cpse	r25, r24
    6bf0:	60 c9       	rjmp	.-3392   	; 0x5eb2 <st_prep_buffer+0x5e>
        plan_discard_current_block();
      }
    }

  } 
}      
    6bf2:	ed 96       	adiw	r28, 0x3d	; 61
    6bf4:	0f b6       	in	r0, 0x3f	; 63
    6bf6:	f8 94       	cli
    6bf8:	de bf       	out	0x3e, r29	; 62
    6bfa:	0f be       	out	0x3f, r0	; 63
    6bfc:	cd bf       	out	0x3d, r28	; 61
    6bfe:	df 91       	pop	r29
    6c00:	cf 91       	pop	r28
    6c02:	1f 91       	pop	r17
    6c04:	0f 91       	pop	r16
    6c06:	ff 90       	pop	r15
    6c08:	ef 90       	pop	r14
    6c0a:	df 90       	pop	r13
    6c0c:	cf 90       	pop	r12
    6c0e:	bf 90       	pop	r11
    6c10:	af 90       	pop	r10
    6c12:	9f 90       	pop	r9
    6c14:	8f 90       	pop	r8
    6c16:	7f 90       	pop	r7
    6c18:	6f 90       	pop	r6
    6c1a:	5f 90       	pop	r5
    6c1c:	4f 90       	pop	r4
    6c1e:	3f 90       	pop	r3
    6c20:	2f 90       	pop	r2
    6c22:	08 95       	ret

00006c24 <system_init>:
#include "grbl.h"


void system_init() 
{
  CONTROL_DDR &= ~(CONTROL_MASK); // Configure as input pins
    6c24:	87 b1       	in	r24, 0x07	; 7
    6c26:	88 7f       	andi	r24, 0xF8	; 248
    6c28:	87 b9       	out	0x07, r24	; 7
  #ifdef DISABLE_CONTROL_PIN_PULL_UP
    CONTROL_PORT &= ~(CONTROL_MASK); // Normal low operation. Requires external pull-down.
  #else
    CONTROL_PORT |= CONTROL_MASK;   // Enable internal pull-up resistors. Normal high operation.
    6c2a:	88 b1       	in	r24, 0x08	; 8
    6c2c:	87 60       	ori	r24, 0x07	; 7
    6c2e:	88 b9       	out	0x08, r24	; 8
  #endif
  CONTROL_PCMSK |= CONTROL_MASK;  // Enable specific pins of the Pin Change Interrupt
    6c30:	ec e6       	ldi	r30, 0x6C	; 108
    6c32:	f0 e0       	ldi	r31, 0x00	; 0
    6c34:	80 81       	ld	r24, Z
    6c36:	87 60       	ori	r24, 0x07	; 7
    6c38:	80 83       	st	Z, r24
  PCICR |= (1 << CONTROL_INT);   // Enable Pin Change Interrupt
    6c3a:	e8 e6       	ldi	r30, 0x68	; 104
    6c3c:	f0 e0       	ldi	r31, 0x00	; 0
    6c3e:	80 81       	ld	r24, Z
    6c40:	82 60       	ori	r24, 0x02	; 2
    6c42:	80 83       	st	Z, r24
    6c44:	08 95       	ret

00006c46 <__vector_4>:
// Pin change interrupt for pin-out commands, i.e. cycle start, feed hold, and reset. Sets
// only the realtime command execute variable to have the main program execute these when 
// its ready. This works exactly like the character-based realtime commands when picked off
// directly from the incoming serial data stream.
ISR(CONTROL_INT_vect) 
{
    6c46:	1f 92       	push	r1
    6c48:	0f 92       	push	r0
    6c4a:	0f b6       	in	r0, 0x3f	; 63
    6c4c:	0f 92       	push	r0
    6c4e:	11 24       	eor	r1, r1
    6c50:	2f 93       	push	r18
    6c52:	3f 93       	push	r19
    6c54:	4f 93       	push	r20
    6c56:	5f 93       	push	r21
    6c58:	6f 93       	push	r22
    6c5a:	7f 93       	push	r23
    6c5c:	8f 93       	push	r24
    6c5e:	9f 93       	push	r25
    6c60:	af 93       	push	r26
    6c62:	bf 93       	push	r27
    6c64:	ef 93       	push	r30
    6c66:	ff 93       	push	r31
  uint8_t pin = (CONTROL_PIN & CONTROL_MASK);
    6c68:	86 b1       	in	r24, 0x06	; 6
  #ifndef INVERT_ALL_CONTROL_PINS
    pin ^= CONTROL_INVERT_MASK;
    6c6a:	80 95       	com	r24
    6c6c:	87 70       	andi	r24, 0x07	; 7
  #endif
  // Enter only if any CONTROL pin is detected as active.
  if (pin) { 
    6c6e:	a9 f0       	breq	.+42     	; 0x6c9a <__vector_4+0x54>
    if (bit_istrue(pin,bit(RESET_BIT))) {
    6c70:	80 ff       	sbrs	r24, 0
    6c72:	03 c0       	rjmp	.+6      	; 0x6c7a <__vector_4+0x34>
      mc_reset();
    6c74:	0e 94 36 18 	call	0x306c	; 0x306c <mc_reset>
    6c78:	10 c0       	rjmp	.+32     	; 0x6c9a <__vector_4+0x54>
    } else if (bit_istrue(pin,bit(CYCLE_START_BIT))) {
    6c7a:	98 2f       	mov	r25, r24
    6c7c:	94 70       	andi	r25, 0x04	; 4
    6c7e:	31 f0       	breq	.+12     	; 0x6c8c <__vector_4+0x46>
      bit_true(sys_rt_exec_state, EXEC_CYCLE_START);
    6c80:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    6c84:	82 60       	ori	r24, 0x02	; 2
    6c86:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <sys_rt_exec_state>
    6c8a:	07 c0       	rjmp	.+14     	; 0x6c9a <__vector_4+0x54>
    #ifndef ENABLE_SAFETY_DOOR_INPUT_PIN
      } else if (bit_istrue(pin,bit(FEED_HOLD_BIT))) {
    6c8c:	81 ff       	sbrs	r24, 1
    6c8e:	05 c0       	rjmp	.+10     	; 0x6c9a <__vector_4+0x54>
        bit_true(sys_rt_exec_state, EXEC_FEED_HOLD); 
    6c90:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <sys_rt_exec_state>
    6c94:	88 60       	ori	r24, 0x08	; 8
    6c96:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <sys_rt_exec_state>
      } else if (bit_istrue(pin,bit(SAFETY_DOOR_BIT))) {
        bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
    #endif
    } 
  }
}
    6c9a:	ff 91       	pop	r31
    6c9c:	ef 91       	pop	r30
    6c9e:	bf 91       	pop	r27
    6ca0:	af 91       	pop	r26
    6ca2:	9f 91       	pop	r25
    6ca4:	8f 91       	pop	r24
    6ca6:	7f 91       	pop	r23
    6ca8:	6f 91       	pop	r22
    6caa:	5f 91       	pop	r21
    6cac:	4f 91       	pop	r20
    6cae:	3f 91       	pop	r19
    6cb0:	2f 91       	pop	r18
    6cb2:	0f 90       	pop	r0
    6cb4:	0f be       	out	0x3f, r0	; 63
    6cb6:	0f 90       	pop	r0
    6cb8:	1f 90       	pop	r1
    6cba:	18 95       	reti

00006cbc <system_check_safety_door_ajar>:
      return(bit_isfalse(CONTROL_PIN,bit(SAFETY_DOOR_BIT)));
    #endif
  #else
    return(false); // Input pin not enabled, so just return that it's closed.
  #endif
}
    6cbc:	80 e0       	ldi	r24, 0x00	; 0
    6cbe:	08 95       	ret

00006cc0 <system_execute_startup>:


// Executes user startup script, if stored.
void system_execute_startup(char *line) 
{
    6cc0:	0f 93       	push	r16
    6cc2:	1f 93       	push	r17
    6cc4:	cf 93       	push	r28
    6cc6:	8c 01       	movw	r16, r24
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    6cc8:	c0 e0       	ldi	r28, 0x00	; 0
    if (!(settings_read_startup_line(n, line))) {
    6cca:	b8 01       	movw	r22, r16
    6ccc:	8c 2f       	mov	r24, r28
    6cce:	0e 94 d8 29 	call	0x53b0	; 0x53b0 <settings_read_startup_line>
    6cd2:	81 11       	cpse	r24, r1
    6cd4:	04 c0       	rjmp	.+8      	; 0x6cde <system_execute_startup+0x1e>
      report_status_message(STATUS_SETTING_READ_FAIL);
    6cd6:	87 e0       	ldi	r24, 0x07	; 7
    6cd8:	0e 94 3f 22 	call	0x447e	; 0x447e <report_status_message>
    6cdc:	0c c0       	rjmp	.+24     	; 0x6cf6 <system_execute_startup+0x36>
    } else {
      if (line[0] != 0) {
    6cde:	f8 01       	movw	r30, r16
    6ce0:	80 81       	ld	r24, Z
    6ce2:	88 23       	and	r24, r24
    6ce4:	41 f0       	breq	.+16     	; 0x6cf6 <system_execute_startup+0x36>
        printString(line); // Echo startup line to indicate execution.
    6ce6:	c8 01       	movw	r24, r16
    6ce8:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printString>
        report_status_message(gc_execute_line(line));
    6cec:	c8 01       	movw	r24, r16
    6cee:	0e 94 0b 06 	call	0xc16	; 0xc16 <gc_execute_line>
    6cf2:	0e 94 3f 22 	call	0x447e	; 0x447e <report_status_message>

// Executes user startup script, if stored.
void system_execute_startup(char *line) 
{
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    6cf6:	cf 5f       	subi	r28, 0xFF	; 255
    6cf8:	c2 30       	cpi	r28, 0x02	; 2
    6cfa:	39 f7       	brne	.-50     	; 0x6cca <system_execute_startup+0xa>
        printString(line); // Echo startup line to indicate execution.
        report_status_message(gc_execute_line(line));
      }
    } 
  }  
}
    6cfc:	cf 91       	pop	r28
    6cfe:	1f 91       	pop	r17
    6d00:	0f 91       	pop	r16
    6d02:	08 95       	ret

00006d04 <system_execute_line>:
// next line during a cycle, so for switches like block delete, the switch only effects
// the lines that are processed afterward, not necessarily real-time during a cycle, 
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line) 
{   
    6d04:	8f 92       	push	r8
    6d06:	9f 92       	push	r9
    6d08:	af 92       	push	r10
    6d0a:	bf 92       	push	r11
    6d0c:	cf 92       	push	r12
    6d0e:	df 92       	push	r13
    6d10:	ef 92       	push	r14
    6d12:	ff 92       	push	r15
    6d14:	0f 93       	push	r16
    6d16:	1f 93       	push	r17
    6d18:	cf 93       	push	r28
    6d1a:	df 93       	push	r29
    6d1c:	cd b7       	in	r28, 0x3d	; 61
    6d1e:	de b7       	in	r29, 0x3e	; 62
    6d20:	29 97       	sbiw	r28, 0x09	; 9
    6d22:	0f b6       	in	r0, 0x3f	; 63
    6d24:	f8 94       	cli
    6d26:	de bf       	out	0x3e, r29	; 62
    6d28:	0f be       	out	0x3f, r0	; 63
    6d2a:	cd bf       	out	0x3d, r28	; 61
    6d2c:	8c 01       	movw	r16, r24
  uint8_t char_counter = 1; 
    6d2e:	81 e0       	ldi	r24, 0x01	; 1
    6d30:	89 83       	std	Y+1, r24	; 0x01
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    6d32:	f8 01       	movw	r30, r16
    6d34:	81 81       	ldd	r24, Z+1	; 0x01
    6d36:	83 34       	cpi	r24, 0x43	; 67
    6d38:	89 f0       	breq	.+34     	; 0x6d5c <system_execute_line+0x58>
    6d3a:	30 f4       	brcc	.+12     	; 0x6d48 <system_execute_line+0x44>
    6d3c:	88 23       	and	r24, r24
    6d3e:	51 f0       	breq	.+20     	; 0x6d54 <system_execute_line+0x50>
    6d40:	84 32       	cpi	r24, 0x24	; 36
    6d42:	09 f0       	breq	.+2      	; 0x6d46 <system_execute_line+0x42>
    6d44:	48 c0       	rjmp	.+144    	; 0x6dd6 <system_execute_line+0xd2>
    6d46:	0a c0       	rjmp	.+20     	; 0x6d5c <system_execute_line+0x58>
    6d48:	87 34       	cpi	r24, 0x47	; 71
    6d4a:	41 f0       	breq	.+16     	; 0x6d5c <system_execute_line+0x58>
    6d4c:	88 35       	cpi	r24, 0x58	; 88
    6d4e:	09 f0       	breq	.+2      	; 0x6d52 <system_execute_line+0x4e>
    6d50:	42 c0       	rjmp	.+132    	; 0x6dd6 <system_execute_line+0xd2>
    6d52:	04 c0       	rjmp	.+8      	; 0x6d5c <system_execute_line+0x58>
    case 0 : report_grbl_help(); break;
    6d54:	0e 94 23 23 	call	0x4646	; 0x4646 <report_grbl_help>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6d58:	f1 2c       	mov	r15, r1
{   
  uint8_t char_counter = 1; 
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    6d5a:	b0 c1       	rjmp	.+864    	; 0x70bc <system_execute_line+0x3b8>
    case '$': case 'G': case 'C': case 'X':
      if ( line[(char_counter+1)] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    6d5c:	f8 01       	movw	r30, r16
    6d5e:	92 81       	ldd	r25, Z+2	; 0x02
    6d60:	91 11       	cpse	r25, r1
    6d62:	53 c1       	rjmp	.+678    	; 0x700a <system_execute_line+0x306>
      switch( line[char_counter] ) {
    6d64:	83 34       	cpi	r24, 0x43	; 67
    6d66:	b1 f0       	breq	.+44     	; 0x6d94 <system_execute_line+0x90>
    6d68:	18 f4       	brcc	.+6      	; 0x6d70 <system_execute_line+0x6c>
    6d6a:	84 32       	cpi	r24, 0x24	; 36
    6d6c:	31 f0       	breq	.+12     	; 0x6d7a <system_execute_line+0x76>
    6d6e:	52 c1       	rjmp	.+676    	; 0x7014 <system_execute_line+0x310>
    6d70:	87 34       	cpi	r24, 0x47	; 71
    6d72:	61 f0       	breq	.+24     	; 0x6d8c <system_execute_line+0x88>
    6d74:	88 35       	cpi	r24, 0x58	; 88
    6d76:	19 f1       	breq	.+70     	; 0x6dbe <system_execute_line+0xba>
    6d78:	4d c1       	rjmp	.+666    	; 0x7014 <system_execute_line+0x310>
    6d7a:	80 91 a1 05 	lds	r24, 0x05A1	; 0x8005a1 <sys+0x1>
    6d7e:	88 71       	andi	r24, 0x18	; 24
    6d80:	f8 2e       	mov	r15, r24
        case '$' : // Prints Grbl settings
          if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    6d82:	09 f0       	breq	.+2      	; 0x6d86 <system_execute_line+0x82>
    6d84:	49 c1       	rjmp	.+658    	; 0x7018 <system_execute_line+0x314>
          else { report_grbl_settings(); }
    6d86:	0e 94 28 23 	call	0x4650	; 0x4650 <report_grbl_settings>
          break;
    6d8a:	98 c1       	rjmp	.+816    	; 0x70bc <system_execute_line+0x3b8>
        case 'G' : // Prints gcode parser state
          // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
          report_gcode_modes();
    6d8c:	0e 94 fd 25 	call	0x4bfa	; 0x4bfa <report_gcode_modes>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6d90:	f1 2c       	mov	r15, r1
          else { report_grbl_settings(); }
          break;
        case 'G' : // Prints gcode parser state
          // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
          report_gcode_modes();
          break;   
    6d92:	94 c1       	rjmp	.+808    	; 0x70bc <system_execute_line+0x3b8>
        case 'C' : // Set check g-code mode [IDLE/CHECK]
          // Perform reset when toggling off. Check g-code mode should only work if Grbl
          // is idle and ready, regardless of alarm locks. This is mainly to keep things
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) { 
    6d94:	f0 90 a1 05 	lds	r15, 0x05A1	; 0x8005a1 <sys+0x1>
    6d98:	f2 e0       	ldi	r31, 0x02	; 2
    6d9a:	ff 12       	cpse	r15, r31
    6d9c:	07 c0       	rjmp	.+14     	; 0x6dac <system_execute_line+0xa8>
            mc_reset(); 
    6d9e:	0e 94 36 18 	call	0x306c	; 0x306c <mc_reset>
            report_feedback_message(MESSAGE_DISABLED);
    6da2:	85 e0       	ldi	r24, 0x05	; 5
    6da4:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <report_feedback_message>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6da8:	f1 2c       	mov	r15, r1
    6daa:	88 c1       	rjmp	.+784    	; 0x70bc <system_execute_line+0x3b8>
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) { 
            mc_reset(); 
            report_feedback_message(MESSAGE_DISABLED);
          } else {
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    6dac:	f1 10       	cpse	r15, r1
    6dae:	38 c1       	rjmp	.+624    	; 0x7020 <system_execute_line+0x31c>
            sys.state = STATE_CHECK_MODE;
    6db0:	82 e0       	ldi	r24, 0x02	; 2
    6db2:	80 93 a1 05 	sts	0x05A1, r24	; 0x8005a1 <sys+0x1>
            report_feedback_message(MESSAGE_ENABLED);
    6db6:	84 e0       	ldi	r24, 0x04	; 4
    6db8:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <report_feedback_message>
    6dbc:	7f c1       	rjmp	.+766    	; 0x70bc <system_execute_line+0x3b8>
          }
          break; 
        case 'X' : // Disable alarm lock [ALARM]
          if (sys.state == STATE_ALARM) { 
    6dbe:	80 91 a1 05 	lds	r24, 0x05A1	; 0x8005a1 <sys+0x1>
    6dc2:	81 30       	cpi	r24, 0x01	; 1
    6dc4:	09 f0       	breq	.+2      	; 0x6dc8 <system_execute_line+0xc4>
    6dc6:	30 c1       	rjmp	.+608    	; 0x7028 <system_execute_line+0x324>
            report_feedback_message(MESSAGE_ALARM_UNLOCK);
    6dc8:	83 e0       	ldi	r24, 0x03	; 3
    6dca:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <report_feedback_message>
            sys.state = STATE_IDLE;
    6dce:	10 92 a1 05 	sts	0x05A1, r1	; 0x8005a1 <sys+0x1>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6dd2:	f1 2c       	mov	r15, r1
    6dd4:	73 c1       	rjmp	.+742    	; 0x70bc <system_execute_line+0x3b8>
//       break;
      }
      break;
    default : 
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    6dd6:	90 91 a1 05 	lds	r25, 0x05A1	; 0x8005a1 <sys+0x1>
    6dda:	92 30       	cpi	r25, 0x02	; 2
    6ddc:	08 f0       	brcs	.+2      	; 0x6de0 <system_execute_line+0xdc>
    6dde:	26 c1       	rjmp	.+588    	; 0x702c <system_execute_line+0x328>
      switch( line[char_counter] ) {
    6de0:	89 34       	cpi	r24, 0x49	; 73
    6de2:	91 f1       	breq	.+100    	; 0x6e48 <system_execute_line+0x144>
    6de4:	28 f4       	brcc	.+10     	; 0x6df0 <system_execute_line+0xec>
    6de6:	83 32       	cpi	r24, 0x23	; 35
    6de8:	51 f0       	breq	.+20     	; 0x6dfe <system_execute_line+0xfa>
    6dea:	88 34       	cpi	r24, 0x48	; 72
    6dec:	91 f0       	breq	.+36     	; 0x6e12 <system_execute_line+0x10e>
    6dee:	9c c0       	rjmp	.+312    	; 0x6f28 <system_execute_line+0x224>
    6df0:	8e 34       	cpi	r24, 0x4E	; 78
    6df2:	09 f4       	brne	.+2      	; 0x6df6 <system_execute_line+0xf2>
    6df4:	79 c0       	rjmp	.+242    	; 0x6ee8 <system_execute_line+0x1e4>
    6df6:	82 35       	cpi	r24, 0x52	; 82
    6df8:	09 f4       	brne	.+2      	; 0x6dfc <system_execute_line+0xf8>
    6dfa:	49 c0       	rjmp	.+146    	; 0x6e8e <system_execute_line+0x18a>
    6dfc:	95 c0       	rjmp	.+298    	; 0x6f28 <system_execute_line+0x224>
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    6dfe:	82 e0       	ldi	r24, 0x02	; 2
    6e00:	89 83       	std	Y+1, r24	; 0x01
    6e02:	f8 01       	movw	r30, r16
    6e04:	82 81       	ldd	r24, Z+2	; 0x02
    6e06:	81 11       	cpse	r24, r1
    6e08:	15 c1       	rjmp	.+554    	; 0x7034 <system_execute_line+0x330>
          else { report_ngc_parameters(); }
    6e0a:	0e 94 67 25 	call	0x4ace	; 0x4ace <report_ngc_parameters>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6e0e:	f1 2c       	mov	r15, r1
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
      switch( line[char_counter] ) {
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
          else { report_ngc_parameters(); }
          break;          
    6e10:	55 c1       	rjmp	.+682    	; 0x70bc <system_execute_line+0x3b8>
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) { 
    6e12:	80 91 bc 06 	lds	r24, 0x06BC	; 0x8006bc <settings+0x3d>
    6e16:	84 ff       	sbrs	r24, 4
    6e18:	12 c1       	rjmp	.+548    	; 0x703e <system_execute_line+0x33a>
            sys.state = STATE_HOMING; // Set system state variable
    6e1a:	0f 2e       	mov	r0, r31
    6e1c:	f0 ea       	ldi	r31, 0xA0	; 160
    6e1e:	ef 2e       	mov	r14, r31
    6e20:	f5 e0       	ldi	r31, 0x05	; 5
    6e22:	ff 2e       	mov	r15, r31
    6e24:	f0 2d       	mov	r31, r0
    6e26:	84 e0       	ldi	r24, 0x04	; 4
    6e28:	f7 01       	movw	r30, r14
    6e2a:	81 83       	std	Z+1, r24	; 0x01
              bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
              protocol_execute_realtime(); // Enter safety door mode.
            }
            
            
            mc_homing_cycle(); 
    6e2c:	0e 94 a0 17 	call	0x2f40	; 0x2f40 <mc_homing_cycle>
            if (!sys.abort) {  // Execute startup scripts after successful homing.
    6e30:	f7 01       	movw	r30, r14
    6e32:	f0 80       	ld	r15, Z
    6e34:	f1 10       	cpse	r15, r1
    6e36:	08 c1       	rjmp	.+528    	; 0x7048 <system_execute_line+0x344>
              sys.state = STATE_IDLE; // Set to IDLE when complete.
    6e38:	10 92 a1 05 	sts	0x05A1, r1	; 0x8005a1 <sys+0x1>
              st_go_idle(); // Set steppers to the settings idle state before returning.
    6e3c:	0e 94 5b 2c 	call	0x58b6	; 0x58b6 <st_go_idle>
              system_execute_startup(line); 
    6e40:	c8 01       	movw	r24, r16
    6e42:	0e 94 60 36 	call	0x6cc0	; 0x6cc0 <system_execute_startup>
    6e46:	3a c1       	rjmp	.+628    	; 0x70bc <system_execute_line+0x3b8>
            }
          } else { return(STATUS_SETTING_DISABLED); }
          break;
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
    6e48:	82 e0       	ldi	r24, 0x02	; 2
    6e4a:	89 83       	std	Y+1, r24	; 0x01
    6e4c:	f8 01       	movw	r30, r16
    6e4e:	82 81       	ldd	r24, Z+2	; 0x02
    6e50:	81 11       	cpse	r24, r1
    6e52:	08 c0       	rjmp	.+16     	; 0x6e64 <system_execute_line+0x160>
            settings_read_build_info(line);
    6e54:	c8 01       	movw	r24, r16
    6e56:	0e 94 f5 29 	call	0x53ea	; 0x53ea <settings_read_build_info>
            report_build_info(line);
    6e5a:	c8 01       	movw	r24, r16
    6e5c:	0e 94 f5 26 	call	0x4dea	; 0x4dea <report_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6e60:	f1 2c       	mov	r15, r1
    6e62:	2c c1       	rjmp	.+600    	; 0x70bc <system_execute_line+0x3b8>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
            settings_read_build_info(line);
            report_build_info(line);
          } else { // Store startup line [IDLE/ALARM]
            if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    6e64:	8d 33       	cpi	r24, 0x3D	; 61
    6e66:	09 f0       	breq	.+2      	; 0x6e6a <system_execute_line+0x166>
    6e68:	f1 c0       	rjmp	.+482    	; 0x704c <system_execute_line+0x348>
    6e6a:	83 e0       	ldi	r24, 0x03	; 3
            helper_var = char_counter; // Set helper variable as counter to start of user info line.
            do {
              line[char_counter-helper_var] = line[char_counter];
    6e6c:	f8 01       	movw	r30, r16
    6e6e:	e8 0f       	add	r30, r24
    6e70:	f1 1d       	adc	r31, r1
    6e72:	90 81       	ld	r25, Z
    6e74:	df 01       	movw	r26, r30
    6e76:	13 97       	sbiw	r26, 0x03	; 3
    6e78:	9c 93       	st	X, r25
            } while (line[char_counter++] != 0);
    6e7a:	8f 5f       	subi	r24, 0xFF	; 255
    6e7c:	90 81       	ld	r25, Z
    6e7e:	91 11       	cpse	r25, r1
    6e80:	f5 cf       	rjmp	.-22     	; 0x6e6c <system_execute_line+0x168>
    6e82:	89 83       	std	Y+1, r24	; 0x01
            settings_store_build_info(line);
    6e84:	c8 01       	movw	r24, r16
    6e86:	0e 94 f4 28 	call	0x51e8	; 0x51e8 <settings_store_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6e8a:	f1 2c       	mov	r15, r1
    6e8c:	17 c1       	rjmp	.+558    	; 0x70bc <system_execute_line+0x3b8>
            } while (line[char_counter++] != 0);
            settings_store_build_info(line);
          }
          break; 
        case 'R' : // Restore defaults [IDLE/ALARM]
          if (line[++char_counter] != 'S') { return(STATUS_INVALID_STATEMENT); }
    6e8e:	f8 01       	movw	r30, r16
    6e90:	82 81       	ldd	r24, Z+2	; 0x02
    6e92:	83 35       	cpi	r24, 0x53	; 83
    6e94:	09 f0       	breq	.+2      	; 0x6e98 <system_execute_line+0x194>
    6e96:	df c0       	rjmp	.+446    	; 0x7056 <system_execute_line+0x352>
          if (line[++char_counter] != 'T') { return(STATUS_INVALID_STATEMENT); }
    6e98:	83 81       	ldd	r24, Z+3	; 0x03
    6e9a:	84 35       	cpi	r24, 0x54	; 84
    6e9c:	09 f0       	breq	.+2      	; 0x6ea0 <system_execute_line+0x19c>
    6e9e:	e0 c0       	rjmp	.+448    	; 0x7060 <system_execute_line+0x35c>
          if (line[++char_counter] != '=') { return(STATUS_INVALID_STATEMENT); }
    6ea0:	84 81       	ldd	r24, Z+4	; 0x04
    6ea2:	8d 33       	cpi	r24, 0x3D	; 61
    6ea4:	09 f0       	breq	.+2      	; 0x6ea8 <system_execute_line+0x1a4>
    6ea6:	e1 c0       	rjmp	.+450    	; 0x706a <system_execute_line+0x366>
          if (line[char_counter+2] != 0) { return(STATUS_INVALID_STATEMENT); }                        
    6ea8:	86 81       	ldd	r24, Z+6	; 0x06
    6eaa:	81 11       	cpse	r24, r1
    6eac:	e3 c0       	rjmp	.+454    	; 0x7074 <system_execute_line+0x370>
          switch (line[++char_counter]) {
    6eae:	85 e0       	ldi	r24, 0x05	; 5
    6eb0:	89 83       	std	Y+1, r24	; 0x01
    6eb2:	85 81       	ldd	r24, Z+5	; 0x05
    6eb4:	84 32       	cpi	r24, 0x24	; 36
    6eb6:	31 f0       	breq	.+12     	; 0x6ec4 <system_execute_line+0x1c0>
    6eb8:	8a 32       	cpi	r24, 0x2A	; 42
    6eba:	61 f0       	breq	.+24     	; 0x6ed4 <system_execute_line+0x1d0>
    6ebc:	83 32       	cpi	r24, 0x23	; 35
    6ebe:	09 f0       	breq	.+2      	; 0x6ec2 <system_execute_line+0x1be>
    6ec0:	de c0       	rjmp	.+444    	; 0x707e <system_execute_line+0x37a>
    6ec2:	04 c0       	rjmp	.+8      	; 0x6ecc <system_execute_line+0x1c8>
            case '$': settings_restore(SETTINGS_RESTORE_DEFAULTS); break;
    6ec4:	81 e0       	ldi	r24, 0x01	; 1
    6ec6:	0e 94 14 29 	call	0x5228	; 0x5228 <settings_restore>
    6eca:	07 c0       	rjmp	.+14     	; 0x6eda <system_execute_line+0x1d6>
            case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
    6ecc:	82 e0       	ldi	r24, 0x02	; 2
    6ece:	0e 94 14 29 	call	0x5228	; 0x5228 <settings_restore>
    6ed2:	03 c0       	rjmp	.+6      	; 0x6eda <system_execute_line+0x1d6>
            case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
    6ed4:	8f ef       	ldi	r24, 0xFF	; 255
    6ed6:	0e 94 14 29 	call	0x5228	; 0x5228 <settings_restore>
            default: return(STATUS_INVALID_STATEMENT);
          }
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
    6eda:	88 e0       	ldi	r24, 0x08	; 8
    6edc:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <report_feedback_message>
          mc_reset(); // Force reset to ensure settings are initialized correctly.
    6ee0:	0e 94 36 18 	call	0x306c	; 0x306c <mc_reset>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6ee4:	f1 2c       	mov	r15, r1
            case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
            default: return(STATUS_INVALID_STATEMENT);
          }
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
          mc_reset(); // Force reset to ensure settings are initialized correctly.
          break;
    6ee6:	ea c0       	rjmp	.+468    	; 0x70bc <system_execute_line+0x3b8>
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
    6ee8:	82 e0       	ldi	r24, 0x02	; 2
    6eea:	89 83       	std	Y+1, r24	; 0x01
    6eec:	f8 01       	movw	r30, r16
    6eee:	82 81       	ldd	r24, Z+2	; 0x02
    6ef0:	81 11       	cpse	r24, r1
    6ef2:	15 c0       	rjmp	.+42     	; 0x6f1e <system_execute_line+0x21a>
    6ef4:	f1 2c       	mov	r15, r1
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
              if (!(settings_read_startup_line(helper_var, line))) {
    6ef6:	b8 01       	movw	r22, r16
    6ef8:	8f 2d       	mov	r24, r15
    6efa:	0e 94 d8 29 	call	0x53b0	; 0x53b0 <settings_read_startup_line>
    6efe:	81 11       	cpse	r24, r1
    6f00:	04 c0       	rjmp	.+8      	; 0x6f0a <system_execute_line+0x206>
                report_status_message(STATUS_SETTING_READ_FAIL);
    6f02:	87 e0       	ldi	r24, 0x07	; 7
    6f04:	0e 94 3f 22 	call	0x447e	; 0x447e <report_status_message>
    6f08:	04 c0       	rjmp	.+8      	; 0x6f12 <system_execute_line+0x20e>
              } else {
                report_startup_line(helper_var,line);
    6f0a:	b8 01       	movw	r22, r16
    6f0c:	8f 2d       	mov	r24, r15
    6f0e:	0e 94 da 26 	call	0x4db4	; 0x4db4 <report_startup_line>
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
          mc_reset(); // Force reset to ensure settings are initialized correctly.
          break;
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
    6f12:	f3 94       	inc	r15
    6f14:	f2 e0       	ldi	r31, 0x02	; 2
    6f16:	ff 12       	cpse	r15, r31
    6f18:	ee cf       	rjmp	.-36     	; 0x6ef6 <system_execute_line+0x1f2>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6f1a:	f1 2c       	mov	r15, r1
    6f1c:	cf c0       	rjmp	.+414    	; 0x70bc <system_execute_line+0x3b8>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    6f1e:	91 11       	cpse	r25, r1
    6f20:	b3 c0       	rjmp	.+358    	; 0x7088 <system_execute_line+0x384>
            helper_var = true;  // Set helper_var to flag storing method. 
    6f22:	ff 24       	eor	r15, r15
    6f24:	f3 94       	inc	r15
    6f26:	01 c0       	rjmp	.+2      	; 0x6f2a <system_execute_line+0x226>
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line) 
{   
  uint8_t char_counter = 1; 
  uint8_t helper_var = 0; // Helper variable
    6f28:	f1 2c       	mov	r15, r1
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
            helper_var = true;  // Set helper_var to flag storing method. 
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    6f2a:	ae 01       	movw	r20, r28
    6f2c:	4e 5f       	subi	r20, 0xFE	; 254
    6f2e:	5f 4f       	sbci	r21, 0xFF	; 255
    6f30:	be 01       	movw	r22, r28
    6f32:	6f 5f       	subi	r22, 0xFF	; 255
    6f34:	7f 4f       	sbci	r23, 0xFF	; 255
    6f36:	c8 01       	movw	r24, r16
    6f38:	0e 94 65 18 	call	0x30ca	; 0x30ca <read_float>
    6f3c:	88 23       	and	r24, r24
    6f3e:	09 f4       	brne	.+2      	; 0x6f42 <system_execute_line+0x23e>
    6f40:	a7 c0       	rjmp	.+334    	; 0x7090 <system_execute_line+0x38c>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    6f42:	89 81       	ldd	r24, Y+1	; 0x01
    6f44:	41 e0       	ldi	r20, 0x01	; 1
    6f46:	48 0f       	add	r20, r24
    6f48:	49 83       	std	Y+1, r20	; 0x01
    6f4a:	f8 01       	movw	r30, r16
    6f4c:	e8 0f       	add	r30, r24
    6f4e:	f1 1d       	adc	r31, r1
    6f50:	80 81       	ld	r24, Z
    6f52:	8d 33       	cpi	r24, 0x3D	; 61
    6f54:	09 f0       	breq	.+2      	; 0x6f58 <system_execute_line+0x254>
    6f56:	a0 c0       	rjmp	.+320    	; 0x7098 <system_execute_line+0x394>
          if (helper_var) { // Store startup line
    6f58:	ff 20       	and	r15, r15
    6f5a:	31 f1       	breq	.+76     	; 0x6fa8 <system_execute_line+0x2a4>
    6f5c:	24 2f       	mov	r18, r20
            // Prepare sending gcode block to gcode parser by shifting all characters
            helper_var = char_counter; // Set helper variable as counter to start of gcode block
            do {
              line[char_counter-helper_var] = line[char_counter];
    6f5e:	50 e0       	ldi	r21, 0x00	; 0
    6f60:	82 2f       	mov	r24, r18
    6f62:	90 e0       	ldi	r25, 0x00	; 0
    6f64:	d8 01       	movw	r26, r16
    6f66:	a8 0f       	add	r26, r24
    6f68:	b9 1f       	adc	r27, r25
    6f6a:	3c 91       	ld	r19, X
    6f6c:	84 1b       	sub	r24, r20
    6f6e:	95 0b       	sbc	r25, r21
    6f70:	f8 01       	movw	r30, r16
    6f72:	e8 0f       	add	r30, r24
    6f74:	f9 1f       	adc	r31, r25
    6f76:	30 83       	st	Z, r19
            } while (line[char_counter++] != 0);
    6f78:	2f 5f       	subi	r18, 0xFF	; 255
    6f7a:	8c 91       	ld	r24, X
    6f7c:	81 11       	cpse	r24, r1
    6f7e:	f0 cf       	rjmp	.-32     	; 0x6f60 <system_execute_line+0x25c>
    6f80:	29 83       	std	Y+1, r18	; 0x01
            // Execute gcode block to ensure block is valid.
            helper_var = gc_execute_line(line); // Set helper_var to returned status code.
    6f82:	c8 01       	movw	r24, r16
    6f84:	0e 94 0b 06 	call	0xc16	; 0xc16 <gc_execute_line>
    6f88:	f8 2e       	mov	r15, r24
            if (helper_var) { return(helper_var); }
    6f8a:	81 11       	cpse	r24, r1
    6f8c:	97 c0       	rjmp	.+302    	; 0x70bc <system_execute_line+0x3b8>
            else { 
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
    6f8e:	6a 81       	ldd	r22, Y+2	; 0x02
    6f90:	7b 81       	ldd	r23, Y+3	; 0x03
    6f92:	8c 81       	ldd	r24, Y+4	; 0x04
    6f94:	9d 81       	ldd	r25, Y+5	; 0x05
    6f96:	0e 94 e4 3c 	call	0x79c8	; 0x79c8 <trunc>
              settings_store_startup_line(helper_var,line);
    6f9a:	0e 94 22 3a 	call	0x7444	; 0x7444 <__fixunssfsi>
    6f9e:	86 2f       	mov	r24, r22
    6fa0:	b8 01       	movw	r22, r16
    6fa2:	0e 94 ea 28 	call	0x51d4	; 0x51d4 <settings_store_startup_line>
    6fa6:	8a c0       	rjmp	.+276    	; 0x70bc <system_execute_line+0x3b8>
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    6fa8:	ae 01       	movw	r20, r28
    6faa:	4a 5f       	subi	r20, 0xFA	; 250
    6fac:	5f 4f       	sbci	r21, 0xFF	; 255
    6fae:	be 01       	movw	r22, r28
    6fb0:	6f 5f       	subi	r22, 0xFF	; 255
    6fb2:	7f 4f       	sbci	r23, 0xFF	; 255
    6fb4:	c8 01       	movw	r24, r16
    6fb6:	0e 94 65 18 	call	0x30ca	; 0x30ca <read_float>
    6fba:	88 23       	and	r24, r24
    6fbc:	09 f4       	brne	.+2      	; 0x6fc0 <system_execute_line+0x2bc>
    6fbe:	71 c0       	rjmp	.+226    	; 0x70a2 <system_execute_line+0x39e>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    6fc0:	89 81       	ldd	r24, Y+1	; 0x01
    6fc2:	f8 01       	movw	r30, r16
    6fc4:	e8 0f       	add	r30, r24
    6fc6:	f1 1d       	adc	r31, r1
    6fc8:	80 81       	ld	r24, Z
    6fca:	81 11       	cpse	r24, r1
    6fcc:	6e c0       	rjmp	.+220    	; 0x70aa <system_execute_line+0x3a6>
    6fce:	ca 80       	ldd	r12, Y+2	; 0x02
    6fd0:	db 80       	ldd	r13, Y+3	; 0x03
    6fd2:	ec 80       	ldd	r14, Y+4	; 0x04
    6fd4:	fd 80       	ldd	r15, Y+5	; 0x05
    6fd6:	20 e0       	ldi	r18, 0x00	; 0
    6fd8:	30 e0       	ldi	r19, 0x00	; 0
    6fda:	4f e7       	ldi	r20, 0x7F	; 127
    6fdc:	53 e4       	ldi	r21, 0x43	; 67
    6fde:	c7 01       	movw	r24, r14
    6fe0:	b6 01       	movw	r22, r12
    6fe2:	0e 94 c1 3b 	call	0x7782	; 0x7782 <__gesf2>
    6fe6:	18 16       	cp	r1, r24
    6fe8:	0c f4       	brge	.+2      	; 0x6fec <system_execute_line+0x2e8>
    6fea:	64 c0       	rjmp	.+200    	; 0x70b4 <system_execute_line+0x3b0>
            return(settings_store_global_setting((uint8_t)parameter, value));
    6fec:	8e 80       	ldd	r8, Y+6	; 0x06
    6fee:	9f 80       	ldd	r9, Y+7	; 0x07
    6ff0:	a8 84       	ldd	r10, Y+8	; 0x08
    6ff2:	b9 84       	ldd	r11, Y+9	; 0x09
    6ff4:	c7 01       	movw	r24, r14
    6ff6:	b6 01       	movw	r22, r12
    6ff8:	0e 94 22 3a 	call	0x7444	; 0x7444 <__fixunssfsi>
    6ffc:	86 2f       	mov	r24, r22
    6ffe:	b5 01       	movw	r22, r10
    7000:	a4 01       	movw	r20, r8
    7002:	0e 94 41 2a 	call	0x5482	; 0x5482 <settings_store_global_setting>
    7006:	f8 2e       	mov	r15, r24
    7008:	59 c0       	rjmp	.+178    	; 0x70bc <system_execute_line+0x3b8>
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[(char_counter+1)] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    700a:	0f 2e       	mov	r0, r31
    700c:	f3 e0       	ldi	r31, 0x03	; 3
    700e:	ff 2e       	mov	r15, r31
    7010:	f0 2d       	mov	r31, r0
    7012:	54 c0       	rjmp	.+168    	; 0x70bc <system_execute_line+0x3b8>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7014:	f1 2c       	mov	r15, r1
    7016:	52 c0       	rjmp	.+164    	; 0x70bc <system_execute_line+0x3b8>
    case 0 : report_grbl_help(); break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[(char_counter+1)] != 0 ) { return(STATUS_INVALID_STATEMENT); }
      switch( line[char_counter] ) {
        case '$' : // Prints Grbl settings
          if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    7018:	68 94       	set
    701a:	ff 24       	eor	r15, r15
    701c:	f3 f8       	bld	r15, 3
    701e:	4e c0       	rjmp	.+156    	; 0x70bc <system_execute_line+0x3b8>
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) { 
            mc_reset(); 
            report_feedback_message(MESSAGE_DISABLED);
          } else {
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    7020:	68 94       	set
    7022:	ff 24       	eor	r15, r15
    7024:	f3 f8       	bld	r15, 3
    7026:	4a c0       	rjmp	.+148    	; 0x70bc <system_execute_line+0x3b8>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7028:	f1 2c       	mov	r15, r1
    702a:	48 c0       	rjmp	.+144    	; 0x70bc <system_execute_line+0x3b8>
//       break;
      }
      break;
    default : 
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    702c:	68 94       	set
    702e:	ff 24       	eor	r15, r15
    7030:	f3 f8       	bld	r15, 3
    7032:	44 c0       	rjmp	.+136    	; 0x70bc <system_execute_line+0x3b8>
      switch( line[char_counter] ) {
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7034:	0f 2e       	mov	r0, r31
    7036:	f3 e0       	ldi	r31, 0x03	; 3
    7038:	ff 2e       	mov	r15, r31
    703a:	f0 2d       	mov	r31, r0
    703c:	3f c0       	rjmp	.+126    	; 0x70bc <system_execute_line+0x3b8>
            if (!sys.abort) {  // Execute startup scripts after successful homing.
              sys.state = STATE_IDLE; // Set to IDLE when complete.
              st_go_idle(); // Set steppers to the settings idle state before returning.
              system_execute_startup(line); 
            }
          } else { return(STATUS_SETTING_DISABLED); }
    703e:	0f 2e       	mov	r0, r31
    7040:	f5 e0       	ldi	r31, 0x05	; 5
    7042:	ff 2e       	mov	r15, r31
    7044:	f0 2d       	mov	r31, r0
    7046:	3a c0       	rjmp	.+116    	; 0x70bc <system_execute_line+0x3b8>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7048:	f1 2c       	mov	r15, r1
    704a:	38 c0       	rjmp	.+112    	; 0x70bc <system_execute_line+0x3b8>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
            settings_read_build_info(line);
            report_build_info(line);
          } else { // Store startup line [IDLE/ALARM]
            if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    704c:	0f 2e       	mov	r0, r31
    704e:	f3 e0       	ldi	r31, 0x03	; 3
    7050:	ff 2e       	mov	r15, r31
    7052:	f0 2d       	mov	r31, r0
    7054:	33 c0       	rjmp	.+102    	; 0x70bc <system_execute_line+0x3b8>
            } while (line[char_counter++] != 0);
            settings_store_build_info(line);
          }
          break; 
        case 'R' : // Restore defaults [IDLE/ALARM]
          if (line[++char_counter] != 'S') { return(STATUS_INVALID_STATEMENT); }
    7056:	0f 2e       	mov	r0, r31
    7058:	f3 e0       	ldi	r31, 0x03	; 3
    705a:	ff 2e       	mov	r15, r31
    705c:	f0 2d       	mov	r31, r0
    705e:	2e c0       	rjmp	.+92     	; 0x70bc <system_execute_line+0x3b8>
          if (line[++char_counter] != 'T') { return(STATUS_INVALID_STATEMENT); }
    7060:	0f 2e       	mov	r0, r31
    7062:	f3 e0       	ldi	r31, 0x03	; 3
    7064:	ff 2e       	mov	r15, r31
    7066:	f0 2d       	mov	r31, r0
    7068:	29 c0       	rjmp	.+82     	; 0x70bc <system_execute_line+0x3b8>
          if (line[++char_counter] != '=') { return(STATUS_INVALID_STATEMENT); }
    706a:	0f 2e       	mov	r0, r31
    706c:	f3 e0       	ldi	r31, 0x03	; 3
    706e:	ff 2e       	mov	r15, r31
    7070:	f0 2d       	mov	r31, r0
    7072:	24 c0       	rjmp	.+72     	; 0x70bc <system_execute_line+0x3b8>
          if (line[char_counter+2] != 0) { return(STATUS_INVALID_STATEMENT); }                        
    7074:	0f 2e       	mov	r0, r31
    7076:	f3 e0       	ldi	r31, 0x03	; 3
    7078:	ff 2e       	mov	r15, r31
    707a:	f0 2d       	mov	r31, r0
    707c:	1f c0       	rjmp	.+62     	; 0x70bc <system_execute_line+0x3b8>
          switch (line[++char_counter]) {
            case '$': settings_restore(SETTINGS_RESTORE_DEFAULTS); break;
            case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
            case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
            default: return(STATUS_INVALID_STATEMENT);
    707e:	0f 2e       	mov	r0, r31
    7080:	f3 e0       	ldi	r31, 0x03	; 3
    7082:	ff 2e       	mov	r15, r31
    7084:	f0 2d       	mov	r31, r0
    7086:	1a c0       	rjmp	.+52     	; 0x70bc <system_execute_line+0x3b8>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    7088:	68 94       	set
    708a:	ff 24       	eor	r15, r15
    708c:	f3 f8       	bld	r15, 3
    708e:	16 c0       	rjmp	.+44     	; 0x70bc <system_execute_line+0x3b8>
            helper_var = true;  // Set helper_var to flag storing method. 
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    7090:	68 94       	set
    7092:	ff 24       	eor	r15, r15
    7094:	f1 f8       	bld	r15, 1
    7096:	12 c0       	rjmp	.+36     	; 0x70bc <system_execute_line+0x3b8>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    7098:	0f 2e       	mov	r0, r31
    709a:	f3 e0       	ldi	r31, 0x03	; 3
    709c:	ff 2e       	mov	r15, r31
    709e:	f0 2d       	mov	r31, r0
    70a0:	0d c0       	rjmp	.+26     	; 0x70bc <system_execute_line+0x3b8>
            else { 
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
              settings_store_startup_line(helper_var,line);
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    70a2:	68 94       	set
    70a4:	ff 24       	eor	r15, r15
    70a6:	f1 f8       	bld	r15, 1
    70a8:	09 c0       	rjmp	.+18     	; 0x70bc <system_execute_line+0x3b8>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    70aa:	0f 2e       	mov	r0, r31
    70ac:	f3 e0       	ldi	r31, 0x03	; 3
    70ae:	ff 2e       	mov	r15, r31
    70b0:	f0 2d       	mov	r31, r0
    70b2:	04 c0       	rjmp	.+8      	; 0x70bc <system_execute_line+0x3b8>
    70b4:	0f 2e       	mov	r0, r31
    70b6:	f3 e0       	ldi	r31, 0x03	; 3
    70b8:	ff 2e       	mov	r15, r31
    70ba:	f0 2d       	mov	r31, r0
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
}
    70bc:	8f 2d       	mov	r24, r15
    70be:	29 96       	adiw	r28, 0x09	; 9
    70c0:	0f b6       	in	r0, 0x3f	; 63
    70c2:	f8 94       	cli
    70c4:	de bf       	out	0x3e, r29	; 62
    70c6:	0f be       	out	0x3f, r0	; 63
    70c8:	cd bf       	out	0x3d, r28	; 61
    70ca:	df 91       	pop	r29
    70cc:	cf 91       	pop	r28
    70ce:	1f 91       	pop	r17
    70d0:	0f 91       	pop	r16
    70d2:	ff 90       	pop	r15
    70d4:	ef 90       	pop	r14
    70d6:	df 90       	pop	r13
    70d8:	cf 90       	pop	r12
    70da:	bf 90       	pop	r11
    70dc:	af 90       	pop	r10
    70de:	9f 90       	pop	r9
    70e0:	8f 90       	pop	r8
    70e2:	08 95       	ret

000070e4 <system_convert_axis_steps_to_mpos>:

// Returns machine position of axis 'idx'. Must be sent a 'step' array.
// NOTE: If motor steps and machine position are not in the same coordinate frame, this function
//   serves as a central place to compute the transformation.
float system_convert_axis_steps_to_mpos(int32_t *steps, uint8_t idx)
{
    70e4:	cf 93       	push	r28
    70e6:	df 93       	push	r29
      pos = (float)system_convert_corexy_to_y_axis_steps(steps) / settings.steps_per_mm[B_MOTOR];
    } else {
      pos = steps[idx]/settings.steps_per_mm[idx];
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
    70e8:	c6 2f       	mov	r28, r22
    70ea:	d0 e0       	ldi	r29, 0x00	; 0
    70ec:	cc 0f       	add	r28, r28
    70ee:	dd 1f       	adc	r29, r29
    70f0:	cc 0f       	add	r28, r28
    70f2:	dd 1f       	adc	r29, r29
    70f4:	8c 0f       	add	r24, r28
    70f6:	9d 1f       	adc	r25, r29
  #endif
  return(pos);
    70f8:	fc 01       	movw	r30, r24
    70fa:	60 81       	ld	r22, Z
    70fc:	71 81       	ldd	r23, Z+1	; 0x01
    70fe:	82 81       	ldd	r24, Z+2	; 0x02
    7100:	93 81       	ldd	r25, Z+3	; 0x03
    7102:	0e 94 53 3a 	call	0x74a6	; 0x74a6 <__floatsisf>
      pos = (float)system_convert_corexy_to_y_axis_steps(steps) / settings.steps_per_mm[B_MOTOR];
    } else {
      pos = steps[idx]/settings.steps_per_mm[idx];
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
    7106:	c1 58       	subi	r28, 0x81	; 129
    7108:	d9 4f       	sbci	r29, 0xF9	; 249
  #endif
  return(pos);
    710a:	28 81       	ld	r18, Y
    710c:	39 81       	ldd	r19, Y+1	; 0x01
    710e:	4a 81       	ldd	r20, Y+2	; 0x02
    7110:	5b 81       	ldd	r21, Y+3	; 0x03
    7112:	0e 94 a9 39 	call	0x7352	; 0x7352 <__divsf3>
}
    7116:	df 91       	pop	r29
    7118:	cf 91       	pop	r28
    711a:	08 95       	ret

0000711c <system_convert_array_steps_to_mpos>:


void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
    711c:	ef 92       	push	r14
    711e:	ff 92       	push	r15
    7120:	0f 93       	push	r16
    7122:	1f 93       	push	r17
    7124:	cf 93       	push	r28
    7126:	7b 01       	movw	r14, r22
    7128:	8c 01       	movw	r16, r24
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    712a:	c0 e0       	ldi	r28, 0x00	; 0
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
    712c:	6c 2f       	mov	r22, r28
    712e:	c7 01       	movw	r24, r14
    7130:	0e 94 72 38 	call	0x70e4	; 0x70e4 <system_convert_axis_steps_to_mpos>
    7134:	f8 01       	movw	r30, r16
    7136:	61 93       	st	Z+, r22
    7138:	71 93       	st	Z+, r23
    713a:	81 93       	st	Z+, r24
    713c:	91 93       	st	Z+, r25
    713e:	8f 01       	movw	r16, r30


void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    7140:	cf 5f       	subi	r28, 0xFF	; 255
    7142:	c3 30       	cpi	r28, 0x03	; 3
    7144:	99 f7       	brne	.-26     	; 0x712c <system_convert_array_steps_to_mpos+0x10>
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
  }
  return;
}
    7146:	cf 91       	pop	r28
    7148:	1f 91       	pop	r17
    714a:	0f 91       	pop	r16
    714c:	ff 90       	pop	r15
    714e:	ef 90       	pop	r14
    7150:	08 95       	ret

00007152 <__subsf3>:
    7152:	50 58       	subi	r21, 0x80	; 128

00007154 <__addsf3>:
    7154:	bb 27       	eor	r27, r27
    7156:	aa 27       	eor	r26, r26
    7158:	0e 94 c1 38 	call	0x7182	; 0x7182 <__addsf3x>
    715c:	0c 94 5b 3b 	jmp	0x76b6	; 0x76b6 <__fp_round>
    7160:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fp_pscA>
    7164:	38 f0       	brcs	.+14     	; 0x7174 <__addsf3+0x20>
    7166:	0e 94 29 3b 	call	0x7652	; 0x7652 <__fp_pscB>
    716a:	20 f0       	brcs	.+8      	; 0x7174 <__addsf3+0x20>
    716c:	39 f4       	brne	.+14     	; 0x717c <__addsf3+0x28>
    716e:	9f 3f       	cpi	r25, 0xFF	; 255
    7170:	19 f4       	brne	.+6      	; 0x7178 <__addsf3+0x24>
    7172:	26 f4       	brtc	.+8      	; 0x717c <__addsf3+0x28>
    7174:	0c 94 f8 3a 	jmp	0x75f0	; 0x75f0 <__fp_nan>
    7178:	0e f4       	brtc	.+2      	; 0x717c <__addsf3+0x28>
    717a:	e0 95       	com	r30
    717c:	e7 fb       	bst	r30, 7
    717e:	0c 94 c9 3a 	jmp	0x7592	; 0x7592 <__fp_inf>

00007182 <__addsf3x>:
    7182:	e9 2f       	mov	r30, r25
    7184:	0e 94 80 3b 	call	0x7700	; 0x7700 <__fp_split3>
    7188:	58 f3       	brcs	.-42     	; 0x7160 <__addsf3+0xc>
    718a:	ba 17       	cp	r27, r26
    718c:	62 07       	cpc	r22, r18
    718e:	73 07       	cpc	r23, r19
    7190:	84 07       	cpc	r24, r20
    7192:	95 07       	cpc	r25, r21
    7194:	20 f0       	brcs	.+8      	; 0x719e <__addsf3x+0x1c>
    7196:	79 f4       	brne	.+30     	; 0x71b6 <__addsf3x+0x34>
    7198:	a6 f5       	brtc	.+104    	; 0x7202 <__addsf3x+0x80>
    719a:	0c 94 ba 3b 	jmp	0x7774	; 0x7774 <__fp_zero>
    719e:	0e f4       	brtc	.+2      	; 0x71a2 <__addsf3x+0x20>
    71a0:	e0 95       	com	r30
    71a2:	0b 2e       	mov	r0, r27
    71a4:	ba 2f       	mov	r27, r26
    71a6:	a0 2d       	mov	r26, r0
    71a8:	0b 01       	movw	r0, r22
    71aa:	b9 01       	movw	r22, r18
    71ac:	90 01       	movw	r18, r0
    71ae:	0c 01       	movw	r0, r24
    71b0:	ca 01       	movw	r24, r20
    71b2:	a0 01       	movw	r20, r0
    71b4:	11 24       	eor	r1, r1
    71b6:	ff 27       	eor	r31, r31
    71b8:	59 1b       	sub	r21, r25
    71ba:	99 f0       	breq	.+38     	; 0x71e2 <__addsf3x+0x60>
    71bc:	59 3f       	cpi	r21, 0xF9	; 249
    71be:	50 f4       	brcc	.+20     	; 0x71d4 <__addsf3x+0x52>
    71c0:	50 3e       	cpi	r21, 0xE0	; 224
    71c2:	68 f1       	brcs	.+90     	; 0x721e <__addsf3x+0x9c>
    71c4:	1a 16       	cp	r1, r26
    71c6:	f0 40       	sbci	r31, 0x00	; 0
    71c8:	a2 2f       	mov	r26, r18
    71ca:	23 2f       	mov	r18, r19
    71cc:	34 2f       	mov	r19, r20
    71ce:	44 27       	eor	r20, r20
    71d0:	58 5f       	subi	r21, 0xF8	; 248
    71d2:	f3 cf       	rjmp	.-26     	; 0x71ba <__addsf3x+0x38>
    71d4:	46 95       	lsr	r20
    71d6:	37 95       	ror	r19
    71d8:	27 95       	ror	r18
    71da:	a7 95       	ror	r26
    71dc:	f0 40       	sbci	r31, 0x00	; 0
    71de:	53 95       	inc	r21
    71e0:	c9 f7       	brne	.-14     	; 0x71d4 <__addsf3x+0x52>
    71e2:	7e f4       	brtc	.+30     	; 0x7202 <__addsf3x+0x80>
    71e4:	1f 16       	cp	r1, r31
    71e6:	ba 0b       	sbc	r27, r26
    71e8:	62 0b       	sbc	r22, r18
    71ea:	73 0b       	sbc	r23, r19
    71ec:	84 0b       	sbc	r24, r20
    71ee:	ba f0       	brmi	.+46     	; 0x721e <__addsf3x+0x9c>
    71f0:	91 50       	subi	r25, 0x01	; 1
    71f2:	a1 f0       	breq	.+40     	; 0x721c <__addsf3x+0x9a>
    71f4:	ff 0f       	add	r31, r31
    71f6:	bb 1f       	adc	r27, r27
    71f8:	66 1f       	adc	r22, r22
    71fa:	77 1f       	adc	r23, r23
    71fc:	88 1f       	adc	r24, r24
    71fe:	c2 f7       	brpl	.-16     	; 0x71f0 <__addsf3x+0x6e>
    7200:	0e c0       	rjmp	.+28     	; 0x721e <__addsf3x+0x9c>
    7202:	ba 0f       	add	r27, r26
    7204:	62 1f       	adc	r22, r18
    7206:	73 1f       	adc	r23, r19
    7208:	84 1f       	adc	r24, r20
    720a:	48 f4       	brcc	.+18     	; 0x721e <__addsf3x+0x9c>
    720c:	87 95       	ror	r24
    720e:	77 95       	ror	r23
    7210:	67 95       	ror	r22
    7212:	b7 95       	ror	r27
    7214:	f7 95       	ror	r31
    7216:	9e 3f       	cpi	r25, 0xFE	; 254
    7218:	08 f0       	brcs	.+2      	; 0x721c <__addsf3x+0x9a>
    721a:	b0 cf       	rjmp	.-160    	; 0x717c <__addsf3+0x28>
    721c:	93 95       	inc	r25
    721e:	88 0f       	add	r24, r24
    7220:	08 f0       	brcs	.+2      	; 0x7224 <__addsf3x+0xa2>
    7222:	99 27       	eor	r25, r25
    7224:	ee 0f       	add	r30, r30
    7226:	97 95       	ror	r25
    7228:	87 95       	ror	r24
    722a:	08 95       	ret
    722c:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fp_pscA>
    7230:	60 f0       	brcs	.+24     	; 0x724a <__addsf3x+0xc8>
    7232:	80 e8       	ldi	r24, 0x80	; 128
    7234:	91 e0       	ldi	r25, 0x01	; 1
    7236:	09 f4       	brne	.+2      	; 0x723a <__addsf3x+0xb8>
    7238:	9e ef       	ldi	r25, 0xFE	; 254
    723a:	0e 94 29 3b 	call	0x7652	; 0x7652 <__fp_pscB>
    723e:	28 f0       	brcs	.+10     	; 0x724a <__addsf3x+0xc8>
    7240:	40 e8       	ldi	r20, 0x80	; 128
    7242:	51 e0       	ldi	r21, 0x01	; 1
    7244:	71 f4       	brne	.+28     	; 0x7262 <atan2+0x10>
    7246:	5e ef       	ldi	r21, 0xFE	; 254
    7248:	0c c0       	rjmp	.+24     	; 0x7262 <atan2+0x10>
    724a:	0c 94 f8 3a 	jmp	0x75f0	; 0x75f0 <__fp_nan>
    724e:	0c 94 ba 3b 	jmp	0x7774	; 0x7774 <__fp_zero>

00007252 <atan2>:
    7252:	e9 2f       	mov	r30, r25
    7254:	e0 78       	andi	r30, 0x80	; 128
    7256:	0e 94 80 3b 	call	0x7700	; 0x7700 <__fp_split3>
    725a:	40 f3       	brcs	.-48     	; 0x722c <__addsf3x+0xaa>
    725c:	09 2e       	mov	r0, r25
    725e:	05 2a       	or	r0, r21
    7260:	b1 f3       	breq	.-20     	; 0x724e <__addsf3x+0xcc>
    7262:	26 17       	cp	r18, r22
    7264:	37 07       	cpc	r19, r23
    7266:	48 07       	cpc	r20, r24
    7268:	59 07       	cpc	r21, r25
    726a:	38 f0       	brcs	.+14     	; 0x727a <atan2+0x28>
    726c:	0e 2e       	mov	r0, r30
    726e:	07 f8       	bld	r0, 7
    7270:	e0 25       	eor	r30, r0
    7272:	69 f0       	breq	.+26     	; 0x728e <atan2+0x3c>
    7274:	e0 25       	eor	r30, r0
    7276:	e0 64       	ori	r30, 0x40	; 64
    7278:	0a c0       	rjmp	.+20     	; 0x728e <atan2+0x3c>
    727a:	ef 63       	ori	r30, 0x3F	; 63
    727c:	07 f8       	bld	r0, 7
    727e:	00 94       	com	r0
    7280:	07 fa       	bst	r0, 7
    7282:	db 01       	movw	r26, r22
    7284:	b9 01       	movw	r22, r18
    7286:	9d 01       	movw	r18, r26
    7288:	dc 01       	movw	r26, r24
    728a:	ca 01       	movw	r24, r20
    728c:	ad 01       	movw	r20, r26
    728e:	ef 93       	push	r30
    7290:	0e 94 c0 39 	call	0x7380	; 0x7380 <__divsf3_pse>
    7294:	0e 94 5b 3b 	call	0x76b6	; 0x76b6 <__fp_round>
    7298:	0e 94 59 39 	call	0x72b2	; 0x72b2 <atan>
    729c:	5f 91       	pop	r21
    729e:	55 23       	and	r21, r21
    72a0:	39 f0       	breq	.+14     	; 0x72b0 <atan2+0x5e>
    72a2:	2b ed       	ldi	r18, 0xDB	; 219
    72a4:	3f e0       	ldi	r19, 0x0F	; 15
    72a6:	49 e4       	ldi	r20, 0x49	; 73
    72a8:	50 fd       	sbrc	r21, 0
    72aa:	49 ec       	ldi	r20, 0xC9	; 201
    72ac:	0c 94 aa 38 	jmp	0x7154	; 0x7154 <__addsf3>
    72b0:	08 95       	ret

000072b2 <atan>:
    72b2:	df 93       	push	r29
    72b4:	dd 27       	eor	r29, r29
    72b6:	b9 2f       	mov	r27, r25
    72b8:	bf 77       	andi	r27, 0x7F	; 127
    72ba:	40 e8       	ldi	r20, 0x80	; 128
    72bc:	5f e3       	ldi	r21, 0x3F	; 63
    72be:	16 16       	cp	r1, r22
    72c0:	17 06       	cpc	r1, r23
    72c2:	48 07       	cpc	r20, r24
    72c4:	5b 07       	cpc	r21, r27
    72c6:	18 f4       	brcc	.+6      	; 0x72ce <atan+0x1c>
    72c8:	d9 2f       	mov	r29, r25
    72ca:	0e 94 c6 3b 	call	0x778c	; 0x778c <inverse>
    72ce:	9f 93       	push	r25
    72d0:	8f 93       	push	r24
    72d2:	7f 93       	push	r23
    72d4:	6f 93       	push	r22
    72d6:	0e 94 e0 3c 	call	0x79c0	; 0x79c0 <square>
    72da:	e4 ea       	ldi	r30, 0xA4	; 164
    72dc:	f2 e0       	ldi	r31, 0x02	; 2
    72de:	0e 94 fb 3a 	call	0x75f6	; 0x75f6 <__fp_powser>
    72e2:	0e 94 5b 3b 	call	0x76b6	; 0x76b6 <__fp_round>
    72e6:	2f 91       	pop	r18
    72e8:	3f 91       	pop	r19
    72ea:	4f 91       	pop	r20
    72ec:	5f 91       	pop	r21
    72ee:	0e 94 14 3c 	call	0x7828	; 0x7828 <__mulsf3x>
    72f2:	dd 23       	and	r29, r29
    72f4:	51 f0       	breq	.+20     	; 0x730a <atan+0x58>
    72f6:	90 58       	subi	r25, 0x80	; 128
    72f8:	a2 ea       	ldi	r26, 0xA2	; 162
    72fa:	2a ed       	ldi	r18, 0xDA	; 218
    72fc:	3f e0       	ldi	r19, 0x0F	; 15
    72fe:	49 ec       	ldi	r20, 0xC9	; 201
    7300:	5f e3       	ldi	r21, 0x3F	; 63
    7302:	d0 78       	andi	r29, 0x80	; 128
    7304:	5d 27       	eor	r21, r29
    7306:	0e 94 c1 38 	call	0x7182	; 0x7182 <__addsf3x>
    730a:	df 91       	pop	r29
    730c:	0c 94 5b 3b 	jmp	0x76b6	; 0x76b6 <__fp_round>

00007310 <ceil>:
    7310:	0e 94 a2 3b 	call	0x7744	; 0x7744 <__fp_trunc>
    7314:	90 f0       	brcs	.+36     	; 0x733a <ceil+0x2a>
    7316:	9f 37       	cpi	r25, 0x7F	; 127
    7318:	48 f4       	brcc	.+18     	; 0x732c <ceil+0x1c>
    731a:	91 11       	cpse	r25, r1
    731c:	16 f4       	brtc	.+4      	; 0x7322 <ceil+0x12>
    731e:	0c 94 bb 3b 	jmp	0x7776	; 0x7776 <__fp_szero>
    7322:	60 e0       	ldi	r22, 0x00	; 0
    7324:	70 e0       	ldi	r23, 0x00	; 0
    7326:	80 e8       	ldi	r24, 0x80	; 128
    7328:	9f e3       	ldi	r25, 0x3F	; 63
    732a:	08 95       	ret
    732c:	26 f0       	brts	.+8      	; 0x7336 <ceil+0x26>
    732e:	1b 16       	cp	r1, r27
    7330:	61 1d       	adc	r22, r1
    7332:	71 1d       	adc	r23, r1
    7334:	81 1d       	adc	r24, r1
    7336:	0c 94 cf 3a 	jmp	0x759e	; 0x759e <__fp_mintl>
    733a:	0c 94 ea 3a 	jmp	0x75d4	; 0x75d4 <__fp_mpack>

0000733e <__cmpsf2>:
    733e:	0e 94 a5 3a 	call	0x754a	; 0x754a <__fp_cmp>
    7342:	08 f4       	brcc	.+2      	; 0x7346 <__cmpsf2+0x8>
    7344:	81 e0       	ldi	r24, 0x01	; 1
    7346:	08 95       	ret

00007348 <cos>:
    7348:	0e 94 32 3b 	call	0x7664	; 0x7664 <__fp_rempio2>
    734c:	e3 95       	inc	r30
    734e:	0c 94 6c 3b 	jmp	0x76d8	; 0x76d8 <__fp_sinus>

00007352 <__divsf3>:
    7352:	0e 94 bd 39 	call	0x737a	; 0x737a <__divsf3x>
    7356:	0c 94 5b 3b 	jmp	0x76b6	; 0x76b6 <__fp_round>
    735a:	0e 94 29 3b 	call	0x7652	; 0x7652 <__fp_pscB>
    735e:	58 f0       	brcs	.+22     	; 0x7376 <__divsf3+0x24>
    7360:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fp_pscA>
    7364:	40 f0       	brcs	.+16     	; 0x7376 <__divsf3+0x24>
    7366:	29 f4       	brne	.+10     	; 0x7372 <__divsf3+0x20>
    7368:	5f 3f       	cpi	r21, 0xFF	; 255
    736a:	29 f0       	breq	.+10     	; 0x7376 <__divsf3+0x24>
    736c:	0c 94 c9 3a 	jmp	0x7592	; 0x7592 <__fp_inf>
    7370:	51 11       	cpse	r21, r1
    7372:	0c 94 bb 3b 	jmp	0x7776	; 0x7776 <__fp_szero>
    7376:	0c 94 f8 3a 	jmp	0x75f0	; 0x75f0 <__fp_nan>

0000737a <__divsf3x>:
    737a:	0e 94 80 3b 	call	0x7700	; 0x7700 <__fp_split3>
    737e:	68 f3       	brcs	.-38     	; 0x735a <__divsf3+0x8>

00007380 <__divsf3_pse>:
    7380:	99 23       	and	r25, r25
    7382:	b1 f3       	breq	.-20     	; 0x7370 <__divsf3+0x1e>
    7384:	55 23       	and	r21, r21
    7386:	91 f3       	breq	.-28     	; 0x736c <__divsf3+0x1a>
    7388:	95 1b       	sub	r25, r21
    738a:	55 0b       	sbc	r21, r21
    738c:	bb 27       	eor	r27, r27
    738e:	aa 27       	eor	r26, r26
    7390:	62 17       	cp	r22, r18
    7392:	73 07       	cpc	r23, r19
    7394:	84 07       	cpc	r24, r20
    7396:	38 f0       	brcs	.+14     	; 0x73a6 <__divsf3_pse+0x26>
    7398:	9f 5f       	subi	r25, 0xFF	; 255
    739a:	5f 4f       	sbci	r21, 0xFF	; 255
    739c:	22 0f       	add	r18, r18
    739e:	33 1f       	adc	r19, r19
    73a0:	44 1f       	adc	r20, r20
    73a2:	aa 1f       	adc	r26, r26
    73a4:	a9 f3       	breq	.-22     	; 0x7390 <__divsf3_pse+0x10>
    73a6:	35 d0       	rcall	.+106    	; 0x7412 <__divsf3_pse+0x92>
    73a8:	0e 2e       	mov	r0, r30
    73aa:	3a f0       	brmi	.+14     	; 0x73ba <__divsf3_pse+0x3a>
    73ac:	e0 e8       	ldi	r30, 0x80	; 128
    73ae:	32 d0       	rcall	.+100    	; 0x7414 <__divsf3_pse+0x94>
    73b0:	91 50       	subi	r25, 0x01	; 1
    73b2:	50 40       	sbci	r21, 0x00	; 0
    73b4:	e6 95       	lsr	r30
    73b6:	00 1c       	adc	r0, r0
    73b8:	ca f7       	brpl	.-14     	; 0x73ac <__divsf3_pse+0x2c>
    73ba:	2b d0       	rcall	.+86     	; 0x7412 <__divsf3_pse+0x92>
    73bc:	fe 2f       	mov	r31, r30
    73be:	29 d0       	rcall	.+82     	; 0x7412 <__divsf3_pse+0x92>
    73c0:	66 0f       	add	r22, r22
    73c2:	77 1f       	adc	r23, r23
    73c4:	88 1f       	adc	r24, r24
    73c6:	bb 1f       	adc	r27, r27
    73c8:	26 17       	cp	r18, r22
    73ca:	37 07       	cpc	r19, r23
    73cc:	48 07       	cpc	r20, r24
    73ce:	ab 07       	cpc	r26, r27
    73d0:	b0 e8       	ldi	r27, 0x80	; 128
    73d2:	09 f0       	breq	.+2      	; 0x73d6 <__divsf3_pse+0x56>
    73d4:	bb 0b       	sbc	r27, r27
    73d6:	80 2d       	mov	r24, r0
    73d8:	bf 01       	movw	r22, r30
    73da:	ff 27       	eor	r31, r31
    73dc:	93 58       	subi	r25, 0x83	; 131
    73de:	5f 4f       	sbci	r21, 0xFF	; 255
    73e0:	3a f0       	brmi	.+14     	; 0x73f0 <__divsf3_pse+0x70>
    73e2:	9e 3f       	cpi	r25, 0xFE	; 254
    73e4:	51 05       	cpc	r21, r1
    73e6:	78 f0       	brcs	.+30     	; 0x7406 <__divsf3_pse+0x86>
    73e8:	0c 94 c9 3a 	jmp	0x7592	; 0x7592 <__fp_inf>
    73ec:	0c 94 bb 3b 	jmp	0x7776	; 0x7776 <__fp_szero>
    73f0:	5f 3f       	cpi	r21, 0xFF	; 255
    73f2:	e4 f3       	brlt	.-8      	; 0x73ec <__divsf3_pse+0x6c>
    73f4:	98 3e       	cpi	r25, 0xE8	; 232
    73f6:	d4 f3       	brlt	.-12     	; 0x73ec <__divsf3_pse+0x6c>
    73f8:	86 95       	lsr	r24
    73fa:	77 95       	ror	r23
    73fc:	67 95       	ror	r22
    73fe:	b7 95       	ror	r27
    7400:	f7 95       	ror	r31
    7402:	9f 5f       	subi	r25, 0xFF	; 255
    7404:	c9 f7       	brne	.-14     	; 0x73f8 <__divsf3_pse+0x78>
    7406:	88 0f       	add	r24, r24
    7408:	91 1d       	adc	r25, r1
    740a:	96 95       	lsr	r25
    740c:	87 95       	ror	r24
    740e:	97 f9       	bld	r25, 7
    7410:	08 95       	ret
    7412:	e1 e0       	ldi	r30, 0x01	; 1
    7414:	66 0f       	add	r22, r22
    7416:	77 1f       	adc	r23, r23
    7418:	88 1f       	adc	r24, r24
    741a:	bb 1f       	adc	r27, r27
    741c:	62 17       	cp	r22, r18
    741e:	73 07       	cpc	r23, r19
    7420:	84 07       	cpc	r24, r20
    7422:	ba 07       	cpc	r27, r26
    7424:	20 f0       	brcs	.+8      	; 0x742e <__divsf3_pse+0xae>
    7426:	62 1b       	sub	r22, r18
    7428:	73 0b       	sbc	r23, r19
    742a:	84 0b       	sbc	r24, r20
    742c:	ba 0b       	sbc	r27, r26
    742e:	ee 1f       	adc	r30, r30
    7430:	88 f7       	brcc	.-30     	; 0x7414 <__divsf3_pse+0x94>
    7432:	e0 95       	com	r30
    7434:	08 95       	ret

00007436 <__fixsfsi>:
    7436:	0e 94 22 3a 	call	0x7444	; 0x7444 <__fixunssfsi>
    743a:	68 94       	set
    743c:	b1 11       	cpse	r27, r1
    743e:	0c 94 bb 3b 	jmp	0x7776	; 0x7776 <__fp_szero>
    7442:	08 95       	ret

00007444 <__fixunssfsi>:
    7444:	0e 94 88 3b 	call	0x7710	; 0x7710 <__fp_splitA>
    7448:	88 f0       	brcs	.+34     	; 0x746c <__fixunssfsi+0x28>
    744a:	9f 57       	subi	r25, 0x7F	; 127
    744c:	98 f0       	brcs	.+38     	; 0x7474 <__fixunssfsi+0x30>
    744e:	b9 2f       	mov	r27, r25
    7450:	99 27       	eor	r25, r25
    7452:	b7 51       	subi	r27, 0x17	; 23
    7454:	b0 f0       	brcs	.+44     	; 0x7482 <__fixunssfsi+0x3e>
    7456:	e1 f0       	breq	.+56     	; 0x7490 <__fixunssfsi+0x4c>
    7458:	66 0f       	add	r22, r22
    745a:	77 1f       	adc	r23, r23
    745c:	88 1f       	adc	r24, r24
    745e:	99 1f       	adc	r25, r25
    7460:	1a f0       	brmi	.+6      	; 0x7468 <__fixunssfsi+0x24>
    7462:	ba 95       	dec	r27
    7464:	c9 f7       	brne	.-14     	; 0x7458 <__fixunssfsi+0x14>
    7466:	14 c0       	rjmp	.+40     	; 0x7490 <__fixunssfsi+0x4c>
    7468:	b1 30       	cpi	r27, 0x01	; 1
    746a:	91 f0       	breq	.+36     	; 0x7490 <__fixunssfsi+0x4c>
    746c:	0e 94 ba 3b 	call	0x7774	; 0x7774 <__fp_zero>
    7470:	b1 e0       	ldi	r27, 0x01	; 1
    7472:	08 95       	ret
    7474:	0c 94 ba 3b 	jmp	0x7774	; 0x7774 <__fp_zero>
    7478:	67 2f       	mov	r22, r23
    747a:	78 2f       	mov	r23, r24
    747c:	88 27       	eor	r24, r24
    747e:	b8 5f       	subi	r27, 0xF8	; 248
    7480:	39 f0       	breq	.+14     	; 0x7490 <__fixunssfsi+0x4c>
    7482:	b9 3f       	cpi	r27, 0xF9	; 249
    7484:	cc f3       	brlt	.-14     	; 0x7478 <__fixunssfsi+0x34>
    7486:	86 95       	lsr	r24
    7488:	77 95       	ror	r23
    748a:	67 95       	ror	r22
    748c:	b3 95       	inc	r27
    748e:	d9 f7       	brne	.-10     	; 0x7486 <__fixunssfsi+0x42>
    7490:	3e f4       	brtc	.+14     	; 0x74a0 <__fixunssfsi+0x5c>
    7492:	90 95       	com	r25
    7494:	80 95       	com	r24
    7496:	70 95       	com	r23
    7498:	61 95       	neg	r22
    749a:	7f 4f       	sbci	r23, 0xFF	; 255
    749c:	8f 4f       	sbci	r24, 0xFF	; 255
    749e:	9f 4f       	sbci	r25, 0xFF	; 255
    74a0:	08 95       	ret

000074a2 <__floatunsisf>:
    74a2:	e8 94       	clt
    74a4:	09 c0       	rjmp	.+18     	; 0x74b8 <__floatsisf+0x12>

000074a6 <__floatsisf>:
    74a6:	97 fb       	bst	r25, 7
    74a8:	3e f4       	brtc	.+14     	; 0x74b8 <__floatsisf+0x12>
    74aa:	90 95       	com	r25
    74ac:	80 95       	com	r24
    74ae:	70 95       	com	r23
    74b0:	61 95       	neg	r22
    74b2:	7f 4f       	sbci	r23, 0xFF	; 255
    74b4:	8f 4f       	sbci	r24, 0xFF	; 255
    74b6:	9f 4f       	sbci	r25, 0xFF	; 255
    74b8:	99 23       	and	r25, r25
    74ba:	a9 f0       	breq	.+42     	; 0x74e6 <__floatsisf+0x40>
    74bc:	f9 2f       	mov	r31, r25
    74be:	96 e9       	ldi	r25, 0x96	; 150
    74c0:	bb 27       	eor	r27, r27
    74c2:	93 95       	inc	r25
    74c4:	f6 95       	lsr	r31
    74c6:	87 95       	ror	r24
    74c8:	77 95       	ror	r23
    74ca:	67 95       	ror	r22
    74cc:	b7 95       	ror	r27
    74ce:	f1 11       	cpse	r31, r1
    74d0:	f8 cf       	rjmp	.-16     	; 0x74c2 <__floatsisf+0x1c>
    74d2:	fa f4       	brpl	.+62     	; 0x7512 <__floatsisf+0x6c>
    74d4:	bb 0f       	add	r27, r27
    74d6:	11 f4       	brne	.+4      	; 0x74dc <__floatsisf+0x36>
    74d8:	60 ff       	sbrs	r22, 0
    74da:	1b c0       	rjmp	.+54     	; 0x7512 <__floatsisf+0x6c>
    74dc:	6f 5f       	subi	r22, 0xFF	; 255
    74de:	7f 4f       	sbci	r23, 0xFF	; 255
    74e0:	8f 4f       	sbci	r24, 0xFF	; 255
    74e2:	9f 4f       	sbci	r25, 0xFF	; 255
    74e4:	16 c0       	rjmp	.+44     	; 0x7512 <__floatsisf+0x6c>
    74e6:	88 23       	and	r24, r24
    74e8:	11 f0       	breq	.+4      	; 0x74ee <__floatsisf+0x48>
    74ea:	96 e9       	ldi	r25, 0x96	; 150
    74ec:	11 c0       	rjmp	.+34     	; 0x7510 <__floatsisf+0x6a>
    74ee:	77 23       	and	r23, r23
    74f0:	21 f0       	breq	.+8      	; 0x74fa <__floatsisf+0x54>
    74f2:	9e e8       	ldi	r25, 0x8E	; 142
    74f4:	87 2f       	mov	r24, r23
    74f6:	76 2f       	mov	r23, r22
    74f8:	05 c0       	rjmp	.+10     	; 0x7504 <__floatsisf+0x5e>
    74fa:	66 23       	and	r22, r22
    74fc:	71 f0       	breq	.+28     	; 0x751a <__floatsisf+0x74>
    74fe:	96 e8       	ldi	r25, 0x86	; 134
    7500:	86 2f       	mov	r24, r22
    7502:	70 e0       	ldi	r23, 0x00	; 0
    7504:	60 e0       	ldi	r22, 0x00	; 0
    7506:	2a f0       	brmi	.+10     	; 0x7512 <__floatsisf+0x6c>
    7508:	9a 95       	dec	r25
    750a:	66 0f       	add	r22, r22
    750c:	77 1f       	adc	r23, r23
    750e:	88 1f       	adc	r24, r24
    7510:	da f7       	brpl	.-10     	; 0x7508 <__floatsisf+0x62>
    7512:	88 0f       	add	r24, r24
    7514:	96 95       	lsr	r25
    7516:	87 95       	ror	r24
    7518:	97 f9       	bld	r25, 7
    751a:	08 95       	ret

0000751c <floor>:
    751c:	0e 94 a2 3b 	call	0x7744	; 0x7744 <__fp_trunc>
    7520:	90 f0       	brcs	.+36     	; 0x7546 <floor+0x2a>
    7522:	9f 37       	cpi	r25, 0x7F	; 127
    7524:	48 f4       	brcc	.+18     	; 0x7538 <floor+0x1c>
    7526:	91 11       	cpse	r25, r1
    7528:	16 f0       	brts	.+4      	; 0x752e <floor+0x12>
    752a:	0c 94 bb 3b 	jmp	0x7776	; 0x7776 <__fp_szero>
    752e:	60 e0       	ldi	r22, 0x00	; 0
    7530:	70 e0       	ldi	r23, 0x00	; 0
    7532:	80 e8       	ldi	r24, 0x80	; 128
    7534:	9f eb       	ldi	r25, 0xBF	; 191
    7536:	08 95       	ret
    7538:	26 f4       	brtc	.+8      	; 0x7542 <floor+0x26>
    753a:	1b 16       	cp	r1, r27
    753c:	61 1d       	adc	r22, r1
    753e:	71 1d       	adc	r23, r1
    7540:	81 1d       	adc	r24, r1
    7542:	0c 94 cf 3a 	jmp	0x759e	; 0x759e <__fp_mintl>
    7546:	0c 94 ea 3a 	jmp	0x75d4	; 0x75d4 <__fp_mpack>

0000754a <__fp_cmp>:
    754a:	99 0f       	add	r25, r25
    754c:	00 08       	sbc	r0, r0
    754e:	55 0f       	add	r21, r21
    7550:	aa 0b       	sbc	r26, r26
    7552:	e0 e8       	ldi	r30, 0x80	; 128
    7554:	fe ef       	ldi	r31, 0xFE	; 254
    7556:	16 16       	cp	r1, r22
    7558:	17 06       	cpc	r1, r23
    755a:	e8 07       	cpc	r30, r24
    755c:	f9 07       	cpc	r31, r25
    755e:	c0 f0       	brcs	.+48     	; 0x7590 <__fp_cmp+0x46>
    7560:	12 16       	cp	r1, r18
    7562:	13 06       	cpc	r1, r19
    7564:	e4 07       	cpc	r30, r20
    7566:	f5 07       	cpc	r31, r21
    7568:	98 f0       	brcs	.+38     	; 0x7590 <__fp_cmp+0x46>
    756a:	62 1b       	sub	r22, r18
    756c:	73 0b       	sbc	r23, r19
    756e:	84 0b       	sbc	r24, r20
    7570:	95 0b       	sbc	r25, r21
    7572:	39 f4       	brne	.+14     	; 0x7582 <__fp_cmp+0x38>
    7574:	0a 26       	eor	r0, r26
    7576:	61 f0       	breq	.+24     	; 0x7590 <__fp_cmp+0x46>
    7578:	23 2b       	or	r18, r19
    757a:	24 2b       	or	r18, r20
    757c:	25 2b       	or	r18, r21
    757e:	21 f4       	brne	.+8      	; 0x7588 <__fp_cmp+0x3e>
    7580:	08 95       	ret
    7582:	0a 26       	eor	r0, r26
    7584:	09 f4       	brne	.+2      	; 0x7588 <__fp_cmp+0x3e>
    7586:	a1 40       	sbci	r26, 0x01	; 1
    7588:	a6 95       	lsr	r26
    758a:	8f ef       	ldi	r24, 0xFF	; 255
    758c:	81 1d       	adc	r24, r1
    758e:	81 1d       	adc	r24, r1
    7590:	08 95       	ret

00007592 <__fp_inf>:
    7592:	97 f9       	bld	r25, 7
    7594:	9f 67       	ori	r25, 0x7F	; 127
    7596:	80 e8       	ldi	r24, 0x80	; 128
    7598:	70 e0       	ldi	r23, 0x00	; 0
    759a:	60 e0       	ldi	r22, 0x00	; 0
    759c:	08 95       	ret

0000759e <__fp_mintl>:
    759e:	88 23       	and	r24, r24
    75a0:	71 f4       	brne	.+28     	; 0x75be <__fp_mintl+0x20>
    75a2:	77 23       	and	r23, r23
    75a4:	21 f0       	breq	.+8      	; 0x75ae <__fp_mintl+0x10>
    75a6:	98 50       	subi	r25, 0x08	; 8
    75a8:	87 2b       	or	r24, r23
    75aa:	76 2f       	mov	r23, r22
    75ac:	07 c0       	rjmp	.+14     	; 0x75bc <__fp_mintl+0x1e>
    75ae:	66 23       	and	r22, r22
    75b0:	11 f4       	brne	.+4      	; 0x75b6 <__fp_mintl+0x18>
    75b2:	99 27       	eor	r25, r25
    75b4:	0d c0       	rjmp	.+26     	; 0x75d0 <__fp_mintl+0x32>
    75b6:	90 51       	subi	r25, 0x10	; 16
    75b8:	86 2b       	or	r24, r22
    75ba:	70 e0       	ldi	r23, 0x00	; 0
    75bc:	60 e0       	ldi	r22, 0x00	; 0
    75be:	2a f0       	brmi	.+10     	; 0x75ca <__fp_mintl+0x2c>
    75c0:	9a 95       	dec	r25
    75c2:	66 0f       	add	r22, r22
    75c4:	77 1f       	adc	r23, r23
    75c6:	88 1f       	adc	r24, r24
    75c8:	da f7       	brpl	.-10     	; 0x75c0 <__fp_mintl+0x22>
    75ca:	88 0f       	add	r24, r24
    75cc:	96 95       	lsr	r25
    75ce:	87 95       	ror	r24
    75d0:	97 f9       	bld	r25, 7
    75d2:	08 95       	ret

000075d4 <__fp_mpack>:
    75d4:	9f 3f       	cpi	r25, 0xFF	; 255
    75d6:	31 f0       	breq	.+12     	; 0x75e4 <__fp_mpack_finite+0xc>

000075d8 <__fp_mpack_finite>:
    75d8:	91 50       	subi	r25, 0x01	; 1
    75da:	20 f4       	brcc	.+8      	; 0x75e4 <__fp_mpack_finite+0xc>
    75dc:	87 95       	ror	r24
    75de:	77 95       	ror	r23
    75e0:	67 95       	ror	r22
    75e2:	b7 95       	ror	r27
    75e4:	88 0f       	add	r24, r24
    75e6:	91 1d       	adc	r25, r1
    75e8:	96 95       	lsr	r25
    75ea:	87 95       	ror	r24
    75ec:	97 f9       	bld	r25, 7
    75ee:	08 95       	ret

000075f0 <__fp_nan>:
    75f0:	9f ef       	ldi	r25, 0xFF	; 255
    75f2:	80 ec       	ldi	r24, 0xC0	; 192
    75f4:	08 95       	ret

000075f6 <__fp_powser>:
    75f6:	df 93       	push	r29
    75f8:	cf 93       	push	r28
    75fa:	1f 93       	push	r17
    75fc:	0f 93       	push	r16
    75fe:	ff 92       	push	r15
    7600:	ef 92       	push	r14
    7602:	df 92       	push	r13
    7604:	7b 01       	movw	r14, r22
    7606:	8c 01       	movw	r16, r24
    7608:	68 94       	set
    760a:	06 c0       	rjmp	.+12     	; 0x7618 <__fp_powser+0x22>
    760c:	da 2e       	mov	r13, r26
    760e:	ef 01       	movw	r28, r30
    7610:	0e 94 14 3c 	call	0x7828	; 0x7828 <__mulsf3x>
    7614:	fe 01       	movw	r30, r28
    7616:	e8 94       	clt
    7618:	a5 91       	lpm	r26, Z+
    761a:	25 91       	lpm	r18, Z+
    761c:	35 91       	lpm	r19, Z+
    761e:	45 91       	lpm	r20, Z+
    7620:	55 91       	lpm	r21, Z+
    7622:	a6 f3       	brts	.-24     	; 0x760c <__fp_powser+0x16>
    7624:	ef 01       	movw	r28, r30
    7626:	0e 94 c1 38 	call	0x7182	; 0x7182 <__addsf3x>
    762a:	fe 01       	movw	r30, r28
    762c:	97 01       	movw	r18, r14
    762e:	a8 01       	movw	r20, r16
    7630:	da 94       	dec	r13
    7632:	69 f7       	brne	.-38     	; 0x760e <__fp_powser+0x18>
    7634:	df 90       	pop	r13
    7636:	ef 90       	pop	r14
    7638:	ff 90       	pop	r15
    763a:	0f 91       	pop	r16
    763c:	1f 91       	pop	r17
    763e:	cf 91       	pop	r28
    7640:	df 91       	pop	r29
    7642:	08 95       	ret

00007644 <__fp_pscA>:
    7644:	00 24       	eor	r0, r0
    7646:	0a 94       	dec	r0
    7648:	16 16       	cp	r1, r22
    764a:	17 06       	cpc	r1, r23
    764c:	18 06       	cpc	r1, r24
    764e:	09 06       	cpc	r0, r25
    7650:	08 95       	ret

00007652 <__fp_pscB>:
    7652:	00 24       	eor	r0, r0
    7654:	0a 94       	dec	r0
    7656:	12 16       	cp	r1, r18
    7658:	13 06       	cpc	r1, r19
    765a:	14 06       	cpc	r1, r20
    765c:	05 06       	cpc	r0, r21
    765e:	08 95       	ret
    7660:	0c 94 f8 3a 	jmp	0x75f0	; 0x75f0 <__fp_nan>

00007664 <__fp_rempio2>:
    7664:	0e 94 88 3b 	call	0x7710	; 0x7710 <__fp_splitA>
    7668:	d8 f3       	brcs	.-10     	; 0x7660 <__fp_pscB+0xe>
    766a:	e8 94       	clt
    766c:	e0 e0       	ldi	r30, 0x00	; 0
    766e:	bb 27       	eor	r27, r27
    7670:	9f 57       	subi	r25, 0x7F	; 127
    7672:	f0 f0       	brcs	.+60     	; 0x76b0 <__fp_rempio2+0x4c>
    7674:	2a ed       	ldi	r18, 0xDA	; 218
    7676:	3f e0       	ldi	r19, 0x0F	; 15
    7678:	49 ec       	ldi	r20, 0xC9	; 201
    767a:	06 c0       	rjmp	.+12     	; 0x7688 <__fp_rempio2+0x24>
    767c:	ee 0f       	add	r30, r30
    767e:	bb 0f       	add	r27, r27
    7680:	66 1f       	adc	r22, r22
    7682:	77 1f       	adc	r23, r23
    7684:	88 1f       	adc	r24, r24
    7686:	28 f0       	brcs	.+10     	; 0x7692 <__fp_rempio2+0x2e>
    7688:	b2 3a       	cpi	r27, 0xA2	; 162
    768a:	62 07       	cpc	r22, r18
    768c:	73 07       	cpc	r23, r19
    768e:	84 07       	cpc	r24, r20
    7690:	28 f0       	brcs	.+10     	; 0x769c <__fp_rempio2+0x38>
    7692:	b2 5a       	subi	r27, 0xA2	; 162
    7694:	62 0b       	sbc	r22, r18
    7696:	73 0b       	sbc	r23, r19
    7698:	84 0b       	sbc	r24, r20
    769a:	e3 95       	inc	r30
    769c:	9a 95       	dec	r25
    769e:	72 f7       	brpl	.-36     	; 0x767c <__fp_rempio2+0x18>
    76a0:	80 38       	cpi	r24, 0x80	; 128
    76a2:	30 f4       	brcc	.+12     	; 0x76b0 <__fp_rempio2+0x4c>
    76a4:	9a 95       	dec	r25
    76a6:	bb 0f       	add	r27, r27
    76a8:	66 1f       	adc	r22, r22
    76aa:	77 1f       	adc	r23, r23
    76ac:	88 1f       	adc	r24, r24
    76ae:	d2 f7       	brpl	.-12     	; 0x76a4 <__fp_rempio2+0x40>
    76b0:	90 48       	sbci	r25, 0x80	; 128
    76b2:	0c 94 ec 3a 	jmp	0x75d8	; 0x75d8 <__fp_mpack_finite>

000076b6 <__fp_round>:
    76b6:	09 2e       	mov	r0, r25
    76b8:	03 94       	inc	r0
    76ba:	00 0c       	add	r0, r0
    76bc:	11 f4       	brne	.+4      	; 0x76c2 <__fp_round+0xc>
    76be:	88 23       	and	r24, r24
    76c0:	52 f0       	brmi	.+20     	; 0x76d6 <__fp_round+0x20>
    76c2:	bb 0f       	add	r27, r27
    76c4:	40 f4       	brcc	.+16     	; 0x76d6 <__fp_round+0x20>
    76c6:	bf 2b       	or	r27, r31
    76c8:	11 f4       	brne	.+4      	; 0x76ce <__fp_round+0x18>
    76ca:	60 ff       	sbrs	r22, 0
    76cc:	04 c0       	rjmp	.+8      	; 0x76d6 <__fp_round+0x20>
    76ce:	6f 5f       	subi	r22, 0xFF	; 255
    76d0:	7f 4f       	sbci	r23, 0xFF	; 255
    76d2:	8f 4f       	sbci	r24, 0xFF	; 255
    76d4:	9f 4f       	sbci	r25, 0xFF	; 255
    76d6:	08 95       	ret

000076d8 <__fp_sinus>:
    76d8:	ef 93       	push	r30
    76da:	e0 ff       	sbrs	r30, 0
    76dc:	07 c0       	rjmp	.+14     	; 0x76ec <__fp_sinus+0x14>
    76de:	a2 ea       	ldi	r26, 0xA2	; 162
    76e0:	2a ed       	ldi	r18, 0xDA	; 218
    76e2:	3f e0       	ldi	r19, 0x0F	; 15
    76e4:	49 ec       	ldi	r20, 0xC9	; 201
    76e6:	5f eb       	ldi	r21, 0xBF	; 191
    76e8:	0e 94 c1 38 	call	0x7182	; 0x7182 <__addsf3x>
    76ec:	0e 94 5b 3b 	call	0x76b6	; 0x76b6 <__fp_round>
    76f0:	0f 90       	pop	r0
    76f2:	03 94       	inc	r0
    76f4:	01 fc       	sbrc	r0, 1
    76f6:	90 58       	subi	r25, 0x80	; 128
    76f8:	e1 ed       	ldi	r30, 0xD1	; 209
    76fa:	f2 e0       	ldi	r31, 0x02	; 2
    76fc:	0c 94 f6 3c 	jmp	0x79ec	; 0x79ec <__fp_powsodd>

00007700 <__fp_split3>:
    7700:	57 fd       	sbrc	r21, 7
    7702:	90 58       	subi	r25, 0x80	; 128
    7704:	44 0f       	add	r20, r20
    7706:	55 1f       	adc	r21, r21
    7708:	59 f0       	breq	.+22     	; 0x7720 <__fp_splitA+0x10>
    770a:	5f 3f       	cpi	r21, 0xFF	; 255
    770c:	71 f0       	breq	.+28     	; 0x772a <__fp_splitA+0x1a>
    770e:	47 95       	ror	r20

00007710 <__fp_splitA>:
    7710:	88 0f       	add	r24, r24
    7712:	97 fb       	bst	r25, 7
    7714:	99 1f       	adc	r25, r25
    7716:	61 f0       	breq	.+24     	; 0x7730 <__fp_splitA+0x20>
    7718:	9f 3f       	cpi	r25, 0xFF	; 255
    771a:	79 f0       	breq	.+30     	; 0x773a <__fp_splitA+0x2a>
    771c:	87 95       	ror	r24
    771e:	08 95       	ret
    7720:	12 16       	cp	r1, r18
    7722:	13 06       	cpc	r1, r19
    7724:	14 06       	cpc	r1, r20
    7726:	55 1f       	adc	r21, r21
    7728:	f2 cf       	rjmp	.-28     	; 0x770e <__fp_split3+0xe>
    772a:	46 95       	lsr	r20
    772c:	f1 df       	rcall	.-30     	; 0x7710 <__fp_splitA>
    772e:	08 c0       	rjmp	.+16     	; 0x7740 <__fp_splitA+0x30>
    7730:	16 16       	cp	r1, r22
    7732:	17 06       	cpc	r1, r23
    7734:	18 06       	cpc	r1, r24
    7736:	99 1f       	adc	r25, r25
    7738:	f1 cf       	rjmp	.-30     	; 0x771c <__fp_splitA+0xc>
    773a:	86 95       	lsr	r24
    773c:	71 05       	cpc	r23, r1
    773e:	61 05       	cpc	r22, r1
    7740:	08 94       	sec
    7742:	08 95       	ret

00007744 <__fp_trunc>:
    7744:	0e 94 88 3b 	call	0x7710	; 0x7710 <__fp_splitA>
    7748:	a0 f0       	brcs	.+40     	; 0x7772 <__fp_trunc+0x2e>
    774a:	be e7       	ldi	r27, 0x7E	; 126
    774c:	b9 17       	cp	r27, r25
    774e:	88 f4       	brcc	.+34     	; 0x7772 <__fp_trunc+0x2e>
    7750:	bb 27       	eor	r27, r27
    7752:	9f 38       	cpi	r25, 0x8F	; 143
    7754:	60 f4       	brcc	.+24     	; 0x776e <__fp_trunc+0x2a>
    7756:	16 16       	cp	r1, r22
    7758:	b1 1d       	adc	r27, r1
    775a:	67 2f       	mov	r22, r23
    775c:	78 2f       	mov	r23, r24
    775e:	88 27       	eor	r24, r24
    7760:	98 5f       	subi	r25, 0xF8	; 248
    7762:	f7 cf       	rjmp	.-18     	; 0x7752 <__fp_trunc+0xe>
    7764:	86 95       	lsr	r24
    7766:	77 95       	ror	r23
    7768:	67 95       	ror	r22
    776a:	b1 1d       	adc	r27, r1
    776c:	93 95       	inc	r25
    776e:	96 39       	cpi	r25, 0x96	; 150
    7770:	c8 f3       	brcs	.-14     	; 0x7764 <__fp_trunc+0x20>
    7772:	08 95       	ret

00007774 <__fp_zero>:
    7774:	e8 94       	clt

00007776 <__fp_szero>:
    7776:	bb 27       	eor	r27, r27
    7778:	66 27       	eor	r22, r22
    777a:	77 27       	eor	r23, r23
    777c:	cb 01       	movw	r24, r22
    777e:	97 f9       	bld	r25, 7
    7780:	08 95       	ret

00007782 <__gesf2>:
    7782:	0e 94 a5 3a 	call	0x754a	; 0x754a <__fp_cmp>
    7786:	08 f4       	brcc	.+2      	; 0x778a <__gesf2+0x8>
    7788:	8f ef       	ldi	r24, 0xFF	; 255
    778a:	08 95       	ret

0000778c <inverse>:
    778c:	9b 01       	movw	r18, r22
    778e:	ac 01       	movw	r20, r24
    7790:	60 e0       	ldi	r22, 0x00	; 0
    7792:	70 e0       	ldi	r23, 0x00	; 0
    7794:	80 e8       	ldi	r24, 0x80	; 128
    7796:	9f e3       	ldi	r25, 0x3F	; 63
    7798:	0c 94 a9 39 	jmp	0x7352	; 0x7352 <__divsf3>

0000779c <lround>:
    779c:	0e 94 88 3b 	call	0x7710	; 0x7710 <__fp_splitA>
    77a0:	58 f1       	brcs	.+86     	; 0x77f8 <lround+0x5c>
    77a2:	9e 57       	subi	r25, 0x7E	; 126
    77a4:	60 f1       	brcs	.+88     	; 0x77fe <lround+0x62>
    77a6:	98 51       	subi	r25, 0x18	; 24
    77a8:	a0 f0       	brcs	.+40     	; 0x77d2 <lround+0x36>
    77aa:	e9 f0       	breq	.+58     	; 0x77e6 <lround+0x4a>
    77ac:	98 30       	cpi	r25, 0x08	; 8
    77ae:	20 f5       	brcc	.+72     	; 0x77f8 <lround+0x5c>
    77b0:	09 2e       	mov	r0, r25
    77b2:	99 27       	eor	r25, r25
    77b4:	66 0f       	add	r22, r22
    77b6:	77 1f       	adc	r23, r23
    77b8:	88 1f       	adc	r24, r24
    77ba:	99 1f       	adc	r25, r25
    77bc:	0a 94       	dec	r0
    77be:	d1 f7       	brne	.-12     	; 0x77b4 <lround+0x18>
    77c0:	12 c0       	rjmp	.+36     	; 0x77e6 <lround+0x4a>
    77c2:	06 2e       	mov	r0, r22
    77c4:	67 2f       	mov	r22, r23
    77c6:	78 2f       	mov	r23, r24
    77c8:	88 27       	eor	r24, r24
    77ca:	98 5f       	subi	r25, 0xF8	; 248
    77cc:	11 f4       	brne	.+4      	; 0x77d2 <lround+0x36>
    77ce:	00 0c       	add	r0, r0
    77d0:	07 c0       	rjmp	.+14     	; 0x77e0 <lround+0x44>
    77d2:	99 3f       	cpi	r25, 0xF9	; 249
    77d4:	b4 f3       	brlt	.-20     	; 0x77c2 <lround+0x26>
    77d6:	86 95       	lsr	r24
    77d8:	77 95       	ror	r23
    77da:	67 95       	ror	r22
    77dc:	93 95       	inc	r25
    77de:	d9 f7       	brne	.-10     	; 0x77d6 <lround+0x3a>
    77e0:	61 1d       	adc	r22, r1
    77e2:	71 1d       	adc	r23, r1
    77e4:	81 1d       	adc	r24, r1
    77e6:	3e f4       	brtc	.+14     	; 0x77f6 <lround+0x5a>
    77e8:	90 95       	com	r25
    77ea:	80 95       	com	r24
    77ec:	70 95       	com	r23
    77ee:	61 95       	neg	r22
    77f0:	7f 4f       	sbci	r23, 0xFF	; 255
    77f2:	8f 4f       	sbci	r24, 0xFF	; 255
    77f4:	9f 4f       	sbci	r25, 0xFF	; 255
    77f6:	08 95       	ret
    77f8:	68 94       	set
    77fa:	0c 94 bb 3b 	jmp	0x7776	; 0x7776 <__fp_szero>
    77fe:	0c 94 ba 3b 	jmp	0x7774	; 0x7774 <__fp_zero>

00007802 <__mulsf3>:
    7802:	0e 94 14 3c 	call	0x7828	; 0x7828 <__mulsf3x>
    7806:	0c 94 5b 3b 	jmp	0x76b6	; 0x76b6 <__fp_round>
    780a:	0e 94 22 3b 	call	0x7644	; 0x7644 <__fp_pscA>
    780e:	38 f0       	brcs	.+14     	; 0x781e <__mulsf3+0x1c>
    7810:	0e 94 29 3b 	call	0x7652	; 0x7652 <__fp_pscB>
    7814:	20 f0       	brcs	.+8      	; 0x781e <__mulsf3+0x1c>
    7816:	95 23       	and	r25, r21
    7818:	11 f0       	breq	.+4      	; 0x781e <__mulsf3+0x1c>
    781a:	0c 94 c9 3a 	jmp	0x7592	; 0x7592 <__fp_inf>
    781e:	0c 94 f8 3a 	jmp	0x75f0	; 0x75f0 <__fp_nan>
    7822:	11 24       	eor	r1, r1
    7824:	0c 94 bb 3b 	jmp	0x7776	; 0x7776 <__fp_szero>

00007828 <__mulsf3x>:
    7828:	0e 94 80 3b 	call	0x7700	; 0x7700 <__fp_split3>
    782c:	70 f3       	brcs	.-36     	; 0x780a <__mulsf3+0x8>

0000782e <__mulsf3_pse>:
    782e:	95 9f       	mul	r25, r21
    7830:	c1 f3       	breq	.-16     	; 0x7822 <__mulsf3+0x20>
    7832:	95 0f       	add	r25, r21
    7834:	50 e0       	ldi	r21, 0x00	; 0
    7836:	55 1f       	adc	r21, r21
    7838:	62 9f       	mul	r22, r18
    783a:	f0 01       	movw	r30, r0
    783c:	72 9f       	mul	r23, r18
    783e:	bb 27       	eor	r27, r27
    7840:	f0 0d       	add	r31, r0
    7842:	b1 1d       	adc	r27, r1
    7844:	63 9f       	mul	r22, r19
    7846:	aa 27       	eor	r26, r26
    7848:	f0 0d       	add	r31, r0
    784a:	b1 1d       	adc	r27, r1
    784c:	aa 1f       	adc	r26, r26
    784e:	64 9f       	mul	r22, r20
    7850:	66 27       	eor	r22, r22
    7852:	b0 0d       	add	r27, r0
    7854:	a1 1d       	adc	r26, r1
    7856:	66 1f       	adc	r22, r22
    7858:	82 9f       	mul	r24, r18
    785a:	22 27       	eor	r18, r18
    785c:	b0 0d       	add	r27, r0
    785e:	a1 1d       	adc	r26, r1
    7860:	62 1f       	adc	r22, r18
    7862:	73 9f       	mul	r23, r19
    7864:	b0 0d       	add	r27, r0
    7866:	a1 1d       	adc	r26, r1
    7868:	62 1f       	adc	r22, r18
    786a:	83 9f       	mul	r24, r19
    786c:	a0 0d       	add	r26, r0
    786e:	61 1d       	adc	r22, r1
    7870:	22 1f       	adc	r18, r18
    7872:	74 9f       	mul	r23, r20
    7874:	33 27       	eor	r19, r19
    7876:	a0 0d       	add	r26, r0
    7878:	61 1d       	adc	r22, r1
    787a:	23 1f       	adc	r18, r19
    787c:	84 9f       	mul	r24, r20
    787e:	60 0d       	add	r22, r0
    7880:	21 1d       	adc	r18, r1
    7882:	82 2f       	mov	r24, r18
    7884:	76 2f       	mov	r23, r22
    7886:	6a 2f       	mov	r22, r26
    7888:	11 24       	eor	r1, r1
    788a:	9f 57       	subi	r25, 0x7F	; 127
    788c:	50 40       	sbci	r21, 0x00	; 0
    788e:	9a f0       	brmi	.+38     	; 0x78b6 <__mulsf3_pse+0x88>
    7890:	f1 f0       	breq	.+60     	; 0x78ce <__mulsf3_pse+0xa0>
    7892:	88 23       	and	r24, r24
    7894:	4a f0       	brmi	.+18     	; 0x78a8 <__mulsf3_pse+0x7a>
    7896:	ee 0f       	add	r30, r30
    7898:	ff 1f       	adc	r31, r31
    789a:	bb 1f       	adc	r27, r27
    789c:	66 1f       	adc	r22, r22
    789e:	77 1f       	adc	r23, r23
    78a0:	88 1f       	adc	r24, r24
    78a2:	91 50       	subi	r25, 0x01	; 1
    78a4:	50 40       	sbci	r21, 0x00	; 0
    78a6:	a9 f7       	brne	.-22     	; 0x7892 <__mulsf3_pse+0x64>
    78a8:	9e 3f       	cpi	r25, 0xFE	; 254
    78aa:	51 05       	cpc	r21, r1
    78ac:	80 f0       	brcs	.+32     	; 0x78ce <__mulsf3_pse+0xa0>
    78ae:	0c 94 c9 3a 	jmp	0x7592	; 0x7592 <__fp_inf>
    78b2:	0c 94 bb 3b 	jmp	0x7776	; 0x7776 <__fp_szero>
    78b6:	5f 3f       	cpi	r21, 0xFF	; 255
    78b8:	e4 f3       	brlt	.-8      	; 0x78b2 <__mulsf3_pse+0x84>
    78ba:	98 3e       	cpi	r25, 0xE8	; 232
    78bc:	d4 f3       	brlt	.-12     	; 0x78b2 <__mulsf3_pse+0x84>
    78be:	86 95       	lsr	r24
    78c0:	77 95       	ror	r23
    78c2:	67 95       	ror	r22
    78c4:	b7 95       	ror	r27
    78c6:	f7 95       	ror	r31
    78c8:	e7 95       	ror	r30
    78ca:	9f 5f       	subi	r25, 0xFF	; 255
    78cc:	c1 f7       	brne	.-16     	; 0x78be <__mulsf3_pse+0x90>
    78ce:	fe 2b       	or	r31, r30
    78d0:	88 0f       	add	r24, r24
    78d2:	91 1d       	adc	r25, r1
    78d4:	96 95       	lsr	r25
    78d6:	87 95       	ror	r24
    78d8:	97 f9       	bld	r25, 7
    78da:	08 95       	ret

000078dc <round>:
    78dc:	0e 94 88 3b 	call	0x7710	; 0x7710 <__fp_splitA>
    78e0:	e8 f0       	brcs	.+58     	; 0x791c <round+0x40>
    78e2:	9e 37       	cpi	r25, 0x7E	; 126
    78e4:	e8 f0       	brcs	.+58     	; 0x7920 <round+0x44>
    78e6:	96 39       	cpi	r25, 0x96	; 150
    78e8:	b8 f4       	brcc	.+46     	; 0x7918 <round+0x3c>
    78ea:	9e 38       	cpi	r25, 0x8E	; 142
    78ec:	48 f4       	brcc	.+18     	; 0x7900 <round+0x24>
    78ee:	67 2f       	mov	r22, r23
    78f0:	78 2f       	mov	r23, r24
    78f2:	88 27       	eor	r24, r24
    78f4:	98 5f       	subi	r25, 0xF8	; 248
    78f6:	f9 cf       	rjmp	.-14     	; 0x78ea <round+0xe>
    78f8:	86 95       	lsr	r24
    78fa:	77 95       	ror	r23
    78fc:	67 95       	ror	r22
    78fe:	93 95       	inc	r25
    7900:	95 39       	cpi	r25, 0x95	; 149
    7902:	d0 f3       	brcs	.-12     	; 0x78f8 <round+0x1c>
    7904:	b6 2f       	mov	r27, r22
    7906:	b1 70       	andi	r27, 0x01	; 1
    7908:	6b 0f       	add	r22, r27
    790a:	71 1d       	adc	r23, r1
    790c:	81 1d       	adc	r24, r1
    790e:	20 f4       	brcc	.+8      	; 0x7918 <round+0x3c>
    7910:	87 95       	ror	r24
    7912:	77 95       	ror	r23
    7914:	67 95       	ror	r22
    7916:	93 95       	inc	r25
    7918:	0c 94 cf 3a 	jmp	0x759e	; 0x759e <__fp_mintl>
    791c:	0c 94 ea 3a 	jmp	0x75d4	; 0x75d4 <__fp_mpack>
    7920:	0c 94 bb 3b 	jmp	0x7776	; 0x7776 <__fp_szero>

00007924 <sin>:
    7924:	9f 93       	push	r25
    7926:	0e 94 32 3b 	call	0x7664	; 0x7664 <__fp_rempio2>
    792a:	0f 90       	pop	r0
    792c:	07 fc       	sbrc	r0, 7
    792e:	ee 5f       	subi	r30, 0xFE	; 254
    7930:	0c 94 6c 3b 	jmp	0x76d8	; 0x76d8 <__fp_sinus>
    7934:	19 f4       	brne	.+6      	; 0x793c <sin+0x18>
    7936:	16 f4       	brtc	.+4      	; 0x793c <sin+0x18>
    7938:	0c 94 f8 3a 	jmp	0x75f0	; 0x75f0 <__fp_nan>
    793c:	0c 94 ea 3a 	jmp	0x75d4	; 0x75d4 <__fp_mpack>

00007940 <sqrt>:
    7940:	0e 94 88 3b 	call	0x7710	; 0x7710 <__fp_splitA>
    7944:	b8 f3       	brcs	.-18     	; 0x7934 <sin+0x10>
    7946:	99 23       	and	r25, r25
    7948:	c9 f3       	breq	.-14     	; 0x793c <sin+0x18>
    794a:	b6 f3       	brts	.-20     	; 0x7938 <sin+0x14>
    794c:	9f 57       	subi	r25, 0x7F	; 127
    794e:	55 0b       	sbc	r21, r21
    7950:	87 ff       	sbrs	r24, 7
    7952:	0e 94 ef 3c 	call	0x79de	; 0x79de <__fp_norm2>
    7956:	00 24       	eor	r0, r0
    7958:	a0 e6       	ldi	r26, 0x60	; 96
    795a:	40 ea       	ldi	r20, 0xA0	; 160
    795c:	90 01       	movw	r18, r0
    795e:	80 58       	subi	r24, 0x80	; 128
    7960:	56 95       	lsr	r21
    7962:	97 95       	ror	r25
    7964:	28 f4       	brcc	.+10     	; 0x7970 <sqrt+0x30>
    7966:	80 5c       	subi	r24, 0xC0	; 192
    7968:	66 0f       	add	r22, r22
    796a:	77 1f       	adc	r23, r23
    796c:	88 1f       	adc	r24, r24
    796e:	20 f0       	brcs	.+8      	; 0x7978 <sqrt+0x38>
    7970:	26 17       	cp	r18, r22
    7972:	37 07       	cpc	r19, r23
    7974:	48 07       	cpc	r20, r24
    7976:	30 f4       	brcc	.+12     	; 0x7984 <sqrt+0x44>
    7978:	62 1b       	sub	r22, r18
    797a:	73 0b       	sbc	r23, r19
    797c:	84 0b       	sbc	r24, r20
    797e:	20 29       	or	r18, r0
    7980:	31 29       	or	r19, r1
    7982:	4a 2b       	or	r20, r26
    7984:	a6 95       	lsr	r26
    7986:	17 94       	ror	r1
    7988:	07 94       	ror	r0
    798a:	20 25       	eor	r18, r0
    798c:	31 25       	eor	r19, r1
    798e:	4a 27       	eor	r20, r26
    7990:	58 f7       	brcc	.-42     	; 0x7968 <sqrt+0x28>
    7992:	66 0f       	add	r22, r22
    7994:	77 1f       	adc	r23, r23
    7996:	88 1f       	adc	r24, r24
    7998:	20 f0       	brcs	.+8      	; 0x79a2 <sqrt+0x62>
    799a:	26 17       	cp	r18, r22
    799c:	37 07       	cpc	r19, r23
    799e:	48 07       	cpc	r20, r24
    79a0:	30 f4       	brcc	.+12     	; 0x79ae <sqrt+0x6e>
    79a2:	62 0b       	sbc	r22, r18
    79a4:	73 0b       	sbc	r23, r19
    79a6:	84 0b       	sbc	r24, r20
    79a8:	20 0d       	add	r18, r0
    79aa:	31 1d       	adc	r19, r1
    79ac:	41 1d       	adc	r20, r1
    79ae:	a0 95       	com	r26
    79b0:	81 f7       	brne	.-32     	; 0x7992 <sqrt+0x52>
    79b2:	b9 01       	movw	r22, r18
    79b4:	84 2f       	mov	r24, r20
    79b6:	91 58       	subi	r25, 0x81	; 129
    79b8:	88 0f       	add	r24, r24
    79ba:	96 95       	lsr	r25
    79bc:	87 95       	ror	r24
    79be:	08 95       	ret

000079c0 <square>:
    79c0:	9b 01       	movw	r18, r22
    79c2:	ac 01       	movw	r20, r24
    79c4:	0c 94 01 3c 	jmp	0x7802	; 0x7802 <__mulsf3>

000079c8 <trunc>:
    79c8:	0e 94 a2 3b 	call	0x7744	; 0x7744 <__fp_trunc>
    79cc:	30 f0       	brcs	.+12     	; 0x79da <trunc+0x12>
    79ce:	9f 37       	cpi	r25, 0x7F	; 127
    79d0:	10 f4       	brcc	.+4      	; 0x79d6 <trunc+0xe>
    79d2:	0c 94 bb 3b 	jmp	0x7776	; 0x7776 <__fp_szero>
    79d6:	0c 94 cf 3a 	jmp	0x759e	; 0x759e <__fp_mintl>
    79da:	0c 94 ea 3a 	jmp	0x75d4	; 0x75d4 <__fp_mpack>

000079de <__fp_norm2>:
    79de:	91 50       	subi	r25, 0x01	; 1
    79e0:	50 40       	sbci	r21, 0x00	; 0
    79e2:	66 0f       	add	r22, r22
    79e4:	77 1f       	adc	r23, r23
    79e6:	88 1f       	adc	r24, r24
    79e8:	d2 f7       	brpl	.-12     	; 0x79de <__fp_norm2>
    79ea:	08 95       	ret

000079ec <__fp_powsodd>:
    79ec:	9f 93       	push	r25
    79ee:	8f 93       	push	r24
    79f0:	7f 93       	push	r23
    79f2:	6f 93       	push	r22
    79f4:	ff 93       	push	r31
    79f6:	ef 93       	push	r30
    79f8:	9b 01       	movw	r18, r22
    79fa:	ac 01       	movw	r20, r24
    79fc:	0e 94 01 3c 	call	0x7802	; 0x7802 <__mulsf3>
    7a00:	ef 91       	pop	r30
    7a02:	ff 91       	pop	r31
    7a04:	0e 94 fb 3a 	call	0x75f6	; 0x75f6 <__fp_powser>
    7a08:	2f 91       	pop	r18
    7a0a:	3f 91       	pop	r19
    7a0c:	4f 91       	pop	r20
    7a0e:	5f 91       	pop	r21
    7a10:	0c 94 01 3c 	jmp	0x7802	; 0x7802 <__mulsf3>

00007a14 <__udivmodqi4>:
    7a14:	99 1b       	sub	r25, r25
    7a16:	79 e0       	ldi	r23, 0x09	; 9
    7a18:	04 c0       	rjmp	.+8      	; 0x7a22 <__udivmodqi4_ep>

00007a1a <__udivmodqi4_loop>:
    7a1a:	99 1f       	adc	r25, r25
    7a1c:	96 17       	cp	r25, r22
    7a1e:	08 f0       	brcs	.+2      	; 0x7a22 <__udivmodqi4_ep>
    7a20:	96 1b       	sub	r25, r22

00007a22 <__udivmodqi4_ep>:
    7a22:	88 1f       	adc	r24, r24
    7a24:	7a 95       	dec	r23
    7a26:	c9 f7       	brne	.-14     	; 0x7a1a <__udivmodqi4_loop>
    7a28:	80 95       	com	r24
    7a2a:	08 95       	ret

00007a2c <__udivmodsi4>:
    7a2c:	a1 e2       	ldi	r26, 0x21	; 33
    7a2e:	1a 2e       	mov	r1, r26
    7a30:	aa 1b       	sub	r26, r26
    7a32:	bb 1b       	sub	r27, r27
    7a34:	fd 01       	movw	r30, r26
    7a36:	0d c0       	rjmp	.+26     	; 0x7a52 <__udivmodsi4_ep>

00007a38 <__udivmodsi4_loop>:
    7a38:	aa 1f       	adc	r26, r26
    7a3a:	bb 1f       	adc	r27, r27
    7a3c:	ee 1f       	adc	r30, r30
    7a3e:	ff 1f       	adc	r31, r31
    7a40:	a2 17       	cp	r26, r18
    7a42:	b3 07       	cpc	r27, r19
    7a44:	e4 07       	cpc	r30, r20
    7a46:	f5 07       	cpc	r31, r21
    7a48:	20 f0       	brcs	.+8      	; 0x7a52 <__udivmodsi4_ep>
    7a4a:	a2 1b       	sub	r26, r18
    7a4c:	b3 0b       	sbc	r27, r19
    7a4e:	e4 0b       	sbc	r30, r20
    7a50:	f5 0b       	sbc	r31, r21

00007a52 <__udivmodsi4_ep>:
    7a52:	66 1f       	adc	r22, r22
    7a54:	77 1f       	adc	r23, r23
    7a56:	88 1f       	adc	r24, r24
    7a58:	99 1f       	adc	r25, r25
    7a5a:	1a 94       	dec	r1
    7a5c:	69 f7       	brne	.-38     	; 0x7a38 <__udivmodsi4_loop>
    7a5e:	60 95       	com	r22
    7a60:	70 95       	com	r23
    7a62:	80 95       	com	r24
    7a64:	90 95       	com	r25
    7a66:	9b 01       	movw	r18, r22
    7a68:	ac 01       	movw	r20, r24
    7a6a:	bd 01       	movw	r22, r26
    7a6c:	cf 01       	movw	r24, r30
    7a6e:	08 95       	ret

00007a70 <__tablejump2__>:
    7a70:	ee 0f       	add	r30, r30
    7a72:	ff 1f       	adc	r31, r31
    7a74:	05 90       	lpm	r0, Z+
    7a76:	f4 91       	lpm	r31, Z
    7a78:	e0 2d       	mov	r30, r0
    7a7a:	09 94       	ijmp

00007a7c <_exit>:
    7a7c:	f8 94       	cli

00007a7e <__stop_program>:
    7a7e:	ff cf       	rjmp	.-2      	; 0x7a7e <__stop_program>
